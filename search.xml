<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Async</title>
    <url>/2016/06/13/Async/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>BFC及其应用</title>
    <url>/2021/07/09/BFC%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>BFC:块级格式化上下文<span id="more"></span></p>
<p>特性：</p>
<ol>
<li>内部box会在垂直方向，一个接一个地放置。</li>
<li>Box垂直方向的距离由margin决定，在一个BFC中，两个相邻的块级盒子的垂直外边距会产生折叠。</li>
<li>形成了BFC的区域不会与float box重叠</li>
<li>计算BFC高度时，浮动元素也参与计算</li>
<li>BFC在页面是个独立的容器，里外元素互不影响。<br>实现两列布局（不和浮动元素重叠）、清除浮动、防止margin重叠</li>
</ol>
<p>创建方式：</p>
<ol>
<li>body 根元素</li>
<li>float的值不能为none</li>
<li>overflow的值不能为visible</li>
<li>display的值为table-cell, table-caption, inline-block中的任何一个</li>
<li>position的值不为relative和static </li>
</ol>
<p>作用：</p>
<ol>
<li>两列布局</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;image.png&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我是超长的文字<span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">img &#123;</span><br><span class="line">    float:left</span><br><span class="line">&#125;</span><br><span class="line">p &#123;</span><br><span class="line">    overflow:hidden</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>解决浮动元素造成的父元素高度塌陷问题(清除浮动)：</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;parent&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;float&#x27;</span>&gt;</span>浮动元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">.parent &#123;</span><br><span class="line">    overflow:hidden;</span><br><span class="line">&#125;</span><br><span class="line">.float &#123;</span><br><span class="line">    float:left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>CNode-android笔记</title>
    <url>/2016/10/21/CNode-android%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>本文为开发CNode-android的笔记，供以后开发参考</p>
<span id="more"></span>
<h4 id="主页列表显示"><a href="#主页列表显示" class="headerlink" title="主页列表显示"></a>主页列表显示</h4><p>ListView的使用</p>
<pre><code>private List&lt;Map&lt;String, Object&gt;&gt;  dataList = new ArrayList&lt;&gt;();
 topicsList = (ListView) findViewById(R.id.topicsList);
topicsAdapter = new SimpleAdapter(this,dataList,R.layout.topic_item,new String[]&#123;&quot;title&quot;,&quot;loginname&quot;,&quot;reply_count&quot;,&quot;visit_count&quot;,&quot;last_reply_at&quot;,&quot;getCreate_at&quot;&#125;
        ,new int[]&#123;R.id.topicLitle,R.id.author_name,R.id.reply_count,R.id.visit_count,R.id.last_reply,R.id.create_at&#125;);
topicsList.setAdapter(topicsAdapter);
</code></pre>
<p>Retrofit的使用  </p>
<pre><code>compile &#39;com.squareup.retrofit2:retrofit:2.1.0&#39;
compile &#39;com.squareup.retrofit2:converter-gson:2.1.0&#39;
</code></pre>
<p>com.squareup.retrofit2:converter-gson:2.1.0不能漏掉，否则会报错，也可以用其他库，参考<a href="http://square.github.io/retrofit/">Retrofit官网</a></p>
<pre><code>Retrofit retrofit = new Retrofit.Builder()
.baseUrl(&quot;https://api.github.com&quot;)
.addConverterFactory(GsonConverterFactory.create())
.build();
</code></pre>
<p>调用的时候不能漏掉<code>.addConverterFactory(GsonConverterFactory.create())</code><br>“2016-10-12T05:36:31.914Z”类似字符串转化为Date方法:</p>
<pre><code>SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS&#39;Z&#39;&quot;);
Date last_reply_date = sdf.parse(last_reply_at);
</code></pre>
<h4 id="列表图片加载"><a href="#列表图片加载" class="headerlink" title="列表图片加载"></a>列表图片加载</h4><p>新建TopicListAdapter代替SimpleAdapter，TopicListAdapter继承BaseAdapter，主要重写getView方法，在getView中使用viewHolder，使listview滑动更加顺畅</p>
<pre><code>@Override
public View getView(int position, View convertView, ViewGroup parent) &#123;
    ViewHolder viewHolder;
    if (convertView == null) &#123;
        viewHolder = new ViewHolder();
        convertView = mInflater.inflate(R.layout.topic_item, null);
        viewHolder.author_image = (ImageView) convertView.findViewById(R.id.author_image);
        viewHolder.author_name = (TextView) convertView.findViewById(R.id.author_name);
        viewHolder.top = (LinearLayout) convertView.findViewById(R.id.top);
        viewHolder.good = (LinearLayout) convertView.findViewById(R.id.good);
        viewHolder.last_reply = (TextView) convertView.findViewById(R.id.last_reply);
        viewHolder.topicLitle = (TextView) convertView.findViewById(R.id.topicLitle);
        viewHolder.create_at = (TextView) convertView.findViewById(R.id.create_at);
        viewHolder.visit_count = (TextView) convertView.findViewById(R.id.visit_count);
        viewHolder.reply_count = (TextView) convertView.findViewById(R.id.reply_count);
        convertView.setTag(viewHolder);
    &#125; else &#123;
        viewHolder = (ViewHolder) convertView.getTag();
    &#125;
    Topic topic = dataList.get(position);
    viewHolder.author_name.setText(topic.getAuthor().getLoginname());
    viewHolder.top.setVisibility(topic.isTop() ? View.VISIBLE : View.GONE);
    viewHolder.good.setVisibility(topic.isGood() ? View.VISIBLE : View.GONE);
    viewHolder.last_reply.setText(Utils.getDateDiff(topic.getLast_reply_at()));
    viewHolder.topicLitle.setText(topic.getTitle());
    viewHolder.create_at.setText(Utils.formatDate(topic.getCreate_at()));
    viewHolder.visit_count.setText(topic.getVisit_count() + &quot;&quot;);
    viewHolder.reply_count.setText(topic.getReply_count() + &quot;&quot;);

    viewHolder.author_image.setImageResource(R.mipmap.ic_launcher);

    String authorImageUrl = topic.getAuthor().getAvatar_url().contains(&quot;http&quot;) ? topic.getAuthor().getAvatar_url() : &quot;https:&quot; + topic.getAuthor().getAvatar_url();
    viewHolder.author_image.setTag(authorImageUrl);
    showImageByAsyncTask(authorImageUrl, viewHolder.author_image);
    return convertView;
&#125;
</code></pre>
<p>使用AsyncTask实现图片的异步加载</p>
<pre><code>public class AuthorImageLoader extends AsyncTask &lt;String,Void,Bitmap&gt;&#123;
    ...
&#125;
</code></pre>
<p>AsyncTask是抽象类.AsyncTask定义了三种泛型类型 Params，Progress和Result。<br>　　1.Params 启动任务执行的输入参数，比如HTTP请求的URL。<br>　　2.Progress 后台任务执行的百分比。<br>　　3.Result 后台执行任务最终返回的结果，比如String。<br>主要重写doInBackground和onPostExecute方法</p>
<pre><code>@Override
protected Bitmap doInBackground(String... params) &#123;
    String url = params[0];
    Bitmap bitmap = getBitmapFromUrl(params[0]);
    return bitmap;
&#125;

@Override
protected void onPostExecute(Bitmap bitmap) &#123;
    super.onPostExecute(bitmap);
    if(mImageView.getTag().equals(mUrl))&#123;
        mImageView.setImageBitmap(bitmap);
    &#125;
&#125;
</code></pre>
<p>通过url获取bitmap</p>
<pre><code>public Bitmap getBitmapFromUrl(String url)&#123;
    Bitmap bitmap;
    InputStream is = null;
    try&#123;
        URL mUrl = new URL(url);
        HttpURLConnection mHttpURLConnection = (HttpURLConnection) mUrl.openConnection();
        is = new BufferedInputStream(mHttpURLConnection.getInputStream());
        bitmap = BitmapFactory.decodeStream(is);
        mHttpURLConnection.disconnect();
        return  bitmap;
    &#125;catch (Exception e)&#123;
        e.printStackTrace();
    &#125;finally &#123;
        try &#123;
            is.close();
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
    return null;
&#125;
</code></pre>
<p>参考：<a href="http://blog.csdn.net/dmk877/article/details/49366421">http://blog.csdn.net/dmk877/article/details/49366421</a></p>
<h4 id="上拉加载-下拉刷新"><a href="#上拉加载-下拉刷新" class="headerlink" title="上拉加载  下拉刷新"></a>上拉加载  下拉刷新</h4><p>下拉刷新，使用SwipeRefreshLayout，布局文件如下</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;android.support.v4.widget.SwipeRefreshLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:id=&quot;@+id/content_main&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;
    tools:context=&quot;com.demo.cnode_android.MainActivity&quot;
    tools:showIn=&quot;@layout/app_bar_main&quot;&gt;


    &lt;ListView
        android:id=&quot;@+id/topicsList&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:layout_alignParentEnd=&quot;true&quot;
        android:layout_alignParentTop=&quot;true&quot; /&gt;
&lt;/android.support.v4.widget.SwipeRefreshLayout&gt;
</code></pre>
<p>主要方法</p>
<pre><code>setOnRefreshListener(OnRefreshListener): 为布局添加一个Listener
setRefreshing(boolean): 显示或隐藏刷新进度条
isRefreshing(): 检查是否处于刷新状态
setColorScheme(): 设置进度条的颜色主题，最多能设置四种
</code></pre>
<p>上拉加载，为ListView添加setOnScrollListener，判断是否滑倒了底部</p>
<pre><code>topicsList.setOnScrollListener(new AbsListView.OnScrollListener() &#123;
    @Override
    public void onScrollStateChanged(AbsListView view, int scrollState) &#123;
       if(scrollState == AbsListView.OnScrollListener.SCROLL_STATE_IDLE)&#123;
            if(view.getLastVisiblePosition() == view.getCount()-1)&#123;
                page++;
                getList(false);
            &#125;
       &#125;

    &#125;

    @Override
    public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) &#123;

    &#125;
&#125;);
</code></pre>
<h4 id="导航抽屉NavigationView"><a href="#导航抽屉NavigationView" class="headerlink" title="导航抽屉NavigationView"></a>导航抽屉NavigationView</h4><p>布局：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;android.support.v4.widget.DrawerLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:id=&quot;@+id/drawer_layout&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:fitsSystemWindows=&quot;true&quot;
    tools:openDrawer=&quot;start&quot;&gt;

    &lt;include
        layout=&quot;@layout/app_bar_main&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot; /&gt;

    &lt;android.support.design.widget.NavigationView
        android:id=&quot;@+id/nav_view&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;match_parent&quot;
        android:layout_gravity=&quot;start&quot;
        android:fitsSystemWindows=&quot;true&quot;
        app:headerLayout=&quot;@layout/nav_header_main&quot;
        app:menu=&quot;@menu/activity_main_drawer&quot; /&gt;

&lt;/android.support.v4.widget.DrawerLayout&gt;
</code></pre>
<p>app:headerLayout接收一个layout，作为导航菜单顶部的Header。<br>app:menu接收一个menu，作为导航菜单的菜单项。activity_main_drawer如下：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;

    &lt;group android:checkableBehavior=&quot;single&quot;&gt;
        &lt;item
            android:id=&quot;@+id/all&quot;
            android:checked=&quot;true&quot;
            android:icon=&quot;@drawable/main_nav_ic_all&quot;
            android:title=&quot;全部&quot; /&gt;
        &lt;item
            android:id=&quot;@+id/good&quot;
            android:icon=&quot;@drawable/main_nav_ic_good&quot;
            android:title=&quot;精华&quot; /&gt;
        &lt;item
            android:id=&quot;@+id/share&quot;
            android:icon=&quot;@drawable/main_nav_ic_share&quot;
            android:title=&quot;分享&quot; /&gt;
        &lt;item
            android:id=&quot;@+id/ask&quot;
            android:icon=&quot;@drawable/main_nav_ic_ask&quot;
            android:title=&quot;问答&quot; /&gt;
        &lt;item
            android:id=&quot;@+id/job&quot;
            android:icon=&quot;@drawable/main_nav_ic_job&quot;
            android:title=&quot;招聘&quot; /&gt;
    &lt;/group&gt;


    &lt;group  android:id=&quot;@+id/group2&quot;&gt;
        &lt;item
            android:id=&quot;@+id/msg&quot;
            android:icon=&quot;@mipmap/ic_notifications_grey600_24dp&quot;
            android:title=&quot;消息&quot; /&gt;
        &lt;item
            android:id=&quot;@+id/setting&quot;
            android:icon=&quot;@mipmap/ic_settings_grey600_24dp&quot;
            android:title=&quot;设置&quot; /&gt;
        &lt;item
            android:id=&quot;@+id/about&quot;
            android:icon=&quot;@mipmap/ic_info_grey600_24dp&quot;
            android:title=&quot;关于&quot; /&gt;
    &lt;/group&gt;


&lt;/menu&gt;
</code></pre>
<p>分为两个group后，会多一条横线分割，checkableBehavior=”single”表示是单选，android:checked=”true”表示已选中。<br>用setNavigationItemSelectedListener方法来设置当导航项被点击时的回调：</p>
<pre><code>mNavigationView.setNavigationItemSelectedListener(new NavigationView.OnNavigationItemSelectedListener() &#123;
    @Override
    public boolean onNavigationItemSelected(MenuItem menuItem) &#123;
         // Handle navigation view item clicks here.
    int id = item.getItemId();

    if (id == R.id.all) &#123;
        page = 1;
        tab = &quot;&quot;;
        getList(true);
    &#125; else if (id == R.id.ask) &#123;
        page = 1;
        tab = &quot;ask&quot;;
        getList(true);
    &#125; else if (id == R.id.share) &#123;
        page = 1;
        tab = &quot;share&quot;;
        getList(true);
    &#125; else if (id == R.id.job) &#123;
        page = 1;
        tab = &quot;job&quot;;
        getList(true);
    &#125; else if (id == R.id.good) &#123;
        page = 1;
        tab = &quot;good&quot;;
        getList(true);
    &#125; else if (id == R.id.msg) &#123;

    &#125; else if (id == R.id.setting) &#123;

    &#125;else if(id == R.id.about)&#123;

    &#125;

    DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout);
    drawer.closeDrawer(GravityCompat.START);
    return true;
    &#125;
&#125;);
</code></pre>
<h4 id="使用Picasso实现圆形头像"><a href="#使用Picasso实现圆形头像" class="headerlink" title="使用Picasso实现圆形头像"></a>使用Picasso实现圆形头像</h4><p>官网例子（截取矩形图片中间部分为正方形）：</p>
<pre><code>public class CropSquareTransformation implements Transformation &#123;
  @Override public Bitmap transform(Bitmap source) &#123;
    int size = Math.min(source.getWidth(), source.getHeight());
    int x = (source.getWidth() - size) / 2;
    int y = (source.getHeight() - size) / 2;
    Bitmap result = Bitmap.createBitmap(source, x, y, size, size);
    if (result != source) &#123;
      source.recycle();
    &#125;
    return result;
  &#125;

  @Override public String key() &#123; return &quot;square()&quot;; &#125;
&#125;
</code></pre>
<p>参考官网例子，定义圆形转换器类</p>
<pre><code>public class CircleTransform implements Transformation &#123;
    @Override
    public Bitmap transform(Bitmap source) &#123;
         //获取Bitmap的宽度
        int width = source.getWidth();
        //返回一个正方形的Bitmap对象
        Bitmap mBitmap = Bitmap.createBitmap(width,width, Bitmap.Config.ARGB_8888);
        //定义指定宽高的canvas
        Canvas mCanvas = new Canvas(mBitmap);
        //定义画笔
        Paint mPaint = new Paint();
        //设置抗锯齿
        mPaint.setAntiAlias(true);
        //背景：在画布上绘制一个圆
        mCanvas.drawCircle(width/2,width/2,width/2,mPaint);
        //设置图片相交情况下的处理方式
        //setXfermode：设置当绘制的图像出现相交情况时候的处理方式的,它包含的常用模式有哪几种
        //PorterDuff.Mode.SRC_IN 取两层图像交集部门,只显示上层图像,注意这里是指取相交叉的部分,然后显示上层图像
        //PorterDuff.Mode.DST_IN 取两层图像交集部门,只显示下层图像
        mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));
        //前景：在画布上绘制一个bitmap
        mCanvas.drawBitmap(source,0,0,mPaint);
        //必须要回收source，否则会报错
        source.recycle();
        return mBitmap;
    &#125;

    @Override
    public String key() &#123;
        return &quot;square()&quot;;
    &#125;
&#125;
</code></pre>
<p>调用：</p>
<pre><code> private CircleTransform mCircleTransform = new CircleTransform();
Picasso.with(context)
            .load(authorImageUrl)
            .resize(100, 100)
            .centerCrop()
            .transform(mCircleTransform)
            .into(viewHolder.author_image);
</code></pre>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter生命周期</title>
    <url>/2021/03/31/Flutter%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<ul>
<li>initState:当Widget第一次插入到Widget树时会被调用,只会调用一次</li>
<li>didChangeDependencies:当State对象的依赖发生变化时会被调用</li>
<li>build:在如下方法之后调用：<br>  1.在调用didUpdateWidget()之后。<br>  2.在调用didChangeDependencies()之后。</li>
<li>didUpdateWidget:当组件的状态改变的时候就会调用didUpdateWidget,比如调用了setState.</li>
<li>deactivate:当State对象从树中被移除时，会调用此回调</li>
<li>dispose:当State对象从树中被永久移除时调用<span id="more"></span> 
<img src="/uploads/stateLifeCycle.png" alt="State Lifecycle">  </li>
</ul>
<h1 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h1>]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>GetX</title>
    <url>/2021/04/25/GetX/</url>
    <content><![CDATA[<h1 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h1><p>dart:async 库中有两个类型，它们对许多 Dart API 来说都非常重要： Stream 和 Future。 Future 用于表示单个运算的结果，而 Stream 则表示多个结果的序列。你可以监听 Stream 以获取其结果（包括数据和错误）或其关闭事件。也可以在 Stream 完成前对其暂停或停止监听。</p>
<span id="more"></span>

<p> async* 函数可以生成一个Stream, 用await for来迭代 Stream 中的事件，例子如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:async&#x27;</span>;</span><br><span class="line"></span><br><span class="line">Future&lt;<span class="built_in">int</span>&gt; sumStream(Stream&lt;<span class="built_in">int</span>&gt; stream) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">in</span> stream) &#123;</span><br><span class="line">    sum += value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stream&lt;<span class="built_in">int</span>&gt; countStream(<span class="built_in">int</span> to) <span class="keyword">async</span>* &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= to; i++) &#123;</span><br><span class="line">    <span class="keyword">yield</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> stream = countStream(<span class="number">10</span>);</span><br><span class="line">  <span class="keyword">var</span> sum = <span class="keyword">await</span> sumStream(stream);</span><br><span class="line">  <span class="built_in">print</span>(sum); <span class="comment">// 55</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用 StreamController 来创建 Stream，使用 Stream 的 listen()对Stream进行监听，例子如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Stream&lt;<span class="built_in">int</span>&gt; timedCounter(<span class="built_in">Duration</span> interval, [<span class="built_in">int</span> maxCount]) &#123;</span><br><span class="line">  StreamController&lt;<span class="built_in">int</span>&gt; controller;</span><br><span class="line">  Timer timer;</span><br><span class="line">  <span class="built_in">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> tick(_) &#123;</span><br><span class="line">    counter++;</span><br><span class="line">    controller.add(counter); <span class="comment">// 请求stream将计数器值作为事件发送。</span></span><br><span class="line">    <span class="keyword">if</span> (counter == maxCount) &#123;</span><br><span class="line">      timer.cancel();</span><br><span class="line">      controller.close(); <span class="comment">// 请求 stream 关闭并告知监听器。</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> startTimer() &#123;</span><br><span class="line">    timer = Timer.periodic(interval, tick);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> stopTimer() &#123;</span><br><span class="line">    <span class="keyword">if</span> (timer != <span class="keyword">null</span>) &#123;</span><br><span class="line">      timer.cancel();</span><br><span class="line">      timer = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  controller = StreamController&lt;<span class="built_in">int</span>&gt;(</span><br><span class="line">      onListen: startTimer,</span><br><span class="line">      onPause: stopTimer,</span><br><span class="line">      onResume: startTimer,</span><br><span class="line">      onCancel: stopTimer);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> controller.stream;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> listenWithPause() &#123;</span><br><span class="line">  <span class="keyword">var</span> counterStream = timedCounter(<span class="keyword">const</span> <span class="built_in">Duration</span>(seconds: <span class="number">1</span>), <span class="number">15</span>);</span><br><span class="line">  StreamSubscription&lt;<span class="built_in">int</span>&gt; subscription;</span><br><span class="line"></span><br><span class="line">  subscription = counterStream.listen((<span class="built_in">int</span> counter) &#123;</span><br><span class="line">    <span class="built_in">print</span>(counter); <span class="comment">// 每秒打印输出一个整数。</span></span><br><span class="line">    <span class="keyword">if</span> (counter == <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="comment">// 打印输出 5 次后暂停 5 秒然后恢复。</span></span><br><span class="line">      subscription.pause(Future.delayed(<span class="keyword">const</span> <span class="built_in">Duration</span>(seconds: <span class="number">5</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="StreamBuilder"><a href="#StreamBuilder" class="headerlink" title="StreamBuilder"></a>StreamBuilder</h1><p>StreamBuilder是用于配合Stream来展示流上事件（数据）变化的UI组件。StreamBuilder的默认构造函数如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">StreamBuilder(&#123;</span><br><span class="line">  Key key,</span><br><span class="line">  <span class="keyword">this</span>.initialData,</span><br><span class="line">  Stream&lt;T&gt; stream,</span><br><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.builder,</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure>
<p>使用StreamBuilder局部刷新例子如下:</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  MyHomePage(&#123;Key key, <span class="keyword">this</span>.title&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> title;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _MyHomePageState createState() =&gt; _MyHomePageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> index = <span class="number">0</span>;</span><br><span class="line">  StreamController streamController;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _incrementCounter() &#123;</span><br><span class="line">    index++;</span><br><span class="line">    streamController.add(index.toString());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    streamController = StreamController&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    streamController.close();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(widget.title),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            StreamBuilder&lt;<span class="built_in">String</span>&gt;(</span><br><span class="line">              initialData: index.toString(),</span><br><span class="line">              stream: streamController.stream,</span><br><span class="line">              builder: (BuildContext context, AsyncSnapshot&lt;<span class="built_in">String</span>&gt; snapshot) &#123;</span><br><span class="line">                <span class="keyword">return</span> Text(</span><br><span class="line">                  <span class="string">&#x27;<span class="subst">$&#123;snapshot.data&#125;</span>&#x27;</span>,</span><br><span class="line">                  style: Theme.of(context).textTheme.headline4,</span><br><span class="line">                );</span><br><span class="line">              &#125;,</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        onPressed: _incrementCounter,</span><br><span class="line">        tooltip: <span class="string">&#x27;Increment&#x27;</span>,</span><br><span class="line">        child: Icon(Icons.add),</span><br><span class="line">      ), <span class="comment">// This trailing comma makes auto-formatting nicer for build methods.</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="GetX"><a href="#GetX" class="headerlink" title="GetX"></a>GetX</h1><p>GetX 是 Flutter 上的一个轻量且强大的解决方案：高性能的状态管理、智能的依赖注入和便捷的路由管理。</p>
<p>使用GetX局部刷新例子如下:</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">final</span> Controller c = Get.put(Controller());</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">        <span class="comment">// 使用Obx(()=&gt;每当改变计数时，就更新Text()。</span></span><br><span class="line">        appBar: AppBar(title: Obx(() =&gt; Text(<span class="string">&quot;Clicks: <span class="subst">$&#123;c.count&#125;</span>&quot;</span>))),</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用一个简单的Get.to()即可代替Navigator.push那8行，无需上下文！</span></span><br><span class="line">        body: Center(</span><br><span class="line">            child: ElevatedButton(</span><br><span class="line">                child: Text(<span class="string">&quot;Go to Other&quot;</span>), onPressed: () =&gt; Get.to(() =&gt; Other()))),</span><br><span class="line">        floatingActionButton: FloatingActionButton(</span><br><span class="line">            child: Icon(Icons.add), onPressed: c.increment));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Other</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 你可以让Get找到一个正在被其他页面使用的Controller，并将它返回给你。</span></span><br><span class="line">  <span class="keyword">final</span> Controller c = Get.find();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(context) &#123;</span><br><span class="line">    <span class="comment">// 访问更新后的计数变量</span></span><br><span class="line">    <span class="keyword">return</span> Scaffold(body: Center(child: Text(<span class="string">&quot;<span class="subst">$&#123;c.count&#125;</span>&quot;</span>)));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><a href="https://github.com/jonataslaw/getx/blob/master/README.zh-cn.md">GetX文档</a></p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>InheritedWidge</title>
    <url>/2021/03/31/InheritedWidge/</url>
    <content><![CDATA[<p>InheritedWidget是Flutter中非常重要的一个功能型组件，它提供了一种数据在widget树中从上到下传递、共享的方式，比如我们在应用的根widget中通过InheritedWidget共享了一个数据，那么我们便可以在任意子widget中来获取该共享的数据！这个特性在一些需要在widget树中共享数据的场景中非常方便！如Flutter SDK中正是通过InheritedWidget来共享应用主题（Theme）和Locale (当前语言环境)信息的。  </p>
<span id="more"></span>  

<p>State对象有一个didChangeDependencies回调，它会在“依赖”发生变化时被Flutter Framework调用。而这个“依赖”指的就是子widget是否使用了父widget中InheritedWidget的数据！如果使用了，则代表子widget依赖有依赖InheritedWidget；如果没有使用则代表没有依赖。这种机制可以使子组件在所依赖的InheritedWidget变化时来更新自身！比如当主题、locale(语言)等发生变化时，依赖其的子widget的didChangeDependencies方法将会被调用。</p>
<p>“计数器”示例应用程序的InheritedWidget版本实现如下：</p>
<p>首先，我们通过继承InheritedWidget，将当前计数器点击次数保存在ShareDataWidget的data属性中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ShareDataWidget extends InheritedWidget &#123;</span><br><span class="line">  ShareDataWidget(&#123;</span><br><span class="line">    @required this.data,</span><br><span class="line">    Widget child</span><br><span class="line">  &#125;) :super(child: child);</span><br><span class="line">    </span><br><span class="line">  final int data; &#x2F;&#x2F;需要在子树中共享的数据，保存点击次数</span><br><span class="line">    </span><br><span class="line">  &#x2F;&#x2F;定义一个便捷方法，方便子树中的widget获取共享数据  </span><br><span class="line">  static ShareDataWidget of(BuildContext context) &#123;</span><br><span class="line">    return context.dependOnInheritedWidgetOfExactType&lt;ShareDataWidget&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;该回调决定当data发生变化时，是否通知子树中依赖data的Widget  </span><br><span class="line">  @override</span><br><span class="line">  bool updateShouldNotify(ShareDataWidget old) &#123;</span><br><span class="line">    &#x2F;&#x2F;如果返回true，则子树中依赖(build函数中有调用)本widget</span><br><span class="line">    &#x2F;&#x2F;的子widget的&#96;state.didChangeDependencies&#96;会被调用</span><br><span class="line">    return old.data !&#x3D; data;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后实现一个子组件_TestWidget，在其build方法中引用ShareDataWidget中的数据。同时，在其didChangeDependencies() 回调中打印日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class _TestWidget extends StatefulWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  __TestWidgetState createState() &#x3D;&gt; new __TestWidgetState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class __TestWidgetState extends State&lt;_TestWidget&gt; &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    &#x2F;&#x2F;使用InheritedWidget中的共享数据</span><br><span class="line">    return Text(ShareDataWidget</span><br><span class="line">        .of(context)</span><br><span class="line">        .data</span><br><span class="line">        .toString());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  void didChangeDependencies() &#123;</span><br><span class="line">    super.didChangeDependencies();</span><br><span class="line">    &#x2F;&#x2F;父或祖先widget中的InheritedWidget改变(updateShouldNotify返回true)时会被调用。</span><br><span class="line">    &#x2F;&#x2F;如果build中没有依赖InheritedWidget，则此回调不会被调用。</span><br><span class="line">    print(&quot;Dependencies change&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们创建一个按钮，每点击一次，就将ShareDataWidget的值自增：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class InheritedWidgetTestRoute extends StatefulWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  _InheritedWidgetTestRouteState createState() &#x3D;&gt; new _InheritedWidgetTestRouteState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class _InheritedWidgetTestRouteState extends State&lt;InheritedWidgetTestRoute&gt; &#123;</span><br><span class="line">  int count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return  Center(</span><br><span class="line">      child: ShareDataWidget( &#x2F;&#x2F;使用ShareDataWidget</span><br><span class="line">        data: count,</span><br><span class="line">        child: Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Padding(</span><br><span class="line">              padding: const EdgeInsets.only(bottom: 20.0),</span><br><span class="line">              child: _TestWidget(),&#x2F;&#x2F;子widget中依赖ShareDataWidget</span><br><span class="line">            ),</span><br><span class="line">            RaisedButton(</span><br><span class="line">              child: Text(&quot;Increment&quot;),</span><br><span class="line">              &#x2F;&#x2F;每点击一次，将count自增，然后重新build,ShareDataWidget的data将被更新  </span><br><span class="line">              onPressed: () &#x3D;&gt; setState(() &#x3D;&gt; ++count),</span><br><span class="line">            )</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>界面如下：<br><img src="/uploads/flutter1.png" alt="State Lifecycle"><br>每次点击Increment按钮控制台都会打印”Dependencies change”</p>
<p>由于_TestWidget使用了ShareDataWidget（InheritedWidget）的数据，所以当ShareDataWidget的data变化时，就会调用_TestWidget的didChangeDependencies方法。</p>
<p>如果_TestWidget只想使用ShareDataWidget（InheritedWidget）的数据，当data变化时，不想触发他的didChangeDependencies方法，则只需要将ShareDataWidget的of方法修改如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;定义一个便捷方法，方便子树中的widget获取共享数据</span><br><span class="line">static ShareDataWidget of(BuildContext context) &#123;</span><br><span class="line">  &#x2F;&#x2F;return context.dependOnInheritedWidgetOfExactType&lt;ShareDataWidget&gt;();</span><br><span class="line">  return context.getElementForInheritedWidgetOfExactType&lt;ShareDataWidget&gt;().widget;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript模块化</title>
    <url>/2021/07/08/JavaScript%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    <content><![CDATA[<p>模块（module）体系，能将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。</p>
<span id="more"></span>
<p>JS 中常见的模块如下</p>
<h1 id="IIFE-模式：匿名函数自调用（闭包）"><a href="#IIFE-模式：匿名函数自调用（闭包）" class="headerlink" title="IIFE 模式：匿名函数自调用（闭包）"></a>IIFE 模式：匿名函数自调用（闭包）</h1><p>主要应用在浏览器端。</p>
<p>利用闭包的原理创造一个独有的函数作用域来保存私有变量，达到模块化的效果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">window</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = <span class="string">&quot;data&quot;</span>;</span><br><span class="line">  <span class="comment">//获取数据</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 修改数据</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    data = val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//暴露行为</span></span><br><span class="line">  <span class="built_in">window</span>.myModule = &#123;</span><br><span class="line">    get,</span><br><span class="line">    set,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h1><p>环境： 主要应用在服务端，如果在浏览器端运行需要借助其他工具（Browserify）。</p>
<p>暴露模块： module.exports = value或者exports.xx = value(exports 是一个导出的对象)</p>
<p>引入模块： require(xx)，如果是第三方模块，xxx 为模块名，如果为自定义模块，xxx 为模块的文件路径。</p>
<ol>
<li>所有代码都运行在模块作用域，不会污染全局作用域。</li>
<li>模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。</li>
<li>模块加载的顺序，按照其在代码中出现的顺序。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// module.js</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  arr,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">let</span> module1 = <span class="built_in">require</span>(<span class="string">&quot;./module.js&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> uniq = <span class="built_in">require</span>(<span class="string">&quot;uniq&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(uniq(module1.arr)); <span class="comment">// [1,2,3]</span></span><br></pre></td></tr></table></figure>

<h1 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h1><p>AMD 采用非同步的方式来加载模块。</p>
<p>环境： 浏览器环境</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// module.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> url = <span class="built_in">window</span>.location.href;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getUrl</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> url.toUpperCase();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 暴露模块</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getUrl,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&quot;module.js&quot;</span>], <span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> currentUrl = <span class="built_in">module</span>.getUrl();</span><br><span class="line">    alert(<span class="string">&quot;当前页面的URl：&quot;</span> + currentUrl);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h1><p>CMD—是 SeaJS 在推广过程中对模块定义的规范化产出，是一个同步模块定义</p>
<p>CMD 是 AMD 在基础上改进的一种规范，和 AMD 不同在于依赖模块的执行机制不同，CMD 是就近依赖，而 AMD 是前置依赖。<br>环境： 浏览器环境</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// module.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">exports</span>.a = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> moduleA = <span class="built_in">require</span>(<span class="string">&quot;./module.js&quot;</span>);</span><br><span class="line">  alert(moduleA.a); <span class="comment">// 打印出：hello world</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h1><p>兼容 AMD 和 CommonJS 规范</p>
<p>环境： 服务器环境和浏览器端</p>
<p>实现原理:</p>
<ol>
<li>先判断是否支持 AMD（define 是否存在），存在则使用 AMD 方式加载模块；</li>
<li>再判断是否支持 Node.js 模块格式（exports 是否存在），存在则使用 Node.js 模块格式；</li>
<li>前两个都不存在，则将模块公开到全局（window 或 global）</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">root, factory</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">&quot;function&quot;</span> &amp;&amp; define.amd) &#123;</span><br><span class="line">    <span class="comment">//AMD</span></span><br><span class="line">    define([<span class="string">&quot;jquery&quot;</span>], factory);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">exports</span> === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">//Node, CommonJS之类的</span></span><br><span class="line">    <span class="built_in">module</span>.exports = factory(<span class="built_in">require</span>(<span class="string">&quot;jquery&quot;</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//浏览器全局变量(root 即 window)</span></span><br><span class="line">    root.returnExports = factory(root.jQuery);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="built_in">this</span>, <span class="function"><span class="keyword">function</span>(<span class="params">$</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//方法</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">myFuncA</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// 私有方法，因为没有返回</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">myFuncB</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// 公共方法，因为返回了</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//暴露公共方法</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    myFuncB,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<h1 id="ES6-Module"><a href="#ES6-Module" class="headerlink" title="ES6 Module"></a>ES6 Module</h1><p>在 ES6 之前，模块化主要是社区在推动进行的，从而出现了 CommonJS 和 AMD 两个，前者用于服务器后者用于浏览器，ES6 模块的出现将完全替代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的解决方案。</p>
<p>环境： 服务器环境和浏览器端</p>
<p>语法：</p>
<ol>
<li>导入：import {modules1,modules1,} from ‘模块路径’</li>
<li>整体导入：import * as circle from ‘./circle’;</li>
<li>导出：export或者export default</li>
<li>动态加载模块：import(‘模块路径’).then(..)</li>
</ol>
<p>优点：</p>
<ol>
<li>不再需要UMD模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。</li>
<li>将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者navigator对象的属性。</li>
<li>不再需要对象作为命名空间（比如Math对象），未来这些功能可以通过模块提供。</li>
</ol>
<h2 id="浏览器使用："><a href="#浏览器使用：" class="headerlink" title="浏览器使用："></a>浏览器使用：</h2><h3 id="传统方法"><a href="#传统方法" class="headerlink" title="传统方法"></a>传统方法</h3><p>默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到&lt;script&gt;标签就会停下来，等到执行完脚本，再继续向下渲染。</p>
<p>异步加载:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;path/to/myModule.js&quot;</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;path/to/myModule.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>defer与async的区别是：</p>
<ol>
<li>defer要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行。如果有多个defer脚本，会按照它们在页面出现的顺序加载。</li>
<li>async一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。多个async脚本不能保证加载顺序。</li>
</ol>
<h2 id="Node-js-的加载方法"><a href="#Node-js-的加载方法" class="headerlink" title="Node.js 的加载方法"></a>Node.js 的加载方法</h2><ol>
<li>缀名改成.mjs</li>
<li>package.json文件中，指定type字段为module。</li>
</ol>
<h3 id="ES6-Module加载"><a href="#ES6-Module加载" class="headerlink" title="ES6 Module加载"></a>ES6 Module加载</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./foo.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>设置type=”module”  默认表现跟defer一致，等到整个页面渲染完，再执行模块脚本。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./foo.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>也可以加上async属性，一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。</p>
<h1 id="ES6-Module-和-CommonJS-的区别"><a href="#ES6-Module-和-CommonJS-的区别" class="headerlink" title="ES6 Module 和 CommonJS 的区别"></a>ES6 Module 和 CommonJS 的区别</h1><h2 id="CommonJS："><a href="#CommonJS：" class="headerlink" title="CommonJS："></a>CommonJS：</h2><ol>
<li>CommonJS 模块就是对象   运行时加载</li>
<li>输出的是一个值的拷贝（一旦输出一个值（原始类型的值），模块内部的变化就影响不到这个值）</li>
<li>顶层this指向当前模块</li>
<li>循环引用处理：脚本代码在require的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a.js</span></span><br><span class="line"><span class="built_in">exports</span>.done = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&#x27;./b.js&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;在 a.js 之中，b.done = %j&#x27;</span>, b.done);</span><br><span class="line"><span class="built_in">exports</span>.done = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a.js 执行完毕&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//b.js</span></span><br><span class="line"><span class="built_in">exports</span>.done = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./a.js&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;在 b.js 之中，a.done = %j&#x27;</span>, a.done);</span><br><span class="line"><span class="built_in">exports</span>.done = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;b.js 执行完毕&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./a.js&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&#x27;./b.js&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;在 main.js 之中, a.done=%j, b.done=%j&#x27;</span>, a.done, b.done);</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行main.js 结果：</span></span><br><span class="line">在 b.js 之中，a.done = <span class="literal">false</span></span><br><span class="line">b.js 执行完毕</span><br><span class="line">在 a.js 之中，b.done = <span class="literal">true</span></span><br><span class="line">a.js 执行完毕</span><br><span class="line">在 main.js 之中, a.done=<span class="literal">true</span>, b.done=<span class="literal">true</span></span><br></pre></td></tr></table></figure>
上面的代码证明了两件事。<br>一是，在b.js之中，a.js没有执行完毕，只执行了第一行。<br>二是，main.js执行到第二行时，不会再次执行b.js，而是输出缓存的b.js的执行结果</li>
</ol>
<h2 id="ES6-Module："><a href="#ES6-Module：" class="headerlink" title="ES6 Module："></a>ES6 Module：</h2><ol>
<li><p>编译时加载（静态加载）</p>
</li>
<li><p>输出的是值的引用。(通过export {&lt;变量&gt;}输出的是一个值的引用,export default输出的是一个值的拷贝)</p>
</li>
<li><p>顶层的this关键字返回undefined</p>
</li>
<li><p>循环引用处理：ES6 模块是动态引用，如果使用import从一个模块加载变量（即import foo from ‘foo’），那些变量不会被缓存，而是成为一个指向被加载模块的引用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123;bar&#125; <span class="keyword">from</span> <span class="string">&#x27;./b&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a.mjs&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bar);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> foo = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;b.mjs&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> bar = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"></span><br><span class="line">执行a.mjs  结果：</span><br><span class="line">b.mjs</span><br><span class="line"><span class="built_in">ReferenceError</span>: foo is not defined</span><br></pre></td></tr></table></figure>
<p>首先，执行a.mjs以后，引擎发现它加载了b.mjs，因此会优先执行b.mjs，然后再执行a.mjs。<br>接着，执行b.mjs的时候，已知它从a.mjs输入了foo接口，这时不会去执行a.mjs，而是认为这个接口已经存在了，继续往下执行。<br>执行到第三行console.log(foo)的时候，才发现这个接口根本没定义，因此报错。</p>
</li>
<li><p>自动采用严格模式</p>
</li>
<li><p>import的变量是只读的，对它进行重新赋值会报错。</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; obj &#125; <span class="keyword">from</span> <span class="string">&#x27;./lib&#x27;</span>;</span><br><span class="line"></span><br><span class="line">obj.prop = <span class="number">123</span>; <span class="comment">// OK</span></span><br><span class="line">obj = &#123;&#125;; <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript基础</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>MVP入门</title>
    <url>/2016/11/04/MVP%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h4 id="MVP是什么"><a href="#MVP是什么" class="headerlink" title="MVP是什么"></a>MVP是什么</h4><p>MVP 是从经典的模式MVC演变而来，它们的基本思想有相通的地方：Controller/Presenter负责逻辑的处理，Model提供数据，View负责显示。作为一种新的模式，MVP与MVC有着一个重大的区别：在MVP中View并不直接使用Model，它们之间的通信是通过Presenter (MVC中的Controller)来进行的，所有的交互都发生在Presenter内部，而在MVC中View会从直接Model中读取数据而不是通过 Controller。</p>
<span id="more"></span>
<h4 id="MVP的优点"><a href="#MVP的优点" class="headerlink" title="MVP的优点"></a>MVP的优点</h4><ol>
<li>模型与视图完全分离，我们可以修改视图而不影响模型</li>
<li>可以更高效地使用模型，因为所有的交互都发生在一个地方——Presenter内部</li>
<li>我们可以将一个Presenter用于多个视图，而不需要改变Presenter的逻辑。这个特性非常的有用，因为视图的变化总是比模型的变化频繁。</li>
<li>如果我们把逻辑放在Presenter中，那么我们就可以脱离用户接口来测试这些逻辑（单元测试）  </li>
</ol>
<h4 id="Demo解析"><a href="#Demo解析" class="headerlink" title="Demo解析"></a>Demo解析</h4><p>Demo地址：<a href="https://github.com/Peter-cao/MvpDemo">https://github.com/Peter-cao/MvpDemo</a> </p>
<h5 id="基类BasePresenter"><a href="#基类BasePresenter" class="headerlink" title="基类BasePresenter"></a>基类BasePresenter</h5><pre><code>public interface BasePresenter &#123;
    void start();
&#125;
</code></pre>
<p>BasePresenter中含有方法start(),该方法的作用是presenter开始获取数据并调用view中方法改变界面显示，其调用时机是在activity类的onResume方法中。</p>
<h5 id="契约类MainContract"><a href="#契约类MainContract" class="headerlink" title="契约类MainContract"></a>契约类MainContract</h5><p>统一管理view与presenter的所有的接口，使得view与presenter中有哪些功能，一目了然，维护起来也方便</p>
<pre><code>public interface MainContract &#123;
    interface View  &#123;
        void showLoading();//显示loading
        void hideLoading();//隐藏loading
        void showList(List&lt;Topic&gt; list);//显示列表
        void showError(String msg);//显示错误信息

    &#125;
    interface Presenter extends BasePresenter &#123;
        void showList();//发送列表请求
    &#125;
&#125;
</code></pre>
<h5 id="MainActivity"><a href="#MainActivity" class="headerlink" title="MainActivity"></a>MainActivity</h5><p>实现了MainContract.View接口，MainActivity包含了MainPresenter的引用，当用户执行动作时, View截获事件, 通过Presenter接口传递事件给Presenter处理.<br>在onResume()方法中调用mPresenter的start()方法</p>
<pre><code>public class MainActivity extends AppCompatActivity implements MainContract.View &#123;
    private SwipeRefreshLayout mSwipeRefreshLayout;
    private ListView mListView;
    private MainContract.Presenter mPresenter;
    private SimpleAdapter mSimpleAdapter;
    private List&lt;Map&lt;String, Object&gt;&gt; listData = new ArrayList&lt;&gt;();
    @Override
    protected void onCreate(Bundle savedInstanceState) &#123;
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        mSwipeRefreshLayout = (SwipeRefreshLayout)findViewById(R.id.activity_main);
        mListView = (ListView)findViewById(R.id.listview);
        mSimpleAdapter = new SimpleAdapter(this,listData,android.R.layout.simple_list_item_2,new String[] &#123; &quot;title&quot; &#125;,new int[]&#123;android.R.id.text1&#125;);
        mListView.setAdapter(mSimpleAdapter);
        mPresenter = new MainPresenter(this);
    &#125;


    @Override
    protected void onResume() &#123;
        super.onResume();
        mPresenter.start();
    &#125;

    @Override
    public void showLoading() &#123;
        Handler handler = new Handler();
        handler.post(new Runnable() &#123;
            @Override
            public void run() &#123;
                mSwipeRefreshLayout.setRefreshing(true);
            &#125;
        &#125;);

    &#125;

    @Override
    public void hideLoading() &#123;
        mSwipeRefreshLayout.setRefreshing(false);
    &#125;

    @Override
    public void showList(List&lt;Topic&gt; list) &#123;
        for(Topic topic : list)&#123;
            HashMap map = new HashMap();
            map.put(&quot;title&quot;,topic.getTitle());
            listData.add(map);
        &#125;
        mSimpleAdapter.notifyDataSetChanged();
    &#125;

    @Override
    public void showError(String msg) &#123;
        Toast.makeText(this,msg,Toast.LENGTH_SHORT).show();
    &#125;
&#125;
</code></pre>
<h5 id="MainPresenter"><a href="#MainPresenter" class="headerlink" title="MainPresenter"></a>MainPresenter</h5><p>实现了MainContract.Presenter接口，MainPresenter包含了MainContract.View的引用mMainActivity，在View需要更新时，调用mMainActivity的对应方法</p>
<pre><code>public class MainPresenter implements MainContract.Presenter &#123;
    private MainContract.View mMainActivity;

    public MainPresenter(MainContract.View mainActivity) &#123;
        mMainActivity = mainActivity;
    &#125;

    @Override
    public void start() &#123;
        showList();
    &#125;
    @Override
    public void showList()&#123;
        mMainActivity.showLoading();
        Retrofit retrofit = new Retrofit.Builder()
                .baseUrl(&quot;https://cnodejs.org/api/v1/&quot;)
                .addConverterFactory(GsonConverterFactory.create())
                .build();
        ApiService service = retrofit.create(ApiService.class);
        Call&lt;TopicRsp&gt; call = service.listRepos();
        call.enqueue(new Callback&lt;TopicRsp&gt;() &#123;
            @Override
            public void onResponse(Call&lt;TopicRsp&gt; call, Response&lt;TopicRsp&gt; response) &#123;
                mMainActivity.hideLoading();
                if(response.body().isSuccess())&#123;
                    mMainActivity.showList(response.body().getData());
                &#125;else&#123;
                    mMainActivity.showError(&quot;接口异常&quot;);
                &#125;
            &#125;

            @Override
            public void onFailure(Call&lt;TopicRsp&gt; call, Throwable t) &#123;
                mMainActivity.hideLoading();
                mMainActivity.showError(&quot;网络异常&quot;);
            &#125;
        &#125;);

    &#125;
&#125;
</code></pre>
<p>参考：<a href="https://github.com/googlesamples/android-architecture">https://github.com/googlesamples/android-architecture</a></p>
]]></content>
      <tags>
        <tag>android mvp</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown</title>
    <url>/2016/06/06/Markdown%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="段落和换行"><a href="#段落和换行" class="headerlink" title="段落和换行"></a>段落和换行</h1><span id="more"></span>

<p>一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行<br>如果你确实想要依赖 Markdown 来插入 &lt;br /&gt; 标签的话，在插入处先按入两个以上的空格然后回车。  </p>
<h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><pre><code># 一级标题  
## 二级标题  
### 三级标题  
</code></pre>
<p>以此类推，总共六级标题</p>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p> 无序列表使用星号、加号或是减号作为列表标记: </p>
<pre><code>*   Red
*   Green
*   Blue
</code></pre>
<p>or  </p>
<pre><code>+   Red
+   Green
+   Blue      
</code></pre>
<p>or  </p>
<pre><code>-   Red
-   Green
-   Blue
</code></pre>
<p>有序列表则使用数字接着一个英文句点：</p>
<pre><code>1.  Bird
2.  McHale
3.  Parish
</code></pre>
<h1 id="区块引用-Blockquotes"><a href="#区块引用-Blockquotes" class="headerlink" title="区块引用 Blockquotes"></a>区块引用 Blockquotes</h1><p>只需要在文本前加入 <code>&gt;</code> 这种尖括号（大于号）即可</p>
<blockquote>
<p>例如这样  </p>
</blockquote>
<h1 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h1><p>缩进 4 个空格或是 1 个制表符就可,例如  </p>
<pre><code>这是一个普通段落：
    这是一个代码区块。  
</code></pre>
<h1 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h1><p>在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。  </p>
<pre><code>***
</code></pre>
<h1 id="图片与链接"><a href="#图片与链接" class="headerlink" title="图片与链接"></a>图片与链接</h1><pre><code>连接 [an example](http://example.com/ &quot;Title&quot;)
图片 ![Alt text](/path/to/img.jpg)
</code></pre>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>跨组件状态共享Provider</title>
    <url>/2021/03/31/Provider/</url>
    <content><![CDATA[<h1 id="全局事件总线EventBus"><a href="#全局事件总线EventBus" class="headerlink" title="全局事件总线EventBus"></a>全局事件总线EventBus</h1><p>在对应页面添加监听</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void onLoginChanged(e)&#123;</span><br><span class="line">  &#x2F;&#x2F;登录状态变化处理逻辑</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@override</span><br><span class="line">void initState() &#123;</span><br><span class="line">  &#x2F;&#x2F;订阅登录状态改变事件</span><br><span class="line">  bus.on(Event.login,onLogin);</span><br><span class="line">  super.initState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@override</span><br><span class="line">void dispose() &#123;</span><br><span class="line">  &#x2F;&#x2F;取消订阅</span><br><span class="line">  bus.off(Event.login,onLogin);</span><br><span class="line">  super.dispose();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在调用页面触发事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bus.emit(Event.login);</span><br></pre></td></tr></table></figure>
<p>缺点：  </p>
<ol>
<li>必须显式定义各种事件，不好管理   </li>
<li>订阅者必须需显式注册状态改变回调，也必须在组件销毁时手动去解绑回调以避免内存泄露。<span id="more"></span>  </li>
</ol>
<h1 id="InheritedWidge"><a href="#InheritedWidge" class="headerlink" title="InheritedWidge"></a>InheritedWidge</h1><p>InheritedWidget能与依赖它的子孙组件绑定依赖关系，并且当InheritedWidget数据发生变化时，可以自动更新依赖的子孙组件！利用这个特性，我们可以将需要跨组件共享的状态保存在InheritedWidget中，然后在子组件中引用InheritedWidget。Provider原理就是InheritedWidge。</p>
<h1 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h1><p>一个通用的InheritedWidget，保存任需要跨组件共享的状态:</p>
<p>updateShouldNotify:当该Widget rebuild之后是否通知依赖该Widget数据的子孙刷新数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 一个通用的InheritedWidget，保存任需要跨组件共享的状态</span><br><span class="line">class InheritedProvider&lt;T&gt; extends InheritedWidget &#123;</span><br><span class="line">  InheritedProvider(&#123;@required this.data, Widget child&#125;) : super(child: child);</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;共享状态使用泛型</span><br><span class="line">  final T data;</span><br><span class="line">  </span><br><span class="line">  @override</span><br><span class="line">  bool updateShouldNotify(InheritedProvider&lt;T&gt; old) &#123;</span><br><span class="line">    &#x2F;&#x2F;在此简单返回true，则每次更新都会调用依赖其的子孙节点的&#96;didChangeDependencies&#96;。</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们将要共享的状态放到一个Model类中，然后让它继承自ChangeNotifier，这样当共享的状态改变时，我们只需要调用notifyListeners() 来通知订阅者，然后由订阅者来重新构建</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ChangeNotifierProvider&lt;T extends ChangeNotifier&gt; extends StatefulWidget &#123;</span><br><span class="line">  ChangeNotifierProvider(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    this.data,</span><br><span class="line">    this.child,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  final Widget child;</span><br><span class="line">  final T data;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;定义一个便捷方法，方便子树中的widget获取共享数据</span><br><span class="line">  static T of&lt;T&gt;(BuildContext context) &#123;</span><br><span class="line">    final type &#x3D; _typeOf&lt;InheritedProvider&lt;T&gt;&gt;();</span><br><span class="line">    final provider &#x3D;  context.dependOnInheritedWidgetOfExactType&lt;InheritedProvider&lt;T&gt;&gt;();</span><br><span class="line">    return provider.data;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  _ChangeNotifierProviderState&lt;T&gt; createState() &#x3D;&gt; _ChangeNotifierProviderState&lt;T&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>_ChangeNotifierProviderState类的主要作用就是监听到共享状态（model）改变时重新构建Widget树。注意，在_ChangeNotifierProviderState类中调用setState()方法，widget.child始终是同一个，所以执行build时，InheritedProvider的child引用的始终是同一个子widget，所以widget.child并不会重新build，这也就相当于对child进行了缓存！当然如果ChangeNotifierProvider父级Widget重新build时，则其传入的child便有可能会发生变化。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class _ChangeNotifierProviderState&lt;T extends ChangeNotifier&gt; extends State&lt;ChangeNotifierProvider&lt;T&gt;&gt; &#123;</span><br><span class="line">  void update() &#123;</span><br><span class="line">    &#x2F;&#x2F;如果数据发生变化（model类调用了notifyListeners），重新构建InheritedProvider</span><br><span class="line">    setState(() &#x3D;&gt; &#123;&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  void didUpdateWidget(ChangeNotifierProvider&lt;T&gt; oldWidget) &#123;</span><br><span class="line">    &#x2F;&#x2F;当Provider更新时，如果新旧数据不&quot;&#x3D;&#x3D;&quot;，则解绑旧数据监听，同时添加新数据监听</span><br><span class="line">    if (widget.data !&#x3D; oldWidget.data) &#123;</span><br><span class="line">      oldWidget.data.removeListener(update);</span><br><span class="line">      widget.data.addListener(update);</span><br><span class="line">    &#125;</span><br><span class="line">    super.didUpdateWidget(oldWidget);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  void initState() &#123;</span><br><span class="line">    &#x2F;&#x2F; 给model添加监听器</span><br><span class="line">    widget.data.addListener(update);</span><br><span class="line">    super.initState();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  void dispose() &#123;</span><br><span class="line">    &#x2F;&#x2F; 移除model的监听器</span><br><span class="line">    widget.data.removeListener(update);</span><br><span class="line">    super.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return InheritedProvider&lt;T&gt;(</span><br><span class="line">      data: widget.data,</span><br><span class="line">      child: widget.child,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用方法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Item &#123;</span><br><span class="line">  Item(this.price, this.count);</span><br><span class="line">  double price; &#x2F;&#x2F;商品单价</span><br><span class="line">  int count; &#x2F;&#x2F; 商品份数</span><br><span class="line">  &#x2F;&#x2F;... 省略其它属性</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class CartModel extends ChangeNotifier &#123;</span><br><span class="line">  &#x2F;&#x2F; 用于保存购物车中商品列表</span><br><span class="line">  final List&lt;Item&gt; _items &#x3D; [];</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 禁止改变购物车里的商品信息</span><br><span class="line">  UnmodifiableListView&lt;Item&gt; get items &#x3D;&gt; UnmodifiableListView(_items);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 购物车中商品的总价</span><br><span class="line">  double get totalPrice &#x3D;&gt;</span><br><span class="line">      _items.fold(0, (value, item) &#x3D;&gt; value + item.count * item.price);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 将 [item] 添加到购物车。这是唯一一种能从外部改变购物车的方法。</span><br><span class="line">  void add(Item item) &#123;</span><br><span class="line">    _items.add(item);</span><br><span class="line">    &#x2F;&#x2F; 通知监听器（订阅者），重新构建InheritedProvider， 更新状态。</span><br><span class="line">    notifyListeners();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ProviderRoute extends StatefulWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  _ProviderRouteState createState() &#x3D;&gt; _ProviderRouteState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class _ProviderRouteState extends State&lt;ProviderRoute&gt; &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return Center(</span><br><span class="line">      child: ChangeNotifierProvider&lt;CartModel&gt;(</span><br><span class="line">        data: CartModel(),</span><br><span class="line">        child: Builder(builder: (context) &#123;</span><br><span class="line">          return Column(</span><br><span class="line">            children: &lt;Widget&gt;[</span><br><span class="line">              Builder(builder: (context)&#123;</span><br><span class="line">                var cart&#x3D;ChangeNotifierProvider.of&lt;CartModel&gt;(context);</span><br><span class="line">                return Text(&quot;总价: $&#123;cart.totalPrice&#125;&quot;);</span><br><span class="line">              &#125;),</span><br><span class="line">              Builder(builder: (context)&#123;</span><br><span class="line">                print(&quot;RaisedButton build&quot;); &#x2F;&#x2F;在后面优化部分会用到</span><br><span class="line">                return RaisedButton(</span><br><span class="line">                  child: Text(&quot;添加商品&quot;),</span><br><span class="line">                  onPressed: () &#123;</span><br><span class="line">                    &#x2F;&#x2F;给购物车中添加商品，添加后总价会更新</span><br><span class="line">                    ChangeNotifierProvider.of&lt;CartModel&gt;(context).add(Item(20.0, 1));</span><br><span class="line">                  &#125;,</span><br><span class="line">                );</span><br><span class="line">              &#125;),</span><br><span class="line">            ],</span><br><span class="line">          );</span><br><span class="line">        &#125;),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;添加一个listen参数，表示是否建立依赖关系</span><br><span class="line"> static T of&lt;T&gt;(BuildContext context, &#123;bool listen &#x3D; true&#125;) &#123;</span><br><span class="line">   final type &#x3D; _typeOf&lt;InheritedProvider&lt;T&gt;&gt;();</span><br><span class="line">   final provider &#x3D; listen</span><br><span class="line">       ? context.dependOnInheritedWidgetOfExactType&lt;InheritedProvider&lt;T&gt;&gt;()</span><br><span class="line">       : context.getElementForInheritedWidgetOfExactType&lt;InheritedProvider&lt;T&gt;&gt;()?.widget</span><br><span class="line">           as InheritedProvider&lt;T&gt;;</span><br><span class="line">   return provider.data;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Column(</span><br><span class="line">    children: &lt;Widget&gt;[</span><br><span class="line">      Consumer&lt;CartModel&gt;(</span><br><span class="line">        builder: (BuildContext context, cart) &#x3D;&gt;Text(&quot;总价: $&#123;cart.totalPrice&#125;&quot;),</span><br><span class="line">      ),</span><br><span class="line">      Builder(builder: (context) &#123;</span><br><span class="line">        print(&quot;RaisedButton build&quot;);</span><br><span class="line">        return RaisedButton(</span><br><span class="line">          child: Text(&quot;添加商品&quot;),</span><br><span class="line">          onPressed: () &#123;</span><br><span class="line">            &#x2F;&#x2F; listen 设为false，不建立依赖关系</span><br><span class="line">            ChangeNotifierProvider.of&lt;CartModel&gt;(context, listen: false)</span><br><span class="line">                .add(Item(20.0, 1));</span><br><span class="line">          &#125;,</span><br><span class="line">        );</span><br><span class="line">      &#125;)</span><br><span class="line">    ],</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>React笔记</title>
    <url>/2016/10/13/React%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>一个用于构建用户界面的JavaScript库</p>
<span id="more"></span>
<h3 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h3><p>1.下载<br><a href="https://facebook.github.io/react/index.html">https://facebook.github.io/react/index.html</a>  </p>
<p>2.解压后在根目录下创建 <code>helloworld.html</code></p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;title&gt;Hello React!&lt;/title&gt;
    &lt;script src=&quot;build/react.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;build/react-dom.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://unpkg.com/babel-core@5.8.38/browser.min.js&quot;&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;
    &lt;script type=&quot;text/babel&quot;&gt;
      ReactDOM.render(
        &lt;h1&gt;Hello, world!&lt;/h1&gt;,
        document.getElementById(&#39;example&#39;)
      );
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;  
</code></pre>
<p>在浏览器打开后  你应该能看到 Hello, world!</p>
<h3 id="评论框的实现"><a href="#评论框的实现" class="headerlink" title="评论框的实现"></a>评论框的实现</h3><h4 id="新建一个index-html"><a href="#新建一个index-html" class="headerlink" title="新建一个index.html"></a>新建一个index.html</h4><pre><code>&lt;!-- index.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot; /&gt;
    &lt;title&gt;React Tutorial&lt;/title&gt;
    &lt;script src=&quot;https://unpkg.com/react@15.3.2/dist/react.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://unpkg.com/react-dom@15.3.2/dist/react-dom.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://unpkg.com/jquery@3.1.0/dist/jquery.min.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://unpkg.com/remarkable@1.7.1/dist/remarkable.min.js&quot;&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;content&quot;&gt;&lt;/div&gt;
  
    &lt;script type=&quot;text/babel&quot;&gt;
    
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h4 id="构建CommentBox"><a href="#构建CommentBox" class="headerlink" title="构建CommentBox"></a>构建CommentBox</h4><pre><code>var CommentBox = React.createClass(&#123;
  render: function() &#123;
    return (
      &lt;div className=&quot;commentBox&quot;&gt;
        Hello, world! I am a CommentBox.
      &lt;/div&gt;
    );
  &#125;
&#125;);
ReactDOM.render(
  &lt;CommentBox /&gt;,
  document.getElementById(&#39;content&#39;)
);
</code></pre>
<h4 id="构建CommentList、CommentForm，并组装"><a href="#构建CommentList、CommentForm，并组装" class="headerlink" title="构建CommentList、CommentForm，并组装"></a>构建CommentList、CommentForm，并组装</h4><pre><code>var CommentList = React.createClass(&#123;
  render: function() &#123;
    return (
      &lt;div className=&quot;commentList&quot;&gt;
        Hello, world! I am a CommentList.
      &lt;/div&gt;
    );
  &#125;
&#125;);

var CommentForm = React.createClass(&#123;
  render: function() &#123;
    return (
      &lt;div className=&quot;commentForm&quot;&gt;
        Hello, world! I am a CommentForm.
      &lt;/div&gt;
    );
  &#125;
&#125;);  
</code></pre>
<p>更新CommentBox，使用CommentList、CommentForm  </p>
<pre><code>var CommentBox = React.createClass(&#123;
  render: function() &#123;
    return (
      &lt;div className=&quot;commentBox&quot;&gt;
        &lt;h1&gt;Comments&lt;/h1&gt;
        &lt;CommentList /&gt;
        &lt;CommentForm /&gt;
      &lt;/div&gt;
    );
  &#125;
&#125;); 
</code></pre>
<h4 id="使用-props-构建Comment"><a href="#使用-props-构建Comment" class="headerlink" title="使用 props 构建Comment####"></a>使用 props 构建Comment####</h4><pre><code>var Comment = React.createClass(&#123;
  render: function() &#123;
    return (
      &lt;div className=&quot;comment&quot;&gt;
        &lt;h2 className=&quot;commentAuthor&quot;&gt;
          &#123;this.props.author&#125;
        &lt;/h2&gt;
        &#123;this.props.children&#125;
      &lt;/div&gt;
    );
  &#125;
&#125;);  
</code></pre>
<p>通过this.props.author获取Comment节点的author属性，通过this.props.children获取Comment下的子节点<br>更新CommentList   </p>
<pre><code>var CommentList = React.createClass(&#123;
  render: function() &#123;
    return (
      &lt;div className=&quot;commentList&quot;&gt;
        &lt;Comment author=&quot;Pete Hunt&quot;&gt;This is one comment&lt;/Comment&gt;
        &lt;Comment author=&quot;Jordan Walke&quot;&gt;This is *another* comment&lt;/Comment&gt;
      &lt;/div&gt;
    );
  &#125;
&#125;);
</code></pre>
<p>####添加Markdown ####<br>使用第三方库remarkable来使评论支持Markdown，代码如下</p>
<pre><code>var Comment = React.createClass(&#123;
  render: function() &#123;
    var md = new Remarkable();
    return (
      &lt;div className=&quot;comment&quot;&gt;
        &lt;h2 className=&quot;commentAuthor&quot;&gt;
          &#123;this.props.author&#125;
        &lt;/h2&gt;
        &#123;md.render(this.props.children.toString())&#125;
      &lt;/div&gt;
    );
  &#125;
&#125;);  
</code></pre>
<p>这样有个问题，评论会显示成<code>&lt;p&gt;This is &lt;em&gt;another&lt;/em&gt; comment&lt;/p&gt;</code>,我们希望转化成HTML，方法如下  </p>
<pre><code>var Comment = React.createClass(&#123;
  rawMarkup: function() &#123;
    var md = new Remarkable();
    var rawMarkup = md.render(this.props.children.toString());
    return &#123; __html: rawMarkup &#125;;
  &#125;,

  render: function() &#123;
    return (
      &lt;div className=&quot;comment&quot;&gt;
        &lt;h2 className=&quot;commentAuthor&quot;&gt;
          &#123;this.props.author&#125;
        &lt;/h2&gt;
        &lt;span dangerouslySetInnerHTML=&#123;this.rawMarkup()&#125; /&gt;
      &lt;/div&gt;
    );
  &#125;
&#125;);
</code></pre>
<h4 id="数据注入"><a href="#数据注入" class="headerlink" title="数据注入"></a>数据注入</h4><pre><code>var data = [
  &#123;id: 1, author: &quot;Pete Hunt&quot;, text: &quot;This is one comment&quot;&#125;,
  &#123;id: 2, author: &quot;Jordan Walke&quot;, text: &quot;This is *another* comment&quot;&#125;
];  
</code></pre>
<p>修改CommentBox和ReactDOM.render（）来传递数据到CommentList</p>
<pre><code>var CommentBox = React.createClass(&#123;
  render: function() &#123;
    return (
      &lt;div className=&quot;commentBox&quot;&gt;
        &lt;h1&gt;Comments&lt;/h1&gt;
        &lt;CommentList data=&#123;this.props.data&#125; /&gt;
        &lt;CommentForm /&gt;
      &lt;/div&gt;
    );
  &#125;
&#125;);

ReactDOM.render(
  &lt;CommentBox data=&#123;data&#125; /&gt;,
  document.getElementById(&#39;content&#39;)
);  
</code></pre>
<p>动态显示CommentList数据  </p>
<pre><code>var CommentList = React.createClass(&#123;
  render: function() &#123;
    var commentNodes = this.props.data.map(function(comment) &#123;
      return (
        &lt;Comment author=&#123;comment.author&#125; key=&#123;comment.id&#125;&gt;
          &#123;comment.text&#125;
        &lt;/Comment&gt;
      );
    &#125;);
    return (
      &lt;div className=&quot;commentList&quot;&gt;
        &#123;commentNodes&#125;
      &lt;/div&gt;
    );
  &#125;
&#125;);  
</code></pre>
<h4 id="从服务器上获取数据"><a href="#从服务器上获取数据" class="headerlink" title="从服务器上获取数据"></a>从服务器上获取数据</h4><pre><code>ReactDOM.render(
  &lt;CommentBox url=&quot;/api/comments&quot; /&gt;,
  document.getElementById(&#39;content&#39;)
);
</code></pre>
<h4 id="使用-state"><a href="#使用-state" class="headerlink" title="使用 state"></a>使用 state</h4><pre><code>var CommentBox = React.createClass(&#123;
  getInitialState: function() &#123;//组件初始化函数
    return &#123;data: []&#125;;
  &#125;,
  render: function() &#123;
    return (
      &lt;div className=&quot;commentBox&quot;&gt;
        &lt;h1&gt;Comments&lt;/h1&gt;
        &lt;CommentList data=&#123;this.state.data&#125; /&gt;
        &lt;CommentForm /&gt;
      &lt;/div&gt;
    );
  &#125;
&#125;);  
</code></pre>
<p>更新组件</p>
<pre><code>var CommentBox = React.createClass(&#123;
  getInitialState: function() &#123;
    return &#123;data: []&#125;;
  &#125;,
  componentDidMount: function() &#123;//当组件第一次render完成之后自动调用
    $.ajax(&#123;
      url: this.props.url,
      dataType: &#39;json&#39;,
      cache: false,
      success: function(data) &#123;
        this.setState(&#123;data: data&#125;);
      &#125;.bind(this),
      error: function(xhr, status, err) &#123;
        console.error(this.props.url, status, err.toString());
      &#125;.bind(this)
    &#125;);
  &#125;,
  render: function() &#123;
    return (
      &lt;div className=&quot;commentBox&quot;&gt;
        &lt;h1&gt;Comments&lt;/h1&gt;
        &lt;CommentList data=&#123;this.state.data&#125; /&gt;
        &lt;CommentForm /&gt;
      &lt;/div&gt;
    );
  &#125;
&#125;);
</code></pre>
<p>通过调用this.setState();方法改变state，React会自动更新UI</p>
<h4 id="提交评论"><a href="#提交评论" class="headerlink" title="提交评论"></a>提交评论</h4><p>更新CommentForm组件  </p>
<pre><code>var CommentForm = React.createClass(&#123;
  render: function() &#123;
    return (
      &lt;form className=&quot;commentForm&quot;&gt;
        &lt;input type=&quot;text&quot; placeholder=&quot;Your name&quot; /&gt;
        &lt;input type=&quot;text&quot; placeholder=&quot;Say something...&quot; /&gt;
        &lt;input type=&quot;submit&quot; value=&quot;Post&quot; /&gt;
      &lt;/form&gt;
    );
  &#125;
&#125;);  
</code></pre>
<p>处理用户输入，将author和text存入state,将input的value设置为<code>this.state.author</code>，在onChange中调用this.setState（）修改author和text的值，这样input中的值将自动更新，更新代码如下</p>
<pre><code>var CommentForm = React.createClass(&#123;
  getInitialState: function() &#123;//初始化author和text
    return &#123;author: &#39;&#39;, text: &#39;&#39;&#125;;
  &#125;,
  handleAuthorChange: function(e) &#123;
    this.setState(&#123;author: e.target.value&#125;);
  &#125;,
  handleTextChange: function(e) &#123;
    this.setState(&#123;text: e.target.value&#125;);
  &#125;,
  render: function() &#123;
    return (
      &lt;form className=&quot;commentForm&quot;&gt;
        &lt;input
          type=&quot;text&quot;
          placeholder=&quot;Your name&quot;
          value=&#123;this.state.author&#125;
          onChange=&#123;this.handleAuthorChange&#125;
        /&gt;
        &lt;input
          type=&quot;text&quot;
          placeholder=&quot;Say something...&quot;
          value=&#123;this.state.text&#125;
          onChange=&#123;this.handleTextChange&#125;
        /&gt;
        &lt;input type=&quot;submit&quot; value=&quot;Post&quot; /&gt;
      &lt;/form&gt;
    );
  &#125;
&#125;);  
</code></pre>
<h4 id="提交评论-1"><a href="#提交评论-1" class="headerlink" title="提交评论"></a>提交评论</h4><p>将form的 <code>onSubmit=&#123;this.handleSubmit&#125;</code>,点提交按钮触发handleSubmit方法，提交数据，并将数据清空</p>
<pre><code>var CommentForm = React.createClass(&#123;
  getInitialState: function() &#123;
    return &#123;author: &#39;&#39;, text: &#39;&#39;&#125;;
  &#125;,
  handleAuthorChange: function(e) &#123;
    this.setState(&#123;author: e.target.value&#125;);
  &#125;,
  handleTextChange: function(e) &#123;
    this.setState(&#123;text: e.target.value&#125;);
  &#125;,
  handleSubmit: function(e) &#123;
    e.preventDefault();//阻止浏览器默认的提交表单事件
    var author = this.state.author.trim();
    var text = this.state.text.trim();
    if (!text || !author) &#123;
      return;
    &#125;
    // TODO: 提交数据
    this.setState(&#123;author: &#39;&#39;, text: &#39;&#39;&#125;);
  &#125;,
  render: function() &#123;
    return (
      &lt;form className=&quot;commentForm&quot; onSubmit=&#123;this.handleSubmit&#125;&gt;
        &lt;input
          type=&quot;text&quot;
          placeholder=&quot;Your name&quot;
          value=&#123;this.state.author&#125;
          onChange=&#123;this.handleAuthorChange&#125;
        /&gt;
        &lt;input
          type=&quot;text&quot;
          placeholder=&quot;Say something...&quot;
          value=&#123;this.state.text&#125;
          onChange=&#123;this.handleTextChange&#125;
        /&gt;
        &lt;input type=&quot;submit&quot; value=&quot;Post&quot; /&gt;
      &lt;/form&gt;
    );
  &#125;
&#125;);
</code></pre>
<h4 id="使用props调用组件的方法"><a href="#使用props调用组件的方法" class="headerlink" title="使用props调用组件的方法"></a>使用props调用组件的方法</h4><p>当用户提交一条评论后，需要刷新列表。这个逻辑应该在CommentBox中做完，因为CommentBox组件的state中含有列表的data.<br>我们需要将子组件的数据传递到父组件。方法如下：在CommentBox的render方法中为CommentForm添加<code>onCommentSubmit=&#123;this.handleCommentSubmit&#125;</code>方法，将handleCommentSubmit和onCommentSubmit方法绑定</p>
<pre><code>var CommentBox = React.createClass(&#123;
  loadCommentsFromServer: function() &#123;
    $.ajax(&#123;
      url: this.props.url,
      dataType: &#39;json&#39;,
      cache: false,
      success: function(data) &#123;
        this.setState(&#123;data: data&#125;);
      &#125;.bind(this),
      error: function(xhr, status, err) &#123;
        console.error(this.props.url, status, err.toString());
      &#125;.bind(this)
    &#125;);
  &#125;,
  handleCommentSubmit: function(comment) &#123;//添加新方法
    // TODO: 提交数据
  &#125;,
  getInitialState: function() &#123;
    return &#123;data: []&#125;;
  &#125;,
  componentDidMount: function() &#123;
    this.loadCommentsFromServer();
    setInterval(this.loadCommentsFromServer, this.props.pollInterval);
  &#125;,
  render: function() &#123;
    return (
      &lt;div className=&quot;commentBox&quot;&gt;
        &lt;h1&gt;Comments&lt;/h1&gt;
        &lt;CommentList data=&#123;this.state.data&#125; /&gt;
        &lt;CommentForm onCommentSubmit=&#123;this.handleCommentSubmit&#125; /&gt;//添加onCommentSubmit触发handleCommentSubmit
      &lt;/div&gt;
    );
  &#125;
&#125;);  
</code></pre>
<p>在CommentForm 的handleSubmit中调用<code>this.props.onCommentSubmit(&#123;author: author, text: text&#125;);</code>触发handleCommentSubmit方法</p>
<pre><code>var CommentForm = React.createClass(&#123;
  getInitialState: function() &#123;
    return &#123;author: &#39;&#39;, text: &#39;&#39;&#125;;
  &#125;,
  handleAuthorChange: function(e) &#123;
    this.setState(&#123;author: e.target.value&#125;);
  &#125;,
  handleTextChange: function(e) &#123;
    this.setState(&#123;text: e.target.value&#125;);
  &#125;,
  handleSubmit: function(e) &#123;
    e.preventDefault();
    var author = this.state.author.trim();
    var text = this.state.text.trim();
    if (!text || !author) &#123;
      return;
    &#125;
    this.props.onCommentSubmit(&#123;author: author, text: text&#125;);//调用onCommentSubmit(&#123;author: author, text: text&#125;)
    this.setState(&#123;author: &#39;&#39;, text: &#39;&#39;&#125;);
  &#125;,
  render: function() &#123;
    return (
      &lt;form className=&quot;commentForm&quot; onSubmit=&#123;this.handleSubmit&#125;&gt;
        &lt;input
          type=&quot;text&quot;
          placeholder=&quot;Your name&quot;
          value=&#123;this.state.author&#125;
          onChange=&#123;this.handleAuthorChange&#125;
        /&gt;
        &lt;input
          type=&quot;text&quot;
          placeholder=&quot;Say something...&quot;
          value=&#123;this.state.text&#125;
          onChange=&#123;this.handleTextChange&#125;
        /&gt;
        &lt;input type=&quot;submit&quot; value=&quot;Post&quot; /&gt;
      &lt;/form&gt;
    );
  &#125;
&#125;);  
</code></pre>
<p>然后在CommentBox 的handleCommentSubmit方法中发送请求</p>
<pre><code> handleCommentSubmit: function(comment) &#123;
    $.ajax(&#123;
      url: this.props.url,
      dataType: &#39;json&#39;,
      type: &#39;POST&#39;,
      data: comment,
      success: function(data) &#123;
        this.setState(&#123;data: data&#125;);
      &#125;.bind(this),
      error: function(xhr, status, err) &#123;
        console.error(this.props.url, status, err.toString());
      &#125;.bind(this)
    &#125;);
  &#125;,    
</code></pre>
<h4 id="提前更新"><a href="#提前更新" class="headerlink" title="提前更新"></a>提前更新</h4><p>到目前为止功能已经完成，但是当提交评论时，总会先发送请求，等请求成功后才显示数据，显示比较慢。<br>更改方法：在发送请求之前，将提交的评论添加到this.state.data中，然后调用 this.setState(),先将数据显示出来，在请求成功的回调用再次调用this.setState({data: data})，确保数据和服务器同步</p>
<pre><code>handleCommentSubmit: function(comment) &#123;
    var comments = this.state.data;
    // Optimistically set an id on the new comment. It will be replaced by an
    // id generated by the server. In a production application you would likely
    // not use Date.now() for this and would have a more robust system in place.
    comment.id = Date.now();
    var newComments = comments.concat([comment]);
    this.setState(&#123;data: newComments&#125;);
    $.ajax(&#123;
      url: this.props.url,
      dataType: &#39;json&#39;,
      type: &#39;POST&#39;,
      data: comment,
      success: function(data) &#123;
        this.setState(&#123;data: data&#125;);
      &#125;.bind(this),
      error: function(xhr, status, err) &#123;
        this.setState(&#123;data: comments&#125;);
        console.error(this.props.url, status, err.toString());
      &#125;.bind(this)
    &#125;);
  &#125;,
</code></pre>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://facebook.github.io/react/docs/tutorial.html">https://facebook.github.io/react/docs/tutorial.html</a></p>
]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>RxJava入门</title>
    <url>/2016/10/18/RxJava%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h4 id="RxJava-是什么"><a href="#RxJava-是什么" class="headerlink" title="RxJava 是什么"></a>RxJava 是什么</h4><p>Github上的介绍：a library for composing asynchronous and event-based programs by using observable sequences.<br>一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库</p>
<span id="more"></span>
<h4 id="观察者模式举例"><a href="#观察者模式举例" class="headerlink" title="观察者模式举例"></a>观察者模式举例</h4><p>举例：按下开关，台灯灯亮<br>在这个事件中，台灯作为观察者，开关作为被观察者，台灯透过电线来观察开关的状态来并做出相应的处理</p>
<h4 id="创建被观察者（开关）"><a href="#创建被观察者（开关）" class="headerlink" title="创建被观察者（开关）"></a>创建被观察者（开关）</h4><p>正常模式：</p>
<pre><code>Observable switcher=Observable.create(new Observable.OnSubscribe&lt;String&gt;()&#123;

    @Override
    public void call(Subscriber&lt;? super String&gt; subscriber) &#123;
        subscriber.onNext(&quot;On&quot;);
        subscriber.onNext(&quot;Off&quot;);
        subscriber.onNext(&quot;On&quot;);
        subscriber.onNext(&quot;On&quot;);
        subscriber.onCompleted();
    &#125;
&#125;);
</code></pre>
<p>偷懒模式1</p>
<pre><code>Observable switcher=Observable.just(&quot;On&quot;,&quot;Off&quot;,&quot;On&quot;,&quot;On&quot;);
</code></pre>
<p>偷懒模式2</p>
<pre><code>String [] kk=&#123;&quot;On&quot;,&quot;Off&quot;,&quot;On&quot;,&quot;On&quot;&#125;;
Observable switcher=Observable.from(kk);
</code></pre>
<h4 id="创建观察者（台灯）"><a href="#创建观察者（台灯）" class="headerlink" title="创建观察者（台灯）"></a>创建观察者（台灯）</h4><p>正常模式</p>
<pre><code>Subscriber light=new Subscriber&lt;String&gt;() &#123;
    @Override
    public void onCompleted() &#123;
        //被观察者的onCompleted()事件会走到这里;
        Log.d(&quot;DDDDDD&quot;,&quot;结束观察...\n&quot;);
    &#125;

    @Override
    public void onError(Throwable e) &#123;
            //出现错误会调用这个方法
    &#125;
    @Override
    public void onNext(String s) &#123;
        //处理传过来的onNext事件
        Log.d(&quot;DDDDD&quot;,&quot;handle this---&quot;+s)
    &#125;
&#125;
</code></pre>
<p>偷懒模式</p>
<pre><code> Action1 light=new Action1&lt;String&gt;() &#123;
        @Override
        public void call(String s) &#123;
            Log.d(&quot;DDDDD&quot;,&quot;handle this---&quot;+s)
        &#125;
    &#125;
</code></pre>
<h4 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h4><pre><code>switcher.subscribe(light);
</code></pre>
<p>基本骨架：</p>
<pre><code>//创建被观察者，是事件传递的起点
Observable.just(&quot;On&quot;,&quot;Off&quot;,&quot;On&quot;,&quot;On&quot;)
//这就是在传递过程中对事件进行过滤操作
 .filter(new Func1&lt;String, Boolean&gt;() &#123;
            @Override
            public Boolean call(String s) &#123;
                return s！=null;
            &#125;
        &#125;)
//实现订阅
.subscribe(
    //创建观察者，作为事件传递的终点处理事件    
      new Subscriber&lt;String&gt;() &#123;
        @Override
        public void onCompleted() &#123;
            Log.d(&quot;DDDDDD&quot;,&quot;结束观察...\n&quot;);
        &#125;

        @Override
        public void onError(Throwable e) &#123;
            //出现错误会调用这个方法
        &#125;
        @Override
        public void onNext(String s) &#123;
            //处理事件
            Log.d(&quot;DDDDD&quot;,&quot;handle this---&quot;+s)
        &#125;
    &#125;
);
</code></pre>
<p>总结：  </p>
<ul>
<li>创建被观察者，产生事件</li>
<li>设置事件传递过程中的过滤，合并，变换等加工操作。</li>
<li>订阅一个观察者对象，实现事件最终的处理。</li>
</ul>
<blockquote>
<p>Tips: 当调用订阅操作（即调用Observer.subscribe()方法）的时候，被观察者才真正开始发出事件。  </p>
</blockquote>
<h4 id="Map操作"><a href="#Map操作" class="headerlink" title="Map操作"></a>Map操作</h4><p>例子：</p>
<pre><code>Observable.just(&quot;images/logo.png&quot;) // 输入类型 String
.map(new Func1&lt;String, Bitmap&gt;() &#123;
    @Override
    public Bitmap call(String filePath) &#123; // 参数类型 String
        return getBitmapFromPath(filePath); // 返回类型 Bitmap
    &#125;
&#125;)
.subscribe(new Action1&lt;Bitmap&gt;() &#123;
    @Override
    public void call(Bitmap bitmap) &#123; // 参数类型 Bitmap
        showBitmap(bitmap);
    &#125;
&#125;);
</code></pre>
<blockquote>
<p>实际上在使用map操作时，new Func1() 就对应了类型的转你方向，String是原类型，Bitmap是转换后的类型。在call()方法中，输入的是原类型，返回转换后的类型 </p>
</blockquote>
<p>读取文件，创建bitmap可能是一个耗时操作，那么就应该在子线程中执行，主线程应该仅仅做展示。那么线程切换一般就会是比较复杂的事情了。但是在Rxjava中，是非常方便的。</p>
<pre><code>Observable.create(new Observable.just(getFilePath())
   //指定了被观察者执行的线程环境
  .subscribeOn(Schedulers.newThread())
  //将接下来执行的线程环境指定为io线程
  .observeOn(Schedulers.io())
    //使用map操作来完成类型转换
    .map(new Func1&lt;String, Bitmap&gt;() &#123;
      @Override
      public Bitmap call(String s) &#123;
        //显然自定义的createBitmapFromPath(s)方法，是一个极其耗时的操作
          return createBitmapFromPath(s);
      &#125;
  &#125;)
    //将后面执行的线程环境切换为主线程
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(
         //创建观察者，作为事件传递的终点处理事件    
          new Subscriber&lt;Bitmap&gt;() &#123;
                @Override
                public void onCompleted() &#123;
                    Log.d(&quot;DDDDDD&quot;,&quot;结束观察...\n&quot;);
                &#125;

                @Override
                public void onError(Throwable e) &#123;
                    //出现错误会调用这个方法
                &#125;
                @Override
                public void onNext(Bitmap s) &#123;
                    //处理事件
                    showBitmap(s)
                &#125;
            );
    &#125;
</code></pre>
<h4 id="flatMap-操作"><a href="#flatMap-操作" class="headerlink" title="flatMap()操作"></a>flatMap()操作</h4><p>假设这么一种需求：假设有一个数据结构『学生』，现在需要打印出一组学生的名字。实现方式很简单：</p>
<pre><code>Student[] students = ...;
Subscriber&lt;String&gt; subscriber = new Subscriber&lt;String&gt;() &#123;
    @Override
    public void onNext(String name) &#123;
        Log.d(tag, name);
    &#125;
    ...
&#125;;
Observable.from(students)
    .map(new Func1&lt;Student, String&gt;() &#123;
        @Override
        public String call(Student student) &#123;
            return student.getName();
        &#125;
    &#125;)
.subscribe(subscriber);
</code></pre>
<p>很简单。那么再假设：如果要打印出每个学生所需要修的所有课程的名称呢？（需求的区别在于，每个学生只有一个名字，但却有多个课程。）首先可以这样实现：</p>
<pre><code>Student[] students = ...;
Subscriber&lt;Student&gt; subscriber = new Subscriber&lt;Student&gt;() &#123;
    @Override
    public void onNext(Student student) &#123;
        List&lt;Course&gt; courses = student.getCourses();
        for (int i = 0; i &lt; courses.size(); i++) &#123;
            Course course = courses.get(i);
            Log.d(tag, course.getName());
        &#125;
    &#125;
    ...
&#125;;
Observable.from(students)
.subscribe(subscriber);
</code></pre>
<p>依然很简单。那么如果我不想在 Subscriber 中使用 for 循环，而是希望 Subscriber 中直接传入单个的 Course 对象呢（这对于代码复用很重要）？用 map() 显然是不行的，因为 map() 是一对一的转化，而我现在的要求是一对多的转化。那怎么才能把一个 Student 转化成多个 Course 呢？<br>这个时候，就需要用 <code>flatMap()</code> 了：</p>
<pre><code>Student[] students = ...;
Subscriber&lt;Course&gt; subscriber = new Subscriber&lt;Course&gt;() &#123;
    @Override
    public void onNext(Course course) &#123;
        Log.d(tag, course.getName());
    &#125;
    ...
&#125;;
Observable.from(students)
    .flatMap(new Func1&lt;Student, Observable&lt;Course&gt;&gt;() &#123;
        @Override
        public Observable&lt;Course&gt; call(Student student) &#123;
            return Observable.from(student.getCourses());
        &#125;
    &#125;)
.subscribe(subscriber);
</code></pre>
<h4 id="异步（线程调度）"><a href="#异步（线程调度）" class="headerlink" title="异步（线程调度）"></a>异步（线程调度）</h4><p>在讲解Map操作符时，已经提到了线程调度，在这里我用更加简介的代码代替：</p>
<pre><code> Observable.create(new Observable.just(getFilePath())
       //指定在新线程中创建被观察者
      .subscribeOn(Schedulers.newThread())
      //将接下来执行的线程环境指定为io线程
      .observeOn(Schedulers.io())
        //map就处在io线程
      .map(mMapOperater)
        //将后面执行的线程环境切换为主线程，
        //但是这一句依然执行在io线程
      .observeOn(AndroidSchedulers.mainThread())
      //指定线程无效，但这句代码本身执行在主线程
      .subscribeOn(Schedulers.io())
      //执行在主线程
      .subscribe(mSubscriber);
</code></pre>
<p>实际上线程调度只有subscribeOn（）和observeOn（）两个方法。对于初学者，只需要掌握两点：  </p>
<ul>
<li>subscribeOn（）它指示Observable在一个指定的调度器上创建（只作用于被观察者创建阶段）。只能指定一次，如果指定多次则以第一次为准</li>
<li>observeOn（）指定在事件传递（加工变换）和最终被处理（观察者）的发生在哪一个调度器。可指定多次，每次指定完都在下一步生效。</li>
</ul>
<p>RxJava已经为我们提供了一下几个Scheduler</p>
<ul>
<li>Schedulers.immediate()：直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。</li>
<li>Schedulers.newThread()：总是启用新线程，并在新线程执行操作。</li>
<li>Schedulers.io()： I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。</li>
<li>Schedulers.computation()：计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。</li>
<li>AndroidSchedulers.mainThread()：它指定的操作将在 Android 主线程运行。</li>
</ul>
<h4 id="与-Retrofit-的结合"><a href="#与-Retrofit-的结合" class="headerlink" title="与 Retrofit 的结合"></a>与 Retrofit 的结合</h4><p>以获取一个 User 对象的接口作为例子。使用Retrofit 的传统 API，你可以用这样的方式来定义请求：</p>
<pre><code>@GET(&quot;/user&quot;)
public void getUser(@Query(&quot;userId&quot;) String userId, Callback&lt;User&gt; callback);
</code></pre>
<p>在程序的构建过程中， Retrofit 会把自动把方法实现并生成代码，然后开发者就可以利用下面的方法来获取特定用户并处理响应：</p>
<pre><code>getUser(userId, new Callback&lt;User&gt;() &#123;
    @Override
    public void success(User user) &#123;
        userView.setUser(user);
    &#125;

    @Override
    public void failure(RetrofitError error) &#123;
        // Error handling
        ...
    &#125;
&#125;;
</code></pre>
<p>而使用 RxJava 形式的 API，定义同样的请求是这样的：</p>
<pre><code>@GET(&quot;/user&quot;)
public Observable&lt;User&gt; getUser(@Query(&quot;userId&quot;) String userId);
</code></pre>
<p>使用的时候是这样的：</p>
<pre><code>getUser(userId)
    .subscribeOn(Schedulers.newThread())
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(new Observer&lt;User&gt;() &#123;
        @Override
        public void onNext(User user) &#123;
            userView.setUser(user);
        &#125;

        @Override
        public void onCompleted() &#123;
        &#125;

        @Override
        public void onError(Throwable error) &#123;
            // Error handling
            ...
        &#125;
    &#125;);
</code></pre>
<p>再举一个例子：假设 /user 接口并不能直接访问，而需要填入一个在线获取的 token ，代码应该怎么写？<br>Callback 方式，可以使用嵌套的 Callback：</p>
<pre><code>@GET(&quot;/token&quot;)
public void getToken(Callback&lt;String&gt; callback);

@GET(&quot;/user&quot;)
public void getUser(@Query(&quot;token&quot;) String token, @Query(&quot;userId&quot;) String userId, Callback&lt;User&gt; callback);

...

getToken(new Callback&lt;String&gt;() &#123;
    @Override
    public void success(String token) &#123;
        getUser(token, userId, new Callback&lt;User&gt;() &#123;
            @Override
            public void success(User user) &#123;
                userView.setUser(user);
            &#125;

            @Override
            public void failure(RetrofitError error) &#123;
                // Error handling
                ...
            &#125;
        &#125;;
    &#125;

    @Override
    public void failure(RetrofitError error) &#123;
        // Error handling
        ...
    &#125;
&#125;);
</code></pre>
<p>倒是没有什么性能问题，可是迷之缩进毁一生，你懂我也懂，做过大项目的人应该更懂。<br>而使用 RxJava 的话，代码是这样的：</p>
<pre><code>@GET(&quot;/token&quot;)
public Observable&lt;String&gt; getToken();

@GET(&quot;/user&quot;)
public Observable&lt;User&gt; getUser(@Query(&quot;token&quot;) String token, @Query(&quot;userId&quot;) String userId);

...

getToken()
    .flatMap(new Func1&lt;String, Observable&lt;User&gt;&gt;() &#123;
        @Override
        public Observable&lt;User&gt; onNext(String token) &#123;
            return getUser(token, userId);
        &#125;)
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(new Observer&lt;User&gt;() &#123;
        @Override
        public void onNext(User user) &#123;
            userView.setUser(user);
        &#125;

        @Override
        public void onCompleted() &#123;
        &#125;

        @Override
        public void onError(Throwable error) &#123;
            // Error handling
            ...
        &#125;
    &#125;);  
</code></pre>
<p>参考：<br><a href="http://gank.io/post/560e15be2dca930e00da1083">http://gank.io/post/560e15be2dca930e00da1083</a><br><a href="http://gold.xitu.io/post/580103f20e3dd90057fc3e6d">http://gold.xitu.io/post/580103f20e3dd90057fc3e6d</a>  </p>
<p>Demo:<a href="/uploads/RxjavaTest.rar">RxjavaTest.rar</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>SAX解析xml</title>
    <url>/2016/07/06/SAX%E8%A7%A3%E6%9E%90xml/</url>
    <content><![CDATA[<p>常见的xml解析方式有ＤＯＭ解析和ＳＡＸ解析</p>
<span id="more"></span>
<p>DOM（文件对象模型）解析：解析器读入整个文档，然后构建一个驻留内存的树结构，然后代码就可以根据DOM接口来操作这个树结构了。  </p>
<pre><code>优点：整个文档读入内存，方便操作：支持修改、删除和重现排列等多种功能。
缺点：将整个文档读入内存中，保留了过多的不需要的节点，浪费内存和空间。
</code></pre>
<p>为了解决DOM解析存在的问题，就出现了SAX解析</p>
<pre><code>优点：不用实现调入整个文档，占用资源少。尤其在嵌入式环境中，如android，极力推荐使用SAX解析。
缺点：不像DOM解析一样将文档长期驻留在内存中，数据不是持久的。如果事件过后没有保存数据，数据就会丢失。
</code></pre>
<p>使用方法：  </p>
<ol>
<li>先由SAXParserFactory这个工厂的实例生产一个SAXParser解析器；</li>
<li>然后根据读取的xml路径，传递给SAXParser这个解析器，再调用parse()方法；</li>
<li>在parse()方法中需要传递DefaultHandler这个类的扩展类的实例，因为它才会真正去一步步去解析xml文档的；</li>
<li>在DefaultHandler扩展类中需要重写startDocument()，endDocument()，startElement（），endElement（），characters（）等等方法，因为他们方法内部有返回的具体文档的结果。</li>
</ol>
<p>具体代码：</p>
<pre><code>File file = new File(Environment.getExternalStorageDirectory()+&quot;/channel.xml&quot;);
InputStream inputStream = new FileInputStream(file) ;
SAXParserFactory factory = SAXParserFactory.newInstance();
SAXParser parser = factory.newSAXParser();
SAXHeaper handler = new SAXHeaper();
parser.parse(inputStream,handler);
</code></pre>
<p>SAXHeaper类（继承DefaultHandler类）：</p>
<pre><code>import org.xml.sax.helpers.DefaultHandler;

import java.util.ArrayList;

/**
 * Created by ck on 2016/7/6.
 */
public class SAXHeaper extends DefaultHandler &#123;
    private String TagName;
    private channel channel;
    private ArrayList&lt;channel&gt; channels;
    //解析开始
    @Override
    public void startDocument() throws SAXException &#123;
        channels = new ArrayList&lt;channel&gt;();
    &#125;
    //解析结束
    @Override
    public void endDocument() throws SAXException &#123;
        Log.i(&quot;SAXHeaper&quot;,channels.toString());
    &#125;
    //标签开始
    @Override
    public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException &#123;
        TagName = localName;
        if(localName.equals(&quot;item&quot;))&#123;
            channel = new channel();
        &#125;
    &#125;
    //标签结束
    @Override
    public void endElement(String uri, String localName, String qName) throws SAXException &#123;
        TagName = &quot;&quot;;
        if(localName.equals(&quot;item&quot;))&#123;
            channels.add(channel);
            channel = null;
        &#125;

    &#125;
    //标签中的内容
    @Override
    public void characters(char[] ch, int start, int length) throws SAXException &#123;
        String chars = new String(ch,start,length);
        if(TagName.equals(&quot;title&quot;))&#123;
            channel.setTitle(chars);
        &#125;else if(TagName.equals(&quot;link&quot;))&#123;
            channel.setLink(chars);
        &#125;else if(TagName.equals(&quot;category&quot;))&#123;
            channel.setCategory(chars);
        &#125;else if(TagName.equals(&quot;description&quot;))&#123;
            channel.setDescription(chars);
        &#125;else if(TagName.equals(&quot;pubDate&quot;))&#123;
            channel.setPubDate(chars);
        &#125;
    &#125;
&#125;
</code></pre>
<p>代码：<a href="/uploads/SAXTest.zip">SAXTest.zip</a></p>
]]></content>
      <tags>
        <tag>xml</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue双向绑定</title>
    <url>/2021/05/27/Vue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<p>vue.js 采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p>
<span id="more"></span>

<h1 id="大体思路"><a href="#大体思路" class="headerlink" title="大体思路"></a>大体思路</h1><ol>
<li>实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者 </li>
<li>实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数 </li>
<li>实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图 </li>
<li>mvvm入口函数，整合以上三者</li>
</ol>
<h1 id="实现Observer"><a href="#实现Observer" class="headerlink" title="实现Observer"></a>实现Observer</h1><p>将需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 get 和 set 。这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123;<span class="attr">name</span>: <span class="string">&#x27;kindeng&#x27;</span>&#125;;</span><br><span class="line">observe(data);</span><br><span class="line">data.name = <span class="string">&#x27;dmq&#x27;</span>; <span class="comment">// 哈哈哈，监听到值变化了 kindeng --&gt; dmq</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!data || <span class="keyword">typeof</span> data !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取出所有属性遍历</span></span><br><span class="line">    <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">	    defineReactive(data, key, data[key]);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">data, key, val</span>) </span>&#123;</span><br><span class="line">    observe(val); <span class="comment">// 监听子属性</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">        enumerable: <span class="literal">true</span>, <span class="comment">// 可枚举</span></span><br><span class="line">        configurable: <span class="literal">false</span>, <span class="comment">// 不能再define</span></span><br><span class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;,</span><br><span class="line">        set: <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;哈哈哈，监听到值变化了 &#x27;</span>, val, <span class="string">&#x27; --&gt; &#x27;</span>, newVal);</span><br><span class="line">            val = newVal;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>监听到变化之后就是怎么通知订阅者了，所以接下来我们需要实现一个消息订阅器，很简单，维护一个数组，用来收集订阅者，数据变动触发notify，再调用订阅者的update方法，代码改善之后是这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ... 省略</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">data, key, val</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line">    observe(val); <span class="comment">// 监听子属性</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">        <span class="comment">// ... 省略</span></span><br><span class="line">        set: <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">        	<span class="keyword">if</span> (val === newVal) <span class="keyword">return</span>;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;哈哈哈，监听到值变化了 &#x27;</span>, val, <span class="string">&#x27; --&gt; &#x27;</span>, newVal);</span><br><span class="line">            val = newVal;</span><br><span class="line">            dep.notify(); <span class="comment">// 通知所有订阅者</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dep</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.subs = [];</span><br><span class="line">&#125;</span><br><span class="line">Dep.prototype = &#123;</span><br><span class="line">    addSub: <span class="function"><span class="keyword">function</span>(<span class="params">sub</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.subs.push(sub);</span><br><span class="line">    &#125;,</span><br><span class="line">    notify: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.subs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">sub</span>) </span>&#123;</span><br><span class="line">            sub.update();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>那么问题来了，谁是订阅者？怎么往订阅器添加订阅者？ 没错，上面的思路整理中我们已经明确订阅者应该是Watcher, 而且var dep = new Dep();是在 defineReactive方法内部定义的，所以想通过dep添加订阅者，就必须要在闭包内操作，所以我们可以在 getter里面动手脚：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Observer.js</span></span><br><span class="line"><span class="comment">// ...省略</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">	get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="comment">// 由于需要在闭包内添加watcher，所以通过Dep定义一个全局target属性，暂存watcher, 添加完移除</span></span><br><span class="line">		Dep.target &amp;&amp; dep.addDep(Dep.target);</span><br><span class="line">		<span class="keyword">return</span> val;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// ... 省略</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Watcher.js</span></span><br><span class="line">Watcher.prototype = &#123;</span><br><span class="line">	get: <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">		Dep.target = <span class="built_in">this</span>;</span><br><span class="line">		<span class="built_in">this</span>.value = data[key];	<span class="comment">// 这里会触发属性的getter，从而添加订阅者</span></span><br><span class="line">		Dep.target = <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="实现Compile"><a href="#实现Compile" class="headerlink" title="实现Compile"></a>实现Compile</h1><p>compile主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图。</p>
<p>因为遍历解析的过程有多次操作dom节点，为提高性能和效率，会先将vue实例根节点的el转换成文档碎片fragment进行解析编译操作，解析完成，再将fragment添加回原来的真实dom节点中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Compile</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.$el = <span class="built_in">this</span>.isElementNode(el) ? el : <span class="built_in">document</span>.querySelector(el);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.$el) &#123;</span><br><span class="line">        <span class="built_in">this</span>.$fragment = <span class="built_in">this</span>.node2Fragment(<span class="built_in">this</span>.$el);</span><br><span class="line">        <span class="built_in">this</span>.init();</span><br><span class="line">        <span class="built_in">this</span>.$el.appendChild(<span class="built_in">this</span>.$fragment);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Compile.prototype = &#123;</span><br><span class="line">	init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">this</span>.compileElement(<span class="built_in">this</span>.$fragment); &#125;,</span><br><span class="line">    node2Fragment: <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> fragment = <span class="built_in">document</span>.createDocumentFragment(), child;</span><br><span class="line">        <span class="comment">// 将原生节点拷贝到fragment</span></span><br><span class="line">        <span class="keyword">while</span> (child = el.firstChild) &#123;</span><br><span class="line">            fragment.appendChild(child);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fragment;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>compileElement方法将遍历所有节点及其子节点，进行扫描解析编译，调用对应的指令渲染函数进行数据渲染，并调用对应的指令更新函数进行绑定：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Compile.prototype = &#123;</span><br><span class="line">	<span class="comment">// ... 省略</span></span><br><span class="line">	compileElement: <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> childNodes = el.childNodes, me = <span class="built_in">this</span>;</span><br><span class="line">        [].slice.call(childNodes).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> text = node.textContent;</span><br><span class="line">            <span class="keyword">var</span> reg = <span class="regexp">/\&#123;\&#123;(.*)\&#125;\&#125;/</span>;	<span class="comment">// 表达式文本</span></span><br><span class="line">            <span class="comment">// 按元素节点方式编译</span></span><br><span class="line">            <span class="keyword">if</span> (me.isElementNode(node)) &#123;</span><br><span class="line">                me.compile(node);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (me.isTextNode(node) &amp;&amp; reg.test(text)) &#123;</span><br><span class="line">                me.compileText(node, <span class="built_in">RegExp</span>.$1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遍历编译子节点</span></span><br><span class="line">            <span class="keyword">if</span> (node.childNodes &amp;&amp; node.childNodes.length) &#123;</span><br><span class="line">                me.compileElement(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    compile: <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> nodeAttrs = node.attributes, me = <span class="built_in">this</span>;</span><br><span class="line">        [].slice.call(nodeAttrs).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">attr</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 规定：指令以 v-xxx 命名</span></span><br><span class="line">            <span class="comment">// 如 &lt;span v-text=&quot;content&quot;&gt;&lt;/span&gt; 中指令为 v-text</span></span><br><span class="line">            <span class="keyword">var</span> attrName = attr.name;	<span class="comment">// v-text</span></span><br><span class="line">            <span class="keyword">if</span> (me.isDirective(attrName)) &#123;</span><br><span class="line">                <span class="keyword">var</span> exp = attr.value; <span class="comment">// content</span></span><br><span class="line">                <span class="keyword">var</span> dir = attrName.substring(<span class="number">2</span>);	<span class="comment">// text</span></span><br><span class="line">                <span class="keyword">if</span> (me.isEventDirective(dir)) &#123;</span><br><span class="line">                	<span class="comment">// 事件指令, 如 v-on:click</span></span><br><span class="line">                    compileUtil.eventHandler(node, me.$vm, exp, dir);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                	<span class="comment">// 普通指令</span></span><br><span class="line">                    compileUtil[dir] &amp;&amp; compileUtil[dir](node, me.$vm, exp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指令处理集合</span></span><br><span class="line"><span class="keyword">var</span> compileUtil = &#123;</span><br><span class="line">    text: <span class="function"><span class="keyword">function</span>(<span class="params">node, vm, exp</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.bind(node, vm, exp, <span class="string">&#x27;text&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">    bind: <span class="function"><span class="keyword">function</span>(<span class="params">node, vm, exp, dir</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> updaterFn = updater[dir + <span class="string">&#x27;Updater&#x27;</span>];</span><br><span class="line">        <span class="comment">// 第一次初始化视图</span></span><br><span class="line">        updaterFn &amp;&amp; updaterFn(node, vm[exp]);</span><br><span class="line">        <span class="comment">// 实例化订阅者，此操作会在对应的属性消息订阅器中添加了该订阅者watcher</span></span><br><span class="line">        <span class="keyword">new</span> Watcher(vm, exp, <span class="function"><span class="keyword">function</span>(<span class="params">value, oldValue</span>) </span>&#123;</span><br><span class="line">        	<span class="comment">// 一旦属性值有变化，会收到通知执行此更新函数，更新视图</span></span><br><span class="line">            updaterFn &amp;&amp; updaterFn(node, value, oldValue);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新函数</span></span><br><span class="line"><span class="keyword">var</span> updater = &#123;</span><br><span class="line">    textUpdater: <span class="function"><span class="keyword">function</span>(<span class="params">node, value</span>) </span>&#123;</span><br><span class="line">        node.textContent = <span class="keyword">typeof</span> value == <span class="string">&#x27;undefined&#x27;</span> ? <span class="string">&#x27;&#x27;</span> : value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里通过递归遍历保证了每个节点及子节点都会解析编译到，包括了<code>&#123;&#123;&#125;&#125;</code>表达式声明的文本节点。 </p>
<p>指令的声明规定是通过特定前缀的节点属性来标记，如<code>span v-text="content" other-attr</code>中v-text便是指令，而other-attr不是指令，只是普通的属性。    </p>
<p>监听数据、绑定更新函数的处理是在compileUtil.bind()这个方法中，通过new Watcher()添加回调来接收数据变化的通知</p>
<h1 id="实现Watcher"><a href="#实现Watcher" class="headerlink" title="实现Watcher"></a>实现Watcher</h1><p>Watcher订阅者作为Observer和Compile之间通信的桥梁，主要做的事情是: </p>
<ol>
<li>在自身实例化时往属性订阅器(dep)里面添加自己 </li>
<li>自身必须有一个update()方法 </li>
<li>待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Watcher</span>(<span class="params">vm, exp, cb</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.cb = cb;</span><br><span class="line">    <span class="built_in">this</span>.vm = vm;</span><br><span class="line">    <span class="built_in">this</span>.exp = exp;</span><br><span class="line">    <span class="comment">// 此处为了触发属性的getter，从而在dep添加自己，结合Observer更易理解</span></span><br><span class="line">    <span class="built_in">this</span>.value = <span class="built_in">this</span>.get(); </span><br><span class="line">&#125;</span><br><span class="line">Watcher.prototype = &#123;</span><br><span class="line">    update: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.run();	<span class="comment">// 属性值变化收到通知</span></span><br><span class="line">    &#125;,</span><br><span class="line">    run: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> value = <span class="built_in">this</span>.get(); <span class="comment">// 取到最新值</span></span><br><span class="line">        <span class="keyword">var</span> oldVal = <span class="built_in">this</span>.value;</span><br><span class="line">        <span class="keyword">if</span> (value !== oldVal) &#123;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.cb.call(<span class="built_in">this</span>.vm, value, oldVal); <span class="comment">// 执行Compile中绑定的回调，更新视图</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        Dep.target = <span class="built_in">this</span>;	<span class="comment">// 将当前订阅者指向自己</span></span><br><span class="line">        <span class="keyword">var</span> value = <span class="built_in">this</span>.vm[exp];	<span class="comment">// 触发getter，添加自己到属性订阅器中</span></span><br><span class="line">        Dep.target = <span class="literal">null</span>;	<span class="comment">// 添加完毕，重置</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 这里再次列出Observer和Dep，方便理解</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">	get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="comment">// 由于需要在闭包内添加watcher，所以可以在Dep定义一个全局target属性，暂存watcher, 添加完移除</span></span><br><span class="line">		Dep.target &amp;&amp; dep.addDep(Dep.target);</span><br><span class="line">		<span class="keyword">return</span> val;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// ... 省略</span></span><br><span class="line">&#125;);</span><br><span class="line">Dep.prototype = &#123;</span><br><span class="line">    notify: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.subs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">sub</span>) </span>&#123;</span><br><span class="line">            sub.update(); <span class="comment">// 调用订阅者的update方法，通知变化</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>实例化Watcher的时候，调用get()方法，通过Dep.target = watcherInstance标记订阅者是当前watcher实例，强行触发属性定义的getter方法，getter方法执行的时候，就会在属性的订阅器dep添加当前watcher实例，从而在属性值有变化的时候，watcherInstance就能收到更新通知。  </p>
<h1 id="实现MVVM"><a href="#实现MVVM" class="headerlink" title="实现MVVM"></a>实现MVVM</h1><p>MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。<br>一个简单的MVVM构造器是这样子：  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MVVM</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.$options = options;</span><br><span class="line">    <span class="keyword">var</span> data = <span class="built_in">this</span>._data = <span class="built_in">this</span>.$options.data;</span><br><span class="line">    observe(data, <span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">this</span>.$compile = <span class="keyword">new</span> Compile(options.el || <span class="built_in">document</span>.body, <span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是这里有个问题，从代码中可看出监听的数据对象是options.data，每次需要更新视图，则必须通过<code>var vm = new MVVM(&#123;data:&#123;name: 'kindeng'&#125;&#125;); vm._data.name = 'dmq'; </code>这样的方式来改变数据。   </p>
<p>显然不符合我们一开始的期望，我们所期望的调用方式应该是这样的：<code> var vm = new MVVM(&#123;data: &#123;name: 'kindeng'&#125;&#125;); vm.name = 'dmq';</code>  </p>
<p>所以这里需要给MVVM实例添加一个属性代理的方法，使访问vm的属性代理为访问vm._data的属性，改造后的代码如下：    </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MVVM</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.$options = options;</span><br><span class="line">    <span class="keyword">var</span> data = <span class="built_in">this</span>._data = <span class="built_in">this</span>.$options.data, me = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// 属性代理，实现 vm.xxx -&gt; vm._data.xxx</span></span><br><span class="line">    <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">        me._proxy(key);</span><br><span class="line">    &#125;);</span><br><span class="line">    observe(data, <span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">this</span>.$compile = <span class="keyword">new</span> Compile(options.el || <span class="built_in">document</span>.body, <span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MVVM.prototype = &#123;</span><br><span class="line">	_proxy: <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> me = <span class="built_in">this</span>;</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(me, key, &#123;</span><br><span class="line">            configurable: <span class="literal">false</span>,</span><br><span class="line">            enumerable: <span class="literal">true</span>,</span><br><span class="line">            get: <span class="function"><span class="keyword">function</span> <span class="title">proxyGetter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> me._data[key];</span><br><span class="line">            &#125;,</span><br><span class="line">            set: <span class="function"><span class="keyword">function</span> <span class="title">proxySetter</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">                me._data[key] = newVal;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Object-defineProperty-有什么缺陷？为什么在-Vue3-0-采用了-Proxy，抛弃了-Object-defineProperty？"><a href="#Object-defineProperty-有什么缺陷？为什么在-Vue3-0-采用了-Proxy，抛弃了-Object-defineProperty？" class="headerlink" title="Object.defineProperty 有什么缺陷？为什么在 Vue3.0 采用了 Proxy，抛弃了 Object.defineProperty？"></a>Object.defineProperty 有什么缺陷？为什么在 Vue3.0 采用了 Proxy，抛弃了 Object.defineProperty？</h1><ol>
<li>Object.defineProperty无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应；</li>
<li>Object.defineProperty只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。Proxy可以劫持整个对象，并返回一个新的对象。</li>
<li>Proxy不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性。</li>
<li>Object.defineProperty无法代理动态增加的属性</li>
</ol>
<h1 id="vue-如何优化首页的加载速度？vue-首页白屏是什么问题引起的？如何解决呢？"><a href="#vue-如何优化首页的加载速度？vue-首页白屏是什么问题引起的？如何解决呢？" class="headerlink" title="vue 如何优化首页的加载速度？vue 首页白屏是什么问题引起的？如何解决呢？"></a>vue 如何优化首页的加载速度？vue 首页白屏是什么问题引起的？如何解决呢？</h1><ol>
<li>使用首屏SSR + 跳转SPA方式来优化</li>
<li>改单页应用为多页应用，需要修改webpack的entry</li>
<li>改成多页以后使用应该使用prefetch的就使用</li>
<li>处理加载的时间片，合理安排加载顺序，尽量不要有大面积空隙</li>
<li>CDN资源还是很重要的，最好分开，也能减少一些不必要的资源损耗</li>
<li>使用Quicklink，在网速好的时候 可以帮助你预加载页面资源</li>
<li>骨架屏这种的用户体验的东西一定要上，最好借助stream先将这部分输出给浏览器解析</li>
<li>合理使用web worker优化一些计算</li>
<li>缓存一定要使用，但是请注意合理使用</li>
<li>大概就这么多，最后可以借助一些工具进行性能评测，重点调优，例如使用performance自己实现下等</li>
</ol>
<h1 id="vue-是如何对数组方法进行变异的？例如-push、pop、splice-等方法"><a href="#vue-是如何对数组方法进行变异的？例如-push、pop、splice-等方法" class="headerlink" title="vue 是如何对数组方法进行变异的？例如 push、pop、splice 等方法"></a>vue 是如何对数组方法进行变异的？例如 push、pop、splice 等方法</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> methodsToPatch = [</span><br><span class="line">  <span class="string">&#x27;push&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;shift&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;unshift&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;splice&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;sort&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;reverse&#x27;</span></span><br><span class="line">]</span><br><span class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// cache original method</span></span><br><span class="line">    <span class="comment">// 获取原方法</span></span><br><span class="line">    <span class="keyword">var</span> original = arrayProto[method];</span><br><span class="line">    <span class="comment">// def方法重新定义arrayMethods的method方法，然后将新的取值方法赋值</span></span><br><span class="line">    def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> args = [],</span><br><span class="line">        len = <span class="built_in">arguments</span>.length;</span><br><span class="line">      <span class="keyword">while</span> (len--) args[len] = <span class="built_in">arguments</span>[len];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> result = original.apply(<span class="built_in">this</span>, args);</span><br><span class="line">      <span class="keyword">var</span> ob = <span class="built_in">this</span>.__ob__;</span><br><span class="line">      <span class="keyword">var</span> inserted;</span><br><span class="line">      <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;push&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;unshift&#x27;</span>:</span><br><span class="line">          <span class="comment">// [].push(1),[].unshift(1)</span></span><br><span class="line">          <span class="comment">// arg = [1]</span></span><br><span class="line">          inserted = args;</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;splice&#x27;</span>:</span><br><span class="line">          <span class="comment">// [1,2,3].splice(0,1,1)</span></span><br><span class="line">          <span class="comment">// 第三个参数为插入的值</span></span><br><span class="line">          inserted = args.slice(<span class="number">2</span>);</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (inserted) &#123; ob.observeArray(inserted); &#125;</span><br><span class="line">      <span class="comment">// 监听变化，如果不是插入操作直接循环响应</span></span><br><span class="line">      <span class="comment">// 如果是去除数组参数方法，触发一次notify将会重新计算</span></span><br><span class="line">      <span class="comment">// 如果仅仅是数字数据，任何操作只需要再次执行一次notify则可以</span></span><br><span class="line">      <span class="comment">// 但是如果新增的是一个对象类型，就需要重新监听</span></span><br><span class="line">      <span class="comment">// 为什么用角标和length属性不能监听的原因是因为无法触发obj的get方法，所以没法动态监听</span></span><br><span class="line">      <span class="comment">// notify change</span></span><br><span class="line">      ob.dep.notify();</span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h1 id="谈一谈-nextTick-的原理"><a href="#谈一谈-nextTick-的原理" class="headerlink" title="谈一谈 nextTick 的原理"></a>谈一谈 nextTick 的原理</h1><p>nextTick 中的回调是在下次 DOM 更新循环结束之后执行的延迟回调。</p>
<p>Promise -&gt; MutationObserver -&gt; setImmediate -&gt; setTimeout</p>
<h1 id="Vue-中的-computed-和-watch-的区别在哪里"><a href="#Vue-中的-computed-和-watch-的区别在哪里" class="headerlink" title="Vue 中的 computed 和 watch 的区别在哪里"></a>Vue 中的 computed 和 watch 的区别在哪里</h1><ol>
<li><p>watch擅长处理的场景：一个数据影响多个数据</p>
</li>
<li><p>computed擅长处理的场景：一个数据受多个数据影响</p>
</li>
</ol>
<p><a href="https://github.com/DMQ/mvvm">参考链接</a></p>
]]></content>
  </entry>
  <entry>
    <title>Vue父子组件传参</title>
    <url>/2021/05/27/Vue%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/</url>
    <content><![CDATA[<h1 id="props-和-emit"><a href="#props-和-emit" class="headerlink" title="props 和 $emit"></a>props 和 $emit</h1><span id="more"></span>

<h2 id="在-Vue-中，子组件为何不可以修改父组件传递的-Prop"><a href="#在-Vue-中，子组件为何不可以修改父组件传递的-Prop" class="headerlink" title="在 Vue 中，子组件为何不可以修改父组件传递的 Prop"></a>在 Vue 中，子组件为何不可以修改父组件传递的 Prop</h2><p>为了保证数据的单向流动，便于对数据进行追踪，避免数据混乱。</p>
<h2 id="Vue-的父组件和子组件生命周期钩子执行顺序是什么"><a href="#Vue-的父组件和子组件生命周期钩子执行顺序是什么" class="headerlink" title="Vue 的父组件和子组件生命周期钩子执行顺序是什么"></a>Vue 的父组件和子组件生命周期钩子执行顺序是什么</h2><ol>
<li>加载渲染过程 父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted</li>
<li>子组件更新过程 父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</li>
<li>父组件更新过程 父beforeUpdate-&gt;父updated</li>
<li>销毁过程 父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</li>
</ol>
<h1 id="attrs-和-listeners"><a href="#attrs-和-listeners" class="headerlink" title="$attrs 和 $listeners"></a>$attrs 和 $listeners</h1><p>上面这种组件通信的方式只适合直接的父子组件，也就是如果父组件A下面有子组件B，组件B下面有组件C，这时如果组件A直接想传递数据给组件C那就行不通了！ 只能是组件A通过 props 将数据传给组件B，然后组件B获取到组件A 传递过来的数据后再通过 props 将数据传给组件C。当然这种方式是非常复杂的，无关组件中的逻辑业务一种增多了，代码维护也没变得困难，再加上如果嵌套的层级越多逻辑也复杂，无关代码越多！</p>
<p>$attrs 和 $listeners 来实现能够直接让组件A传递消息给组件C。</p>
<p> v-bind=”$attrs” v-on=”$listeners”</p>
<h1 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus"></a>EventBus</h1><h1 id="provide-和-inject"><a href="#provide-和-inject" class="headerlink" title="provide 和 inject"></a>provide 和 inject</h1><h1 id="Vuex-状态管理"><a href="#Vuex-状态管理" class="headerlink" title="Vuex 状态管理"></a>Vuex 状态管理</h1><p>使用场景：</p>
<p>vuex 一般用于中大型 web 单页应用中对应用的状态进行管理 全局的数据中心。<br>vuex 更多地用于解决跨组件通信以及作为数据中心集中式存储数据。</p>
<h2 id="Redux-和-Vuex-的设计思想"><a href="#Redux-和-Vuex-的设计思想" class="headerlink" title="Redux 和 Vuex 的设计思想"></a>Redux 和 Vuex 的设计思想</h2><p>共同点：<br>首先两者都是处理全局状态的工具库，大致实现思想都是：全局state保存状态—-&gt;dispatch(action) ——&gt;reducer(vuex里的mutation)—-&gt; 生成newState; 整个状态为同步操作；</p>
<p>区别：<br>最大的区别在于处理异步的不同，vuex里面多了一步commit操作，在action之后commit(mutation)之前处理异步，而redux里面则是通过中间件处理</p>
<h2 id="为什么-Vuex-的-mutation-和-Redux-的-reducer-中不能做异步操作？"><a href="#为什么-Vuex-的-mutation-和-Redux-的-reducer-中不能做异步操作？" class="headerlink" title="为什么 Vuex 的 mutation 和 Redux 的 reducer 中不能做异步操作？"></a>为什么 Vuex 的 mutation 和 Redux 的 reducer 中不能做异步操作？</h2><p>同步的意义在于这样每一个 mutation 执行完成后都可以对应到一个新的状态（和 reducer 一样），这样 devtools 就可以打个 snapshot 存下来，然后就可以随便 time-travel 了。如果你开着 devtool 调用一个异步的 action，你可以清楚地看到它所调用的 mutation 是何时被记录下来的，并且可以立刻查看它们对应的状态。</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue的diff算法</title>
    <url>/2021/05/27/Vue%E7%9A%84diff%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="传统diff"><a href="#传统diff" class="headerlink" title="传统diff"></a>传统diff</h1><p>传统Diff算法需要找到两个树的最小更新方式，所以需要[两两]对比每个叶子节点是否相同，对比就需要O(n^2)次了，比较之后还得计算最小转化方式，所以综合复杂度就是 O(n^3)。</p>
<span id="more"></span>

<h1 id="框架中的diff"><a href="#框架中的diff" class="headerlink" title="框架中的diff"></a>框架中的diff</h1><p>大前提：Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。</p>
<p>框架中的diff，只对同层节点进行比较，忽略跨层节点的复用</p>
<p>同层节点的比较也不会两两进行，而是按照一定的顺序比较，或通过 key 属性判断，所以只需要遍历一次新节点，因此算法的复杂度就降低到了O(n)</p>
<h1 id="vue-实例代码分析"><a href="#vue-实例代码分析" class="headerlink" title="vue 实例代码分析"></a>vue 实例代码分析</h1><h2 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h2><p>在 vue 中会维护一个和 DOM 节点对应的 vnode 对象<br>例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span>&gt;</span>123<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  elm: el, <span class="comment">// 对应真实的DOM节点</span></span><br><span class="line">  tag: <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">  key: <span class="number">1</span>,</span><br><span class="line">  text: <span class="string">&#x27;123&#x27;</span>,</span><br><span class="line">  children: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="patch函数"><a href="#patch函数" class="headerlink" title="patch函数"></a>patch函数</h2><p>patch函数是 diff 流程的入口函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patch</span> (<span class="params">oldVnode, vnode</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">  <span class="keyword">if</span> (sameVnode(oldVnode, vnode)) &#123;</span><br><span class="line">    <span class="comment">// patch existing root node</span></span><br><span class="line">    patchVnode(oldVnode, vnode)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// replacing existing element</span></span><br><span class="line">    <span class="keyword">const</span> oldElm = oldVnode.elm</span><br><span class="line">    <span class="keyword">const</span> parentElm = nodeOps.parentNode(oldElm)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create new node</span></span><br><span class="line">    createElm(</span><br><span class="line">      vnode,</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      parentElm,</span><br><span class="line">      nodeOps.nextSibling(oldElm)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// destroy old node</span></span><br><span class="line">    <span class="keyword">if</span> (isDef(parentElm)) &#123;</span><br><span class="line">      removeVnodes([oldVnode], <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> vnode.elm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>patch函数的逻辑比较简单：</p>
<ol>
<li><p>判断节点是否可以复用，可以复用则对节点打补丁</p>
</li>
<li><p>节点不可复用，创建新的节点插入到旧节点之后，同时删除旧节点</p>
</li>
</ol>
<p>如果节点不可复用，直接创建新节点替换，旧的子节点也将不再考虑复用。这就是对应了 diff 的假设，Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。</p>
<h2 id="sameVnode函数"><a href="#sameVnode函数" class="headerlink" title="sameVnode函数"></a>sameVnode函数</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sameVnode</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    a.key === b.key &amp;&amp; (</span><br><span class="line">      (</span><br><span class="line">        a.tag === b.tag &amp;&amp;</span><br><span class="line">        a.isComment === b.isComment &amp;&amp;</span><br><span class="line">        isDef(a.data) === isDef(b.data) &amp;&amp;</span><br><span class="line">        sameInputType(a, b)</span><br><span class="line">      ) || (</span><br><span class="line">        isTrue(a.isAsyncPlaceholder) &amp;&amp;</span><br><span class="line">        a.asyncFactory === b.asyncFactory &amp;&amp;</span><br><span class="line">        isUndef(b.asyncFactory.error)</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可大致理解为，当 tag key inputType 完全相同时，我们认定节点可复用。</p>
<h2 id="patchVnode函数"><a href="#patchVnode函数" class="headerlink" title="patchVnode函数"></a>patchVnode函数</h2><p>对可复用节点进行打补丁</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchVnode</span>(<span class="params">oldVnode, vnode</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">  <span class="keyword">if</span> (oldVnode === vnode) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> elm = (vnode.elm = oldVnode.elm);</span><br><span class="line">  <span class="keyword">const</span> oldCh = oldVnode.children;</span><br><span class="line">  <span class="keyword">const</span> ch = vnode.children;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 非文本节点</span></span><br><span class="line">  <span class="keyword">if</span> (isUndef(vnode.text)) &#123;</span><br><span class="line">    <span class="comment">// 新旧节点都有子节点</span></span><br><span class="line">    <span class="keyword">if</span> (isDef(oldCh) &amp;&amp; isDef(ch)) &#123;</span><br><span class="line">      <span class="comment">// 子节点的同层比较</span></span><br><span class="line">      <span class="keyword">if</span> (oldCh !== ch)</span><br><span class="line">        updateChildren(elm, oldCh, ch);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(ch)) &#123;</span><br><span class="line">      <span class="comment">// 仅新元素有子节点</span></span><br><span class="line">      <span class="keyword">if</span> (isDef(oldVnode.text)) nodeOps.setTextContent(elm, <span class="string">&quot;&quot;</span>);</span><br><span class="line">      addVnodes(elm, <span class="literal">null</span>, ch, <span class="number">0</span>, ch.length - <span class="number">1</span>, <span class="literal">null</span>);</span><br><span class="line">      <span class="comment">// 仅旧元素有子节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldCh)) &#123;</span><br><span class="line">      removeVnodes(oldCh, <span class="number">0</span>, oldCh.length - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldVnode.text)) &#123;</span><br><span class="line">      <span class="comment">// 清空文本</span></span><br><span class="line">      nodeOps.setTextContent(elm, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 文本节点，更新文本即可</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldVnode.text !== vnode.text) &#123;</span><br><span class="line">    nodeOps.setTextContent(elm, vnode.text);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>patchVnode函数的逻辑:</p>
<ol>
<li>找到对应的 dom 节点 elm，并且赋值给 vnode.elm</li>
<li>判断新节点类型（vnode.text），如果是文本节点，更新 elm 文本即可</li>
<li>非文本节点下，判断新老节点的子节点</li>
<li>如果新老节点都有子节点，走子节点的同层比较流程 updateChildren</li>
<li>如果只有新节点有子节点，直接使用 addVnodes 为 elm 添加子节点（先删除文本）</li>
<li>如果只有旧节点有子节点，使用 removeVnodes 移除即可</li>
<li>如果都没有子节点，判断旧数据是否有文本节点，有则清空</li>
</ol>
<h2 id="updateChildren"><a href="#updateChildren" class="headerlink" title="updateChildren"></a>updateChildren</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateChildren</span>(<span class="params">parentElm, oldCh, newCh</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> oldStartIdx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> newStartIdx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> oldEndIdx = oldCh.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> oldStartVnode = oldCh[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">let</span> oldEndVnode = oldCh[oldEndIdx];</span><br><span class="line">  <span class="keyword">let</span> newEndIdx = newCh.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> newStartVnode = newCh[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">let</span> newEndVnode = newCh[newEndIdx];</span><br><span class="line">  <span class="keyword">let</span> oldKeyToIdx, idxInOld, vnodeToMove, refElm;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isUndef(oldStartVnode)) &#123;</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx]; <span class="comment">// Vnode has been moved left</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isUndef(oldEndVnode)) &#123;</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">      patchVnode(oldStartVnode, newStartVnode);</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx];</span><br><span class="line">      newStartVnode = newCh[++newStartIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">      patchVnode(oldEndVnode, newEndVnode);</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">      newEndVnode = newCh[--newEndIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123;</span><br><span class="line">      <span class="comment">// Vnode moved right</span></span><br><span class="line">      patchVnode(oldStartVnode, newEndVnode);</span><br><span class="line">      nodeOps.insertBefore(</span><br><span class="line">        parentElm,</span><br><span class="line">        oldStartVnode.elm,</span><br><span class="line">        nodeOps.nextSibling(oldEndVnode.elm)</span><br><span class="line">      );</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx];</span><br><span class="line">      newEndVnode = newCh[--newEndIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123;</span><br><span class="line">      <span class="comment">// Vnode moved left</span></span><br><span class="line">      patchVnode(oldEndVnode, newStartVnode);</span><br><span class="line">      nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">      newStartVnode = newCh[++newStartIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (isUndef(oldKeyToIdx))</span><br><span class="line">        oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);</span><br><span class="line"></span><br><span class="line">      idxInOld = isDef(newStartVnode.key)</span><br><span class="line">        ? oldKeyToIdx[newStartVnode.key]</span><br><span class="line">        : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (isUndef(idxInOld)) &#123;</span><br><span class="line">        <span class="comment">// New element</span></span><br><span class="line">        createElm(</span><br><span class="line">          newStartVnode,</span><br><span class="line">          <span class="literal">null</span>,</span><br><span class="line">          parentElm,</span><br><span class="line">          oldStartVnode.elm</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vnodeToMove = oldCh[idxInOld];</span><br><span class="line">        <span class="keyword">if</span> (sameVnode(vnodeToMove, newStartVnode)) &#123;</span><br><span class="line">          patchVnode(vnodeToMove, newStartVnode);</span><br><span class="line">          oldCh[idxInOld] = <span class="literal">undefined</span>;</span><br><span class="line">          nodeOps.insertBefore(</span><br><span class="line">            parentElm,</span><br><span class="line">            vnodeToMove.elm,</span><br><span class="line">            oldStartVnode.elm</span><br><span class="line">          );</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// same key but different element. treat as new element</span></span><br><span class="line">          createElm(newStartVnode, insertedVnodeQueue, parentElm);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      newStartVnode = newCh[++newStartIdx];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">    refElm = isUndef(newCh[newEndIdx + <span class="number">1</span>])</span><br><span class="line">      ? <span class="literal">null</span></span><br><span class="line">      : newCh[newEndIdx + <span class="number">1</span>].elm;</span><br><span class="line">    addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">    removeVnodes(oldCh, oldStartIdx, oldEndIdx);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>startIdx endIdx 称为左指针，右指针，相应的 startVnode，endVnode 我们称其为左节点，右节点</p>
<p>updateChildren逻辑：</p>
<ol>
<li>当左指针小于等于右指针循环遍历</li>
<li>判断老节点边界为null的情况，向内移动指针</li>
<li>判断左节点是否可以复用，可以则为节点打补丁（递归调用 patchVnode，下同），向右移动指针</li>
<li>否则，判断右节点是否可以复用，可以则为节点打补丁，向左移动指针</li>
<li>否则，判断新右节点和旧左节点是否可以复用，可以则为节点打补丁，同时将旧左节点移动到旧右节点后面，再向内移动指针</li>
<li>否则，判断新左节点和旧右节点是否可以复用，可以则为节点打补丁，同时将旧右节点移动到旧左节点前，向内移动指针</li>
<li>否则 若oldKeyToIdx没有定义，则通过createKeyToOldIdx来得到旧节点索引和 key 属性的映射</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createKeyToOldIdx</span> (<span class="params">children, beginIdx, endIdx</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i, key</span><br><span class="line">  <span class="keyword">const</span> map = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (i = beginIdx; i &lt;= endIdx; ++i) &#123;</span><br><span class="line">    key = children[i].key</span><br><span class="line">    <span class="keyword">if</span> (isDef(key)) map[key] = i</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> map</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="8">
<li>查找左新节点的key在旧节点的位置idxInOld，若新左节点的key不存在，则调用findIdxInOld获取<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findIdxInOld</span> (<span class="params">node, oldCh, start, end</span>) </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> c = oldCh[i]</span><br><span class="line">    <span class="keyword">if</span> (isDef(c) &amp;&amp; sameVnode(node, c)) <span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>若idxInOld不存在，则在旧左节点插入新建点</li>
<li>若idxInOld存在，判断是否是相同节点，若是，则为idxInOld对应的旧节点做补丁，将此节点插入到旧左节点前，内移动指针</li>
<li>若节点不同，创建新节点，插入旧左节点前，内移动指针</li>
<li>若旧节点已遍历完，则批量向后添加剩余新节点</li>
<li>若新节点已遍历完，则批量删除剩余旧节点</li>
</ol>
<h1 id="写-React-Vue-项目时为什么要在列表组件中写-key，其作用是什么？"><a href="#写-React-Vue-项目时为什么要在列表组件中写-key，其作用是什么？" class="headerlink" title="写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？"></a>写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？</h1><h2 id="不用-key："><a href="#不用-key：" class="headerlink" title="不用 key："></a>不用 key：</h2><ol>
<li><p>就地复用节点。在比较新旧两个节点是否是同一个节点的过程中会判断成新旧两个节点是同一个节点，因为 a.key 和 b.key 都是 undefined。所以不会重新创建节点和删除节点，只会在节点的属性层面上进行比较和更新。所以可能在某种程度上（创建和删除节点方面）会有渲染性能上的提升</p>
</li>
<li><p>无法维持组件的状态。由于就地复用节点的关系，可能在维持组件状态方面会导致不可预知的错误，比如无法维持改组件的动画效果、开关等状态；</p>
</li>
<li><p>也有可能会带来性能下降。因为是直接就地复用节点，如果修改的组件，需要复用的很多节点，顺序又和原来的完全不同的话，那么创建和删除的节点数量就会比带 key 的时候增加很多，性能就会有所下降（对应前面的findIdxInOld而不是用map）</p>
</li>
</ol>
<h2 id="用key"><a href="#用key" class="headerlink" title="用key:"></a>用key:</h2><ol>
<li><p>维持组件的状态，保证组件的复用。因为有 key 唯一标识了组件，不会在每次比较新旧两个节点是否是同一个节点的时候直接判断为同一个节点，而是会继续在接下来的节点中找到 key 相同的节点去比较，能找到相同的 key 的话就复用节点，不能找到的话就增加或者删除节点。</p>
</li>
<li><p>查找性能上的提升。有 key 的时候，会生成 hash，这样在查找的时候就是 hash 查找了，基本上就是 O(1) 的复杂度。（使用map 而不是 findIdxInOld）</p>
</li>
</ol>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>android_AppWidget</title>
    <url>/2016/07/15/android-AppWidget/</url>
    <content><![CDATA[<p>AppWidget就是我们平常在桌面上见到的那种一个个的小窗口，利用这个小窗口可以给用户提供一些方便快捷的操作。</p>
<span id="more"></span>
<h4 id="创建一个简单的AppWidget"><a href="#创建一个简单的AppWidget" class="headerlink" title="创建一个简单的AppWidget"></a>创建一个简单的AppWidget</h4><ol>
<li><p>在res文件夹下新建一个名字为xml的文件夹，然后在xml目录下创建一个appwidget_info_info.xml文件</p>
<pre><code> &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
 &lt;appwidget-provider xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
     android:initialKeyguardLayout=&quot;@layout/appwidget_info&quot;
     android:initialLayout=&quot;@layout/appwidget_info&quot;
     android:minHeight=&quot;40dp&quot;
     android:minWidth=&quot;250dp&quot;
     android:previewImage=&quot;@drawable/example_appwidget_preview&quot;
     android:resizeMode=&quot;horizontal|vertical&quot;
     android:updatePeriodMillis=&quot;86400000&quot;
     android:widgetCategory=&quot;home_screen&quot;&gt;&lt;/appwidget-provider&gt;
</code></pre>
</li>
<li><p>在layout文件夹下面新建一个appwidgetlayout.xml文件</p>
<pre><code> &lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
 android:layout_width=&quot;match_parent&quot;
 android:layout_height=&quot;match_parent&quot;
 android:padding=&quot;@dimen/widget_margin&quot;&gt;

     &lt;TextView
         android:id=&quot;@+id/appwidget_text&quot;
         android:layout_width=&quot;wrap_content&quot;
         android:layout_height=&quot;wrap_content&quot;
         android:contentDescription=&quot;@string/appwidget_text&quot;
         android:text=&quot;@string/appwidget_text&quot;
         android:textSize=&quot;24sp&quot;
         android:textStyle=&quot;bold|italic&quot;
         android:layout_marginLeft=&quot;8dp&quot;
         android:layout_marginRight=&quot;8dp&quot;
         android:layout_alignParentTop=&quot;true&quot;
         android:layout_alignParentStart=&quot;true&quot; /&gt;
 
     &lt;Button
         android:layout_width=&quot;wrap_content&quot;
         android:layout_height=&quot;wrap_content&quot;
         android:text=&quot;@string/btn_name&quot;
         android:id=&quot;@+id/button&quot;
         android:layout_below=&quot;@+id/appwidget_text&quot;
         android:layout_alignStart=&quot;@+id/appwidget_text&quot; /&gt;

 &lt;/RelativeLayout&gt;  
</code></pre>
</li>
<li><p>继承AppWidgetProvider类</p>
<pre><code> public class appwidgetInfo extends AppWidgetProvider &#123;

     private  static  String broadCastString = &quot;com.caokai.broadCastString&quot;;
     static void updateAppWidget(Context context, AppWidgetManager appWidgetManager,
                                 int appWidgetId) &#123;
         //发送广播的PendingIntent
         Intent intent = new Intent();
         intent.setAction(broadCastString);
         PendingIntent pendingIntent = PendingIntent.getBroadcast(context,0,intent,0);
         
         //启动activity的PendingIntent
         Intent activityIntent =  new Intent(context,MainActivity.class);
         PendingIntent pendingIntent1 = PendingIntent.getActivity(context,0,activityIntent,0);
 
         CharSequence widgetText = &quot;test&quot;;
         // 获取RemoteViews
         RemoteViews views = new RemoteViews(context.getPackageName(), R.layout.appwidget_info);
         views.setTextViewText(R.id.appwidget_text, widgetText);
         
         //设置点击事件
         views.setOnClickPendingIntent(R.id.button,pendingIntent);
         //设置点击事件
         views.setOnClickPendingIntent(R.id.appwidget_text,pendingIntent1);

         // Instruct the widget manager to update the widget
         appWidgetManager.updateAppWidget(appWidgetId, views);
     &#125;
 
     @Override
     public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) &#123;
         // There may be multiple widgets active, so update all of them
         for (int appWidgetId : appWidgetIds) &#123;
             updateAppWidget(context, appWidgetManager, appWidgetId);
         &#125;
     &#125;
 
     @Override
     public void onEnabled(Context context) &#123;
         // Enter relevant functionality for when the first widget is created
     &#125;
 
     @Override
     public void onDisabled(Context context) &#123;
         // Enter relevant functionality for when the last widget is disabled
     &#125;
 
     @Override
     public void onReceive(Context context, Intent intent) &#123;
         if(intent.getAction().equals(broadCastString))&#123;
             RemoteViews remoteViews = new RemoteViews(context.getPackageName(),R.layout.appwidget_info);
             remoteViews.setTextViewText(R.id.appwidget_text,&quot;点击到了&quot;);
 
             AppWidgetManager appWidgetManager =  AppWidgetManager.getInstance(context);
 
             ComponentName componentName = new ComponentName(context,appwidgetInfo.class);
             appWidgetManager.updateAppWidget(componentName,remoteViews);
         &#125;else&#123;
             super.onReceive(context, intent);
         &#125;
 
     &#125;
 &#125;
</code></pre>
</li>
<li><p>AndroidManifest.xml中申明</p>
<pre><code> &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
 &lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
     package=&quot;caokai.com.appwidgettest&quot;&gt;
 
     &lt;application
         android:allowBackup=&quot;true&quot;
         android:icon=&quot;@mipmap/ic_launcher&quot;
         android:label=&quot;@string/app_name&quot;
         android:supportsRtl=&quot;true&quot;
         android:theme=&quot;@style/AppTheme&quot;&gt;
         &lt;activity android:name=&quot;.MainActivity&quot;&gt;
             &lt;intent-filter&gt;
                 &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
 
                 &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
             &lt;/intent-filter&gt;
         &lt;/activity&gt;
 
         &lt;receiver android:name=&quot;.appwidgetInfo&quot;&gt;
             &lt;intent-filter&gt;
                 &lt;action android:name=&quot;android.appwidget.action.APPWIDGET_UPDATE&quot; /&gt;
             &lt;/intent-filter&gt;
             &lt;intent-filter&gt;
                 &lt;action android:name=&quot;com.caokai.broadCastString&quot; /&gt;
             &lt;/intent-filter&gt;
 
             &lt;meta-data
                 android:name=&quot;android.appwidget.provider&quot;
                 android:resource=&quot;@xml/appwidget_info_info&quot; /&gt;
         &lt;/receiver&gt;
         &lt;receiver android:name=&quot;.NewAppWidget&quot;&gt;
             &lt;intent-filter&gt;
                 &lt;action android:name=&quot;android.appwidget.action.APPWIDGET_UPDATE&quot; /&gt;
             &lt;/intent-filter&gt;
 
             &lt;meta-data
                 android:name=&quot;android.appwidget.provider&quot;
                 android:resource=&quot;@xml/new_app_widget_info&quot; /&gt;
         &lt;/receiver&gt;
     &lt;/application&gt;
 
 &lt;/manifest&gt;
</code></pre>
</li>
</ol>
<p>以上文件可在android studio中通过  New-&gt;Widget-&gt;AppWidget来自动生成</p>
<h4 id="AppWidget与客户端程序交互"><a href="#AppWidget与客户端程序交互" class="headerlink" title="AppWidget与客户端程序交互"></a>AppWidget与客户端程序交互</h4><ol>
<li><p>RemoteViews<br>因为appwidget运行的进程和我们创建的应用不在一个进程中，所以我们也就不能像平常引用控件那样来获得控件的实例。这个时候RemoteViews出场了。</p>
<pre><code> RemoteViews remoteViews  = new RemoteViews(context.getPackageName(),R.layout.appwidgetlayout);

 remoteViews.setOnClickPendingIntent(R.id.btnSend, pendingIntent);  //为小工具上的按钮绑定事件
</code></pre>
</li>
<li><p>pendingIntent</p>
<pre><code> //创建一个Intent对象
 Intent intent = new Intent();
 intent.setAction(broadCastString);
  
 //这一步相当于写信，说明这个信的作用到底是什么，在这里表示将发送一个广播
 PendingIntent pendingIntent = PendingIntent.getBroadcast(context, 0, intent, 0);
</code></pre>
</li>
<li><p>在onUpdate()方法中绑定事件</p>
<pre><code> /**
 * 到达指定的更新时间或者当用户向桌面添加AppWidget时被调用
 * */
 @Override
 public void onUpdate(Context context, AppWidgetManager appWidgetManager,
         int[] appWidgetIds)
         &#123;
          
                 //创建一个Intent对象
                 Intent intent = new Intent();
                 intent.setAction(broadCastString);
          
                 //设置pendingIntent的作用
                 PendingIntent pendingIntent = PendingIntent.getBroadcast(context, 0, intent, 0);
                 RemoteViews remoteViews  = new RemoteViews(context.getPackageName(),R.layout.appwidgetlayout);
          
                 //绑定事件
                 remoteViews.setOnClickPendingIntent(R.id.btnSend, pendingIntent);
                  
                 //更新Appwidget
                 appWidgetManager.updateAppWidget(appWidgetIds, remoteViews);
         &#125;  
</code></pre>
</li>
<li><p>在onReceive()方法中更新appwidget</p>
<pre><code>   /**
    * 接受广播事件
    * */
   @Override
   public void onReceive(Context context, Intent intent)
   &#123;
       if (intent.getAction().equals(broadCastString))
       &#123;               
           //只能通过远程对象来设置appwidget中的控件状态
           RemoteViews remoteViews  = new RemoteViews(context.getPackageName(),R.layout.appwidgetlayout);
  
          //通过远程对象将按钮的文字设置为”hihi”
           remoteViews.setTextViewText(R.id.btnSend, &quot;hihi&quot;);   
             
           //获得appwidget管理实例，用于管理appwidget以便进行更新操作
           AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);
            
           //相当于获得所有本程序创建的appwidget
           ComponentName componentName = new ComponentName(context,AppWidget.class);
            
           //更新appwidget
           appWidgetManager.updateAppWidget(componentName, remoteViews);
       &#125;else&#123;
           super.onReceive(context, intent);
       &#125;
       
   &#125;
</code></pre>
</li>
</ol>
<p>代码：<a href="/uploads/AppWidgetTest.zip">AppWidgetTest.zip</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>android_与其他APP互动</title>
    <url>/2016/06/22/android-%E4%B8%8E%E5%85%B6%E4%BB%96APP%E4%BA%92%E5%8A%A8/</url>
    <content><![CDATA[<h4 id="如何打开其他app"><a href="#如何打开其他app" class="headerlink" title="如何打开其他app"></a>如何打开其他app</h4><span id="more"></span>

<h5 id="创建隐含的Intent"><a href="#创建隐含的Intent" class="headerlink" title="创建隐含的Intent"></a>创建隐含的Intent</h5><h6 id="通过Uri创建Intent"><a href="#通过Uri创建Intent" class="headerlink" title="通过Uri创建Intent"></a>通过Uri创建Intent</h6><p>打电话  </p>
<pre><code>Uri number = Uri.parse(&quot;tel:5551234&quot;);
Intent callIntent = new Intent(Intent.ACTION_DIAL, number);
</code></pre>
<p>打开地图  </p>
<pre><code>// Map point based on address
Uri location = Uri.parse(&quot;geo:0,0?q=1600+Amphitheatre+Parkway,+Mountain+View,+California&quot;);
// Or map point based on latitude/longitude
// Uri location = Uri.parse(&quot;geo:37.422219,-122.08364?z=14&quot;); // z param is zoom level
Intent mapIntent = new Intent(Intent.ACTION_VIEW, location);
</code></pre>
<p>打开网页</p>
<pre><code>Uri webpage = Uri.parse(&quot;http://www.android.com&quot;);
Intent webIntent = new Intent(Intent.ACTION_VIEW, webpage);
</code></pre>
<h6 id="通过添加-extra-data-来制定action"><a href="#通过添加-extra-data-来制定action" class="headerlink" title="通过添加 extra data 来制定action"></a>通过添加 extra data 来制定action</h6><p>发送邮件</p>
<pre><code>Intent emailIntent = new Intent(Intent.ACTION_SEND);
// The intent does not have a URI, so declare the &quot;text/plain&quot; MIME type
emailIntent.setType(HTTP.PLAIN_TEXT_TYPE);
emailIntent.putExtra(Intent.EXTRA_EMAIL, new String[] &#123;&quot;jon@example.com&quot;&#125;); // recipients
emailIntent.putExtra(Intent.EXTRA_SUBJECT, &quot;Email subject&quot;);
emailIntent.putExtra(Intent.EXTRA_TEXT, &quot;Email message text&quot;);
emailIntent.putExtra(Intent.EXTRA_STREAM, Uri.parse(&quot;content://path/to/email/attachment&quot;));
// You can also attach multiple items by passing an ArrayList of Uris  
</code></pre>
<p>创建一个日历标签</p>
<pre><code>Intent calendarIntent = new Intent(Intent.ACTION_INSERT, Events.CONTENT_URI);
Calendar beginTime = Calendar.getInstance().set(2012, 0, 19, 7, 30);
Calendar endTime = Calendar.getInstance().set(2012, 0, 19, 10, 30);
calendarIntent.putExtra(CalendarContract.EXTRA_EVENT_BEGIN_TIME, beginTime.getTimeInMillis());
calendarIntent.putExtra(CalendarContract.EXTRA_EVENT_END_TIME, endTime.getTimeInMillis());
calendarIntent.putExtra(Events.TITLE, &quot;Ninja class&quot;);
calendarIntent.putExtra(Events.EVENT_LOCATION, &quot;Secret dojo&quot;);
</code></pre>
<h5 id="校验是否有app可以接收Intent"><a href="#校验是否有app可以接收Intent" class="headerlink" title="校验是否有app可以接收Intent"></a>校验是否有app可以接收Intent</h5><p>queryIntentActivities()</p>
<pre><code>PackageManager packageManager = getPackageManager();
List activities = packageManager.queryIntentActivities(intent,
        PackageManager.MATCH_DEFAULT_ONLY);
boolean isIntentSafe = activities.size() &gt; 0;
</code></pre>
<h5 id="用Intent-启动activity"><a href="#用Intent-启动activity" class="headerlink" title="用Intent 启动activity"></a>用Intent 启动activity</h5><p>startActivity(intent);</p>
<pre><code>// Build the intent
Uri location = Uri.parse(&quot;geo:0,0?q=1600+Amphitheatre+Parkway,+Mountain+View,+California&quot;);
Intent mapIntent = new Intent(Intent.ACTION_VIEW, location);

// Verify it resolves
PackageManager packageManager = getPackageManager();
List&lt;ResolveInfo&gt; activities = packageManager.queryIntentActivities(mapIntent, 0);
boolean isIntentSafe = activities.size() &gt; 0;

// Start an activity if it&#39;s safe
if (isIntentSafe) &#123;
    startActivity(mapIntent);
&#125;
</code></pre>
<h5 id="创建一个app选择器"><a href="#创建一个app选择器" class="headerlink" title="创建一个app选择器"></a>创建一个app选择器</h5><p>通过用createChooser()创建Intent 然后调用 startActivity</p>
<pre><code>Intent intent = new Intent(Intent.ACTION_SEND);
...

// Always use string resources for UI text.
// This says something like &quot;Share this photo with&quot;
String title = getResources().getString(R.string.chooser_title);
// Create intent to show chooser
Intent chooser = Intent.createChooser(intent, title);

// Verify the intent will resolve to at least one activity
if (intent.resolveActivity(getPackageManager()) != null) &#123;
    startActivity(chooser);
&#125;
</code></pre>
<h4 id="从另外一个activity获得一个结果"><a href="#从另外一个activity获得一个结果" class="headerlink" title="从另外一个activity获得一个结果"></a>从另外一个activity获得一个结果</h4><h5 id="启动一个activity"><a href="#启动一个activity" class="headerlink" title="启动一个activity"></a>启动一个activity</h5><p> startActivityForResult() </p>
<pre><code>static final int PICK_CONTACT_REQUEST = 1;  // The request code
...
private void pickContact() &#123;
    Intent pickContactIntent = new Intent(Intent.ACTION_PICK, Uri.parse(&quot;content://contacts&quot;));
    pickContactIntent.setType(Phone.CONTENT_TYPE); // Show user only contacts w/ phone numbers
    startActivityForResult(pickContactIntent, PICK_CONTACT_REQUEST);
&#125;
</code></pre>
<h5 id="接收结果"><a href="#接收结果" class="headerlink" title="接收结果"></a>接收结果</h5><pre><code>@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123;
    // Check which request we&#39;re responding to
    if (requestCode == PICK_CONTACT_REQUEST) &#123;
        // Make sure the request was successful
        if (resultCode == RESULT_OK) &#123;
            // The user picked a contact.
            // The Intent&#39;s data Uri identifies which contact was selected.

            // Do something with the contact here (bigger example below)
        &#125;
    &#125;
&#125;
</code></pre>
<p>获取联系人数据</p>
<pre><code>@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123;
    // Check which request it is that we&#39;re responding to
    if (requestCode == PICK_CONTACT_REQUEST) &#123;
        // Make sure the request was successful
        if (resultCode == RESULT_OK) &#123;
            // Get the URI that points to the selected contact
            Uri contactUri = data.getData();
            // We only need the NUMBER column, because there will be only one row in the result
            String[] projection = &#123;Phone.NUMBER&#125;;

            // Perform the query on the contact to get the NUMBER column
            // We don&#39;t need a selection or sort order (there&#39;s only one result for the given URI)
            // CAUTION: The query() method should be called from a separate thread to avoid blocking
            // your app&#39;s UI thread. (For simplicity of the sample, this code doesn&#39;t do that.)
            // Consider using CursorLoader to perform the query.
            Cursor cursor = getContentResolver()
                    .query(contactUri, projection, null, null, null);
            cursor.moveToFirst();

            // Retrieve the phone number from the NUMBER column
            int column = cursor.getColumnIndex(Phone.NUMBER);
            String number = cursor.getString(column);

            // Do something with the phone number...
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="允许其他app启动你的activity"><a href="#允许其他app启动你的activity" class="headerlink" title="允许其他app启动你的activity"></a>允许其他app启动你的activity</h4><h5 id="添加Intent过滤器"><a href="#添加Intent过滤器" class="headerlink" title="添加Intent过滤器"></a>添加Intent过滤器</h5><pre><code>&lt;activity android:name=&quot;ShareActivity&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.SEND&quot;/&gt;
        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;
        &lt;data android:mimeType=&quot;text/plain&quot;/&gt;
        &lt;data android:mimeType=&quot;image/*&quot;/&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;
</code></pre>
<p>  or</p>
<pre><code>&lt;activity android:name=&quot;ShareActivity&quot;&gt;
    &lt;!-- filter for sending text; accepts SENDTO action with sms URI schemes --&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.SENDTO&quot;/&gt;
        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;
        &lt;data android:scheme=&quot;sms&quot; /&gt;
        &lt;data android:scheme=&quot;smsto&quot; /&gt;
    &lt;/intent-filter&gt;
    &lt;!-- filter for sending text or images; accepts SEND action and text or image data --&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.SEND&quot;/&gt;
        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;
        &lt;data android:mimeType=&quot;image/*&quot;/&gt;
        &lt;data android:mimeType=&quot;text/plain&quot;/&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;
</code></pre>
<h5 id="在activity中处理Intent"><a href="#在activity中处理Intent" class="headerlink" title="在activity中处理Intent"></a>在activity中处理Intent</h5><p> getIntent()</p>
<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) &#123;
    super.onCreate(savedInstanceState);

    setContentView(R.layout.main);

    // Get the intent that started this activity
    Intent intent = getIntent();
    Uri data = intent.getData();

    // Figure out what to do based on the intent type
    if (intent.getType().indexOf(&quot;image/&quot;) != -1) &#123;
        // Handle intents with image data ...
    &#125; else if (intent.getType().equals(&quot;text/plain&quot;)) &#123;
        // Handle intents with text ...
    &#125;
&#125; 
</code></pre>
<h5 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h5><pre><code>// Create intent to deliver some kind of result data
Intent result = new Intent(&quot;com.example.RESULT_ACTION&quot;, Uri.parse(&quot;content://result_uri&quot;));
setResult(Activity.RESULT_OK, result);
finish();
</code></pre>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>android_拍照</title>
    <url>/2016/07/14/android-%E6%8B%8D%E7%85%A7/</url>
    <content><![CDATA[<h4 id="拍照"><a href="#拍照" class="headerlink" title="拍照"></a>拍照</h4><h5 id="请求相机权限"><a href="#请求相机权限" class="headerlink" title="请求相机权限"></a>请求相机权限</h5><p>如果拍照是app的一个必要的功能，可以在Google Play上设置为只对有相机的设备可见。</p>
<pre><code>&lt;manifest ... &gt;
    &lt;uses-feature android:name=&quot;android.hardware.camera&quot;
                  android:required=&quot;true&quot; /&gt;
    ...
&lt;/manifest&gt;
</code></pre>
<p>如果相机功能不是必须的，则android:required=”false”,然后调用<code>hasSystemFeature(PackageManager.FEATURE_CAMERA)</code>来判断相机是否可用</p>
<h5 id="获得照片通过相机app"><a href="#获得照片通过相机app" class="headerlink" title="获得照片通过相机app"></a>获得照片通过相机app</h5><pre><code>static final int REQUEST_IMAGE_CAPTURE = 1;

private void dispatchTakePictureIntent() &#123;
    Intent takePictureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
    if (takePictureIntent.resolveActivity(getPackageManager()) != null) &#123;
        startActivityForResult(takePictureIntent, REQUEST_IMAGE_CAPTURE);
    &#125;
&#125;
</code></pre>
<p>startActivityForResult()方法被resolveActivity()（该方法返回能处理Intent的第一个Activity组件）方法保护了起来</p>
<h5 id="获得缩略图"><a href="#获得缩略图" class="headerlink" title="获得缩略图"></a>获得缩略图</h5><pre><code>@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123;
    if (requestCode == REQUEST_IMAGE_CAPTURE &amp;&amp; resultCode == RESULT_OK) &#123;
        Bundle extras = data.getExtras();
        Bitmap imageBitmap = (Bitmap) extras.get(&quot;data&quot;);
        mImageView.setImageBitmap(imageBitmap);
    &#125;
&#125;
</code></pre>
<h5 id="保存全尺寸照片"><a href="#保存全尺寸照片" class="headerlink" title="保存全尺寸照片"></a>保存全尺寸照片</h5><pre><code>&lt;manifest ...&gt;
    &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;
    ...
&lt;/manifest&gt;  
</code></pre>
<hr>
<pre><code>String mCurrentPhotoPath;

private File createImageFile() throws IOException &#123;
    // Create an image file name
    String timeStamp = new SimpleDateFormat(&quot;yyyyMMdd_HHmmss&quot;).format(new Date());
    String imageFileName = &quot;JPEG_&quot; + timeStamp + &quot;_&quot;;
    File storageDir = getExternalFilesDir(Environment.DIRECTORY_PICTURES);
    File image = File.createTempFile(
        imageFileName,  /* prefix */
        &quot;.jpg&quot;,         /* suffix */
        storageDir      /* directory */
    );

    // Save a file: path for use with ACTION_VIEW intents
    mCurrentPhotoPath = &quot;file:&quot; + image.getAbsolutePath();
    return image;
&#125;
</code></pre>
<hr>
<pre><code>static final int REQUEST_TAKE_PHOTO = 1;

private void dispatchTakePictureIntent() &#123;
    Intent takePictureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
    // Ensure that there&#39;s a camera activity to handle the intent
    if (takePictureIntent.resolveActivity(getPackageManager()) != null) &#123;
        // Create the File where the photo should go
        File photoFile = null;
        try &#123;
            photoFile = createImageFile();
        &#125; catch (IOException ex) &#123;
            // Error occurred while creating the File
            ...
        &#125;
        // Continue only if the File was successfully created
        if (photoFile != null) &#123;
            Uri photoURI = FileProvider.getUriForFile(this,
                                                  &quot;com.example.android.fileprovider&quot;,
                                                  photoFile);
            takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT, photoURI);
            startActivityForResult(takePictureIntent, REQUEST_TAKE_PHOTO);
        &#125;
    &#125;
&#125;
</code></pre>
<h5 id="将图片添加到画廊"><a href="#将图片添加到画廊" class="headerlink" title="将图片添加到画廊"></a>将图片添加到画廊</h5><h5 id="解码缩放的图片"><a href="#解码缩放的图片" class="headerlink" title="解码缩放的图片"></a>解码缩放的图片</h5><h4 id="录像"><a href="#录像" class="headerlink" title="录像"></a>录像</h4><h4 id="控制摄像头"><a href="#控制摄像头" class="headerlink" title="控制摄像头"></a>控制摄像头</h4>]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>android_支持各种屏幕尺寸</title>
    <url>/2016/07/02/android-%E6%94%AF%E6%8C%81%E5%90%84%E7%A7%8D%E5%B1%8F%E5%B9%95%E5%B0%BA%E5%AF%B8/</url>
    <content><![CDATA[<h4 id="使用”wrap-content”和”match-parent”"><a href="#使用”wrap-content”和”match-parent”" class="headerlink" title="使用”wrap_content”和”match_parent”"></a>使用”wrap_content”和”match_parent”</h4><p>如果使用 “wrap_content” 和 “match_parent” 尺寸值而不是硬编码的尺寸，您的视图就会相应地仅使用自身所需的空间或展开以填满可用空间。</p>
<span id="more"></span>

<p>例如：</p>
<pre><code>&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
android:orientation=&quot;vertical&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot;&gt;
    &lt;LinearLayout android:layout_width=&quot;match_parent&quot; 
                  android:id=&quot;@+id/linearLayout1&quot;  
                  android:gravity=&quot;center&quot;
                  android:layout_height=&quot;50dp&quot;&gt;
        &lt;ImageView android:id=&quot;@+id/imageView1&quot; 
                   android:layout_height=&quot;wrap_content&quot;
                   android:layout_width=&quot;wrap_content&quot;
                   android:src=&quot;@drawable/logo&quot;
                   android:paddingRight=&quot;30dp&quot;
                   android:layout_gravity=&quot;left&quot;
                   android:layout_weight=&quot;0&quot; /&gt;
        &lt;View android:layout_height=&quot;wrap_content&quot; 
              android:id=&quot;@+id/view1&quot;
              android:layout_width=&quot;wrap_content&quot;
              android:layout_weight=&quot;1&quot; /&gt;
        &lt;Button android:id=&quot;@+id/categorybutton&quot;
                android:background=&quot;@drawable/button_bg&quot;
                android:layout_height=&quot;match_parent&quot;
                android:layout_weight=&quot;0&quot;
                android:layout_width=&quot;120dp&quot;
                style=&quot;@style/CategoryButtonStyle&quot;/&gt;
    &lt;/LinearLayout&gt;

    &lt;fragment android:id=&quot;@+id/headlines&quot; 
              android:layout_height=&quot;fill_parent&quot;
              android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot;
              android:layout_width=&quot;match_parent&quot; /&gt;
&lt;/LinearLayout&gt;
</code></pre>
<h4 id="使用相对布局"><a href="#使用相对布局" class="headerlink" title="使用相对布局"></a>使用相对布局</h4><p>RelativeLayout        </p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&gt;
    &lt;TextView
        android:id=&quot;@+id/label&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;Type here:&quot;/&gt;
    &lt;EditText
        android:id=&quot;@+id/entry&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_below=&quot;@id/label&quot;/&gt;
    &lt;Button
        android:id=&quot;@+id/ok&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_below=&quot;@id/entry&quot;
        android:layout_alignParentRight=&quot;true&quot;
        android:layout_marginLeft=&quot;10dp&quot;
        android:text=&quot;OK&quot; /&gt;
    &lt;Button
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_toLeftOf=&quot;@id/ok&quot;
        android:layout_alignTop=&quot;@id/ok&quot;
        android:text=&quot;Cancel&quot; /&gt;
&lt;/RelativeLayout&gt;
</code></pre>
<h4 id="使用尺寸限定符"><a href="#使用尺寸限定符" class="headerlink" title="使用尺寸限定符"></a>使用尺寸限定符</h4><p>在较大的屏幕上实施’双面板’模式,小屏幕上显示’单面板’模式<br>res/layout/main.xml，单面板（默认）布局：</p>
<pre><code>&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
android:orientation=&quot;vertical&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot;&gt;

    &lt;fragment android:id=&quot;@+id/headlines&quot;
              android:layout_height=&quot;fill_parent&quot;
              android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot;
              android:layout_width=&quot;match_parent&quot; /&gt;
&lt;/LinearLayout&gt;
</code></pre>
<p>res/layout-large/main.xml，双面板布局：</p>
<pre><code>&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
android:layout_width=&quot;fill_parent&quot;
android:layout_height=&quot;fill_parent&quot;
android:orientation=&quot;horizontal&quot;&gt;
    &lt;fragment android:id=&quot;@+id/headlines&quot;
              android:layout_height=&quot;fill_parent&quot;
              android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot;
              android:layout_width=&quot;400dp&quot;
              android:layout_marginRight=&quot;10dp&quot;/&gt;
    &lt;fragment android:id=&quot;@+id/article&quot;
              android:layout_height=&quot;fill_parent&quot;
              android:name=&quot;com.example.android.newsreader.ArticleFragment&quot;
              android:layout_width=&quot;fill_parent&quot; /&gt;
&lt;/LinearLayout&gt;
</code></pre>
<h4 id="使用最小宽度限定符"><a href="#使用最小宽度限定符" class="headerlink" title="使用最小宽度限定符"></a>使用最小宽度限定符</h4><p>对于最小宽度大于等于 600 dp 的设备，系统会选择 layout-sw600dp/main.xml（双面板）布局，否则系统就会选择 layout/main.xml（单面板）布局<br>res/layout/main.xml，单面板（默认）布局：</p>
<pre><code>&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
android:orientation=&quot;vertical&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot;&gt;

    &lt;fragment android:id=&quot;@+id/headlines&quot;
              android:layout_height=&quot;fill_parent&quot;
              android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot;
              android:layout_width=&quot;match_parent&quot; /&gt;
&lt;/LinearLayout&gt;
</code></pre>
<p>res/layout-sw600dp/main.xml，双面板布局：</p>
<pre><code>&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
android:layout_width=&quot;fill_parent&quot;
android:layout_height=&quot;fill_parent&quot;
android:orientation=&quot;horizontal&quot;&gt;
    &lt;fragment android:id=&quot;@+id/headlines&quot;
              android:layout_height=&quot;fill_parent&quot;
              android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot;
              android:layout_width=&quot;400dp&quot;
              android:layout_marginRight=&quot;10dp&quot;/&gt;
    &lt;fragment android:id=&quot;@+id/article&quot;
              android:layout_height=&quot;fill_parent&quot;
              android:name=&quot;com.example.android.newsreader.ArticleFragment&quot;
              android:layout_width=&quot;fill_parent&quot; /&gt;
&lt;/LinearLayout&gt;
</code></pre>
<p>但 Android 版本低于 3.2 的设备不支持此技术，原因是这些设备无法将 sw600dp 识别为尺寸限定符，因此您仍需使用 large 限定符。这样一来，就会有一个名称为 res/layout-large/main.xml 的文件（与 res/layout-sw600dp/main.xml 一样）。下一教程中了解到避免此类布局文件出现重复的技术</p>
<h4 id="使用布局别名"><a href="#使用布局别名" class="headerlink" title="使用布局别名"></a>使用布局别名</h4><ul>
<li>res/layout/main.xml: 单面板布局</li>
<li>res/layout-large: 多面板布局</li>
<li>res/layout-sw600dp: 多面板布局</li>
</ul>
<p>后两个文件是相同的，因为其中一个用于和 Android 3.2 设备匹配，而另一个则是为使用较低版本 Android 的平板电脑和电视准备的。<br>为避免文件重复出现，可以使用别名。例如：</p>
<ul>
<li>res/layout/main.xml，单面板布局</li>
<li>res/layout/main_twopanes.xml，双面板布局</li>
</ul>
<p>然后添加两个文件<br>res/values-large/layout.xml:</p>
<pre><code>&lt;resources&gt;
    &lt;item name=&quot;main&quot; type=&quot;layout&quot;&gt;@layout/main_twopanes&lt;/item&gt;
&lt;/resources&gt;
</code></pre>
<p>res/values-sw600dp/layout.xml:</p>
<pre><code>&lt;resources&gt;
    &lt;item name=&quot;main&quot; type=&quot;layout&quot;&gt;@layout/main_twopanes&lt;/item&gt;
&lt;/resources&gt;
</code></pre>
<h4 id="使用屏幕方向限定符"><a href="#使用屏幕方向限定符" class="headerlink" title="使用屏幕方向限定符"></a>使用屏幕方向限定符</h4><p>某些布局会同时支持横向模式和纵向模式，可以通过调整优化其中大部分布局的效果。    </p>
<ul>
<li>小屏幕，纵向：单面板，带徽标</li>
<li>小屏幕，横向：单面板，带徽标</li>
<li>7 英寸平板电脑，纵向：单面板，带操作栏</li>
<li>7 英寸平板电脑，横向：双面板，宽，带操作栏</li>
<li>10 英寸平板电脑，纵向：双面板，窄，带操作栏</li>
<li>10 英寸平板电脑，横向：双面板，宽，带操作栏</li>
<li>电视，横向：双面板，宽，带操作栏</li>
</ul>
<p>res/layout/onepane.xml:<br>    <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent"></p>
<pre><code>    &lt;fragment android:id=&quot;@+id/headlines&quot;
              android:layout_height=&quot;fill_parent&quot;
              android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot;
              android:layout_width=&quot;match_parent&quot; /&gt;
&lt;/LinearLayout&gt;
</code></pre>
<p>res/layout/onepane_with_bar.xml:</p>
<pre><code>&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
android:orientation=&quot;vertical&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot;&gt;
    &lt;LinearLayout android:layout_width=&quot;match_parent&quot; 
                  android:id=&quot;@+id/linearLayout1&quot;  
                  android:gravity=&quot;center&quot;
                  android:layout_height=&quot;50dp&quot;&gt;
        &lt;ImageView android:id=&quot;@+id/imageView1&quot; 
                   android:layout_height=&quot;wrap_content&quot;
                   android:layout_width=&quot;wrap_content&quot;
                   android:src=&quot;@drawable/logo&quot;
                   android:paddingRight=&quot;30dp&quot;
                   android:layout_gravity=&quot;left&quot;
                   android:layout_weight=&quot;0&quot; /&gt;
        &lt;View android:layout_height=&quot;wrap_content&quot; 
              android:id=&quot;@+id/view1&quot;
              android:layout_width=&quot;wrap_content&quot;
              android:layout_weight=&quot;1&quot; /&gt;
        &lt;Button android:id=&quot;@+id/categorybutton&quot;
                android:background=&quot;@drawable/button_bg&quot;
                android:layout_height=&quot;match_parent&quot;
                android:layout_weight=&quot;0&quot;
                android:layout_width=&quot;120dp&quot;
                style=&quot;@style/CategoryButtonStyle&quot;/&gt;
    &lt;/LinearLayout&gt;

    &lt;fragment android:id=&quot;@+id/headlines&quot; 
              android:layout_height=&quot;fill_parent&quot;
              android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot;
              android:layout_width=&quot;match_parent&quot; /&gt;
&lt;/LinearLayout&gt;
</code></pre>
<p>res/layout/twopanes.xml:</p>
<pre><code>&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
android:layout_width=&quot;fill_parent&quot;
android:layout_height=&quot;fill_parent&quot;
android:orientation=&quot;horizontal&quot;&gt;
    &lt;fragment android:id=&quot;@+id/headlines&quot;
              android:layout_height=&quot;fill_parent&quot;
              android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot;
              android:layout_width=&quot;400dp&quot;
              android:layout_marginRight=&quot;10dp&quot;/&gt;
    &lt;fragment android:id=&quot;@+id/article&quot;
              android:layout_height=&quot;fill_parent&quot;
              android:name=&quot;com.example.android.newsreader.ArticleFragment&quot;
              android:layout_width=&quot;fill_parent&quot; /&gt;
&lt;/LinearLayout&gt;
</code></pre>
<p>res/layout/twopanes_narrow.xml:</p>
<pre><code>&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
android:layout_width=&quot;fill_parent&quot;
android:layout_height=&quot;fill_parent&quot;
android:orientation=&quot;horizontal&quot;&gt;
    &lt;fragment android:id=&quot;@+id/headlines&quot;
              android:layout_height=&quot;fill_parent&quot;
              android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot;
              android:layout_width=&quot;200dp&quot;
              android:layout_marginRight=&quot;10dp&quot;/&gt;
    &lt;fragment android:id=&quot;@+id/article&quot;
              android:layout_height=&quot;fill_parent&quot;
              android:name=&quot;com.example.android.newsreader.ArticleFragment&quot;
              android:layout_width=&quot;fill_parent&quot; /&gt;
&lt;/LinearLayout&gt;
</code></pre>
<p>定义好所有可能的布局，那就只需使用配置限定符将正确的布局映射到各种配置即可<br>res/values/layouts.xml:</p>
<pre><code>&lt;resources&gt;
    &lt;item name=&quot;main_layout&quot; type=&quot;layout&quot;&gt;@layout/onepane_with_bar&lt;/item&gt;
    &lt;bool name=&quot;has_two_panes&quot;&gt;false&lt;/bool&gt;
&lt;/resources&gt;
</code></pre>
<p>res/values-sw600dp-land/layouts.xml:<br>    <resources><br>        <item name="main_layout" type="layout">@layout/twopanes</item><br>        <bool name="has_two_panes">true</bool><br>    </resources><br>res/values-sw600dp-port/layouts.xml:<br>    <resources><br>        <item name="main_layout" type="layout">@layout/twopanes</item><br>        <bool name="has_two_panes">true</bool><br>    </resources><br>res/values-large-port/layouts.xml:</p>
<pre><code>&lt;resources&gt;
    &lt;item name=&quot;main_layout&quot; type=&quot;layout&quot;&gt;@layout/twopanes_narrow&lt;/item&gt;
    &lt;bool name=&quot;has_two_panes&quot;&gt;true&lt;/bool&gt;
&lt;/resources&gt;
</code></pre>
<h4 id="使用自动拉伸位图"><a href="#使用自动拉伸位图" class="headerlink" title="使用自动拉伸位图"></a>使用自动拉伸位图</h4><p>通过 SDK 的 draw9patch 实用工具（位于 tools/ 目录中）处理图片</p>
<p>文档参考：<a href="https://developer.android.com/training/multiscreen/screensizes.html#TaskUse9Patch">https://developer.android.com/training/multiscreen/screensizes.html#TaskUse9Patch</a></p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>android_文件共享</title>
    <url>/2016/06/26/android-%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/</url>
    <content><![CDATA[<h4 id="配置文件共享"><a href="#配置文件共享" class="headerlink" title="配置文件共享"></a>配置文件共享</h4><span id="more"></span>

<h5 id="定义FileProvider"><a href="#定义FileProvider" class="headerlink" title="定义FileProvider"></a>定义FileProvider</h5><!--more-->

<pre><code>&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.example.myapp&quot;&gt;
    &lt;application
        ...&gt;
        &lt;provider
            android:name=&quot;android.support.v4.content.FileProvider&quot;
            android:authorities=&quot;com.example.myapp.fileprovider&quot;
            android:grantUriPermissions=&quot;true&quot;
            android:exported=&quot;false&quot;&gt;
            &lt;meta-data
                android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot;
                android:resource=&quot;@xml/filepaths&quot; /&gt;
        &lt;/provider&gt;
        ...
    &lt;/application&gt;
&lt;/manifest&gt;
</code></pre>
<h5 id="指定共享目录"><a href="#指定共享目录" class="headerlink" title="指定共享目录"></a>指定共享目录</h5><p>在res/xml/filepaths.xml中定义</p>
<pre><code>&lt;paths&gt;
    &lt;files-path path=&quot;images/&quot; name=&quot;myimages&quot; /&gt;
&lt;/paths&gt;
</code></pre>
<p>如果你请求default_image.jpg</p>
<pre><code>content://com.example.myapp.fileprovider/myimages/default_image.jpg
</code></pre>
<h4 id="共享文件"><a href="#共享文件" class="headerlink" title="共享文件"></a>共享文件</h4><h5 id="在配置中定义文件选择activity"><a href="#在配置中定义文件选择activity" class="headerlink" title="在配置中定义文件选择activity"></a>在配置中定义文件选择activity</h5><pre><code>&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
    ...
        &lt;application&gt;
        ...
            &lt;activity
                android:name=&quot;.FileSelectActivity&quot;
                android:label=&quot;@File Selector&quot; &gt;
                &lt;intent-filter&gt;
                    &lt;action
                        android:name=&quot;android.intent.action.PICK&quot;/&gt;
                    &lt;category
                        android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;
                    &lt;category
                        android:name=&quot;android.intent.category.OPENABLE&quot;/&gt;
                    &lt;data android:mimeType=&quot;text/plain&quot;/&gt;
                    &lt;data android:mimeType=&quot;image/*&quot;/&gt;
                &lt;/intent-filter&gt;
            &lt;/activity&gt;
</code></pre>
<h5 id="在代码中定义文件选择activity"><a href="#在代码中定义文件选择activity" class="headerlink" title="在代码中定义文件选择activity"></a>在代码中定义文件选择activity</h5><pre><code>public class MainActivity extends Activity &#123;
    // The path to the root of this app&#39;s internal storage
    private File mPrivateRootDir;
    // The path to the &quot;images&quot; subdirectory
    private File mImagesDir;
    // Array of files in the images subdirectory
    File[] mImageFiles;
    // Array of filenames corresponding to mImageFiles
    String[] mImageFilenames;
    // Initialize the Activity
    @Override
    protected void onCreate(Bundle savedInstanceState) &#123;
        ...
        // Set up an Intent to send back to apps that request a file
        mResultIntent =
                new Intent(&quot;com.example.myapp.ACTION_RETURN_FILE&quot;);
        // Get the files/ subdirectory of internal storage
        mPrivateRootDir = getFilesDir();
        // Get the files/images subdirectory;
        mImagesDir = new File(mPrivateRootDir, &quot;images&quot;);
        // Get the files in the images subdirectory
        mImageFiles = mImagesDir.listFiles();
        // Set the Activity&#39;s result to null to begin with
        setResult(Activity.RESULT_CANCELED, null);
        /*
         * Display the file names in the ListView mFileListView.
         * Back the ListView with the array mImageFilenames, which
         * you can create by iterating through mImageFiles and
         * calling File.getAbsolutePath() for each File
         */
         ...
    &#125;
    ...
&#125;
</code></pre>
<h5 id="指定文件选择后的响应"><a href="#指定文件选择后的响应" class="headerlink" title="指定文件选择后的响应"></a>指定文件选择后的响应</h5><pre><code>protected void onCreate(Bundle savedInstanceState) &#123;
    ...
    // Define a listener that responds to clicks on a file in the ListView
    mFileListView.setOnItemClickListener(
            new AdapterView.OnItemClickListener() &#123;
        @Override
        /*
         * When a filename in the ListView is clicked, get its
         * content URI and send it to the requesting app
         */
        public void onItemClick(AdapterView&lt;?&gt; adapterView,
                View view,
                int position,
                long rowId) &#123;
            /*
             * Get a File for the selected file name.
             * Assume that the file names are in the
             * mImageFilename array.
             */
            File requestFile = new File(mImageFilename[position]);
            /*
             * Most file-related method calls need to be in
             * try-catch blocks.
             */
            // Use the FileProvider to get a content URI
            try &#123;
                fileUri = FileProvider.getUriForFile(
                        MainActivity.this,
                        &quot;com.example.myapp.fileprovider&quot;,
                        requestFile);
            &#125; catch (IllegalArgumentException e) &#123;
                Log.e(&quot;File Selector&quot;,
                      &quot;The selected file can&#39;t be shared: &quot; +
                      clickedFilename);
            &#125;
            ...
        &#125;
    &#125;);
    ...
&#125;
</code></pre>
<h5 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h5><pre><code>protected void onCreate(Bundle savedInstanceState) &#123;
    ...
    // Define a listener that responds to clicks in the ListView
    mFileListView.setOnItemClickListener(
            new AdapterView.OnItemClickListener() &#123;
        @Override
        public void onItemClick(AdapterView&lt;?&gt; adapterView,
                View view,
                int position,
                long rowId) &#123;
            ...
            if (fileUri != null) &#123;
                // Grant temporary read permission to the content URI
                mResultIntent.addFlags(
                    Intent.FLAG_GRANT_READ_URI_PERMISSION);
            &#125;
            ...
         &#125;
         ...
    &#125;);
...
&#125;
</code></pre>
<h5 id="共享文件给请求的app"><a href="#共享文件给请求的app" class="headerlink" title="共享文件给请求的app"></a>共享文件给请求的app</h5><pre><code>protected void onCreate(Bundle savedInstanceState) &#123;
    ...
    // Define a listener that responds to clicks on a file in the ListView
    mFileListView.setOnItemClickListener(
            new AdapterView.OnItemClickListener() &#123;
        @Override
        public void onItemClick(AdapterView&lt;?&gt; adapterView,
                View view,
                int position,
                long rowId) &#123;
            ...
            if (fileUri != null) &#123;
                ...
                // Put the Uri and MIME type in the result Intent
                mResultIntent.setDataAndType(
                        fileUri,
                        getContentResolver().getType(fileUri));
                // Set the result
                MainActivity.this.setResult(Activity.RESULT_OK,
                        mResultIntent);
                &#125; else &#123;
                    mResultIntent.setDataAndType(null, &quot;&quot;);
                    MainActivity.this.setResult(RESULT_CANCELED,
                            mResultIntent);
                &#125;
            &#125;
    &#125;);
</code></pre>
<p>一旦用户选择好文件以后，提供一个按钮返回app,点击调用finish（）<br>    public void onDoneClick(View v) {<br>        // Associate a method with the Done button<br>        finish();<br>    }</p>
<h4 id="请求共享的文件"><a href="#请求共享的文件" class="headerlink" title="请求共享的文件"></a>请求共享的文件</h4><h5 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h5><pre><code>public class MainActivity extends Activity &#123;
    private Intent mRequestFileIntent;
    private ParcelFileDescriptor mInputPFD;
    ...
    @Override
    protected void onCreate(Bundle savedInstanceState) &#123;
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        mRequestFileIntent = new Intent(Intent.ACTION_PICK);
        mRequestFileIntent.setType(&quot;image/jpg&quot;);
        ...
    &#125;
    ...
    protected void requestFile() &#123;
        /**
         * When the user requests a file, send an Intent to the
         * server app.
         * files.
         */
            startActivityForResult(mRequestFileIntent, 0);
        ...
    &#125;
    ...
&#125;
</code></pre>
<h5 id="接受文件"><a href="#接受文件" class="headerlink" title="接受文件"></a>接受文件</h5><pre><code> /*
 * When the Activity of the app that hosts files sets a result and calls
 * finish(), this method is invoked. The returned Intent contains the
 * content URI of a selected file. The result code indicates if the
 * selection worked or not.
 */
@Override
public void onActivityResult(int requestCode, int resultCode,
        Intent returnIntent) &#123;
    // If the selection didn&#39;t work
    if (resultCode != RESULT_OK) &#123;
        // Exit without doing anything else
        return;
    &#125; else &#123;
        // Get the file&#39;s content URI from the incoming Intent
        Uri returnUri = returnIntent.getData();
        /*
         * Try to open the file for &quot;read&quot; access using the
         * returned URI. If the file isn&#39;t found, write to the
         * error log and return.
         */
        try &#123;
            /*
             * Get the content resolver instance for this context, and use it
             * to get a ParcelFileDescriptor for the file.
             */
            mInputPFD = getContentResolver().openFileDescriptor(returnUri, &quot;r&quot;);
        &#125; catch (FileNotFoundException e) &#123;
            e.printStackTrace();
            Log.e(&quot;MainActivity&quot;, &quot;File not found.&quot;);
            return;
        &#125;
        // Get a regular file descriptor for the file
        FileDescriptor fd = mInputPFD.getFileDescriptor();
        ...
    &#125;
&#125;
</code></pre>
<h4 id="取出文件信息"><a href="#取出文件信息" class="headerlink" title="取出文件信息"></a>取出文件信息</h4><h5 id="读取文件的MIME-Type"><a href="#读取文件的MIME-Type" class="headerlink" title="读取文件的MIME Type"></a>读取文件的MIME Type</h5><pre><code>...
/*
 * Get the file&#39;s content URI from the incoming Intent, then
 * get the file&#39;s MIME type
 */
Uri returnUri = returnIntent.getData();
String mimeType = getContentResolver().getType(returnUri);
</code></pre>
<h5 id="读取文件的名字和大小"><a href="#读取文件的名字和大小" class="headerlink" title="读取文件的名字和大小"></a>读取文件的名字和大小</h5><pre><code>...
/*
 * Get the file&#39;s content URI from the incoming Intent,
 * then query the server app to get the file&#39;s display name
 * and size.
 */
Uri returnUri = returnIntent.getData();
Cursor returnCursor =
        getContentResolver().query(returnUri, null, null, null, null);
/*
 * Get the column indexes of the data in the Cursor,
 * move to the first row in the Cursor, get the data,
 * and display it.
 */
int nameIndex = returnCursor.getColumnIndex(OpenableColumns.DISPLAY_NAME);
int sizeIndex = returnCursor.getColumnIndex(OpenableColumns.SIZE);
returnCursor.moveToFirst();
TextView nameView = (TextView) findViewById(R.id.filename_text);
TextView sizeView = (TextView) findViewById(R.id.filesize_text);
nameView.setText(returnCursor.getString(nameIndex));
sizeView.setText(Long.toString(returnCursor.getLong(sizeIndex)));
...
</code></pre>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>android_简单数据的分享</title>
    <url>/2016/06/23/android-%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<h4 id="向其他app发送简单数据"><a href="#向其他app发送简单数据" class="headerlink" title="向其他app发送简单数据"></a>向其他app发送简单数据</h4><span id="more"></span>

<h5 id="发送文本内容"><a href="#发送文本内容" class="headerlink" title="发送文本内容"></a>发送文本内容</h5><pre><code>Intent sendIntent = new Intent();
sendIntent.setAction(Intent.ACTION_SEND);
sendIntent.putExtra(Intent.EXTRA_TEXT, &quot;This is my text to send.&quot;);
sendIntent.setType(&quot;text/plain&quot;);
startActivity(sendIntent);
</code></pre>
<p>Intent.createChooser()</p>
<pre><code>Intent sendIntent = new Intent();
sendIntent.setAction(Intent.ACTION_SEND);
sendIntent.putExtra(Intent.EXTRA_TEXT, &quot;This is my text to send.&quot;);
sendIntent.setType(&quot;text/plain&quot;);
startActivity(Intent.createChooser(sendIntent, getResources().getText(R.string.send_to)));
</code></pre>
<h5 id="发送二进制内容"><a href="#发送二进制内容" class="headerlink" title="发送二进制内容"></a>发送二进制内容</h5><pre><code>Intent shareIntent = new Intent();
shareIntent.setAction(Intent.ACTION_SEND);
shareIntent.putExtra(Intent.EXTRA_STREAM, uriToImage);
shareIntent.setType(&quot;image/jpeg&quot;);
startActivity(Intent.createChooser(shareIntent, getResources().getText(R.string.send_to)));
</code></pre>
<h5 id="发送多个内容"><a href="#发送多个内容" class="headerlink" title="发送多个内容"></a>发送多个内容</h5><p>ACTION_SEND_MULTIPLE  </p>
<pre><code>ArrayList&lt;Uri&gt; imageUris = new ArrayList&lt;Uri&gt;();
imageUris.add(imageUri1); // Add your image URIs here
imageUris.add(imageUri2);

Intent shareIntent = new Intent();
shareIntent.setAction(Intent.ACTION_SEND_MULTIPLE);
shareIntent.putParcelableArrayListExtra(Intent.EXTRA_STREAM, imageUris);
shareIntent.setType(&quot;image/*&quot;);
startActivity(Intent.createChooser(shareIntent, &quot;Share images to..&quot;));
</code></pre>
<h4 id="从其他app接收简单数据"><a href="#从其他app接收简单数据" class="headerlink" title="从其他app接收简单数据"></a>从其他app接收简单数据</h4><h5 id="更新Manifest"><a href="#更新Manifest" class="headerlink" title="更新Manifest"></a>更新Manifest</h5><pre><code>&lt;activity android:name=&quot;.ui.MyActivity&quot; &gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.SEND&quot; /&gt;
        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;
        &lt;data android:mimeType=&quot;image/*&quot; /&gt;
    &lt;/intent-filter&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.SEND&quot; /&gt;
        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;
        &lt;data android:mimeType=&quot;text/plain&quot; /&gt;
    &lt;/intent-filter&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.SEND_MULTIPLE&quot; /&gt;
        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;
        &lt;data android:mimeType=&quot;image/*&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;
</code></pre>
<h5 id="处理接收到的内容"><a href="#处理接收到的内容" class="headerlink" title="处理接收到的内容"></a>处理接收到的内容</h5><pre><code>void onCreate (Bundle savedInstanceState) &#123;
    ...
    // Get intent, action and MIME type
    Intent intent = getIntent();
    String action = intent.getAction();
    String type = intent.getType();

    if (Intent.ACTION_SEND.equals(action) &amp;&amp; type != null) &#123;
        if (&quot;text/plain&quot;.equals(type)) &#123;
            handleSendText(intent); // Handle text being sent
        &#125; else if (type.startsWith(&quot;image/&quot;)) &#123;
            handleSendImage(intent); // Handle single image being sent
        &#125;
    &#125; else if (Intent.ACTION_SEND_MULTIPLE.equals(action) &amp;&amp; type != null) &#123;
        if (type.startsWith(&quot;image/&quot;)) &#123;
            handleSendMultipleImages(intent); // Handle multiple images being sent
        &#125;
    &#125; else &#123;
        // Handle other intents, such as being started from the home screen
    &#125;
    ...
&#125;

void handleSendText(Intent intent) &#123;
    String sharedText = intent.getStringExtra(Intent.EXTRA_TEXT);
    if (sharedText != null) &#123;
        // Update UI to reflect text being shared
    &#125;
&#125;

void handleSendImage(Intent intent) &#123;
    Uri imageUri = (Uri) intent.getParcelableExtra(Intent.EXTRA_STREAM);
    if (imageUri != null) &#123;
        // Update UI to reflect image being shared
    &#125;
&#125;

void handleSendMultipleImages(Intent intent) &#123;
    ArrayList&lt;Uri&gt; imageUris = intent.getParcelableArrayListExtra(Intent.EXTRA_STREAM);
    if (imageUris != null) &#123;
        // Update UI to reflect multiple images being shared
    &#125;
&#125;
</code></pre>
<h4 id="添加一个简单的分享action"><a href="#添加一个简单的分享action" class="headerlink" title="添加一个简单的分享action"></a>添加一个简单的分享action</h4><h5 id="更新菜单声明"><a href="#更新菜单声明" class="headerlink" title="更新菜单声明"></a>更新菜单声明</h5><pre><code>&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
    &lt;item
            android:id=&quot;@+id/menu_item_share&quot;
            android:showAsAction=&quot;ifRoom&quot;
            android:title=&quot;Share&quot;
            android:actionProviderClass=
                &quot;android.widget.ShareActionProvider&quot; /&gt;
    ...
&lt;/menu&gt;
</code></pre>
<h5 id="Set-the-Share-Intent"><a href="#Set-the-Share-Intent" class="headerlink" title="Set the Share Intent"></a>Set the Share Intent</h5><pre><code>private ShareActionProvider mShareActionProvider;
...

@Override
public boolean onCreateOptionsMenu(Menu menu) &#123;
    // Inflate menu resource file.
    getMenuInflater().inflate(R.menu.share_menu, menu);

    // Locate MenuItem with ShareActionProvider
    MenuItem item = menu.findItem(R.id.menu_item_share);

    // Fetch and store ShareActionProvider
    mShareActionProvider = (ShareActionProvider) item.getActionProvider();

    // Return true to display menu
    return true;
&#125;

// Call to update the share intent
private void setShareIntent(Intent shareIntent) &#123;
    if (mShareActionProvider != null) &#123;
        mShareActionProvider.setShareIntent(shareIntent);
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>android_系统权限</title>
    <url>/2016/06/23/android-%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[<h4 id="声明权限"><a href="#声明权限" class="headerlink" title="声明权限"></a>声明权限</h4><span id="more"></span>

<h5 id="确定app需要哪些权限"><a href="#确定app需要哪些权限" class="headerlink" title="确定app需要哪些权限"></a>确定app需要哪些权限</h5><h5 id="在Manifest中添加权限"><a href="#在Manifest中添加权限" class="headerlink" title="在Manifest中添加权限"></a>在Manifest中添加权限</h5><pre><code>&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
        package=&quot;com.example.snazzyapp&quot;&gt;

    &lt;uses-permission android:name=&quot;android.permission.SEND_SMS&quot;/&gt;
    

    &lt;application ...&gt;
        ...
    &lt;/application&gt;

&lt;/manifest&gt;
</code></pre>
<h4 id="在运行时请求权限"><a href="#在运行时请求权限" class="headerlink" title="在运行时请求权限"></a>在运行时请求权限</h4><p>在android6.0之后，在app运行时用户可以授予权限，而不是在app安装时确认</p>
<h5 id="检查权限"><a href="#检查权限" class="headerlink" title="检查权限"></a>检查权限</h5><pre><code>// Assume thisActivity is the current activity
int permissionCheck = ContextCompat.checkSelfPermission(thisActivity,
        Manifest.permission.WRITE_CALENDAR);
</code></pre>
<h5 id="请求权限"><a href="#请求权限" class="headerlink" title="请求权限"></a>请求权限</h5><h6 id="解释为什么要权限"><a href="#解释为什么要权限" class="headerlink" title="解释为什么要权限"></a>解释为什么要权限</h6><pre><code>shouldShowRequestPermissionRationale()    
</code></pre>
<p>当app请求了对应权限，而用户拒绝了，此方法返回true</p>
<h6 id="请求需要的权限"><a href="#请求需要的权限" class="headerlink" title="请求需要的权限"></a>请求需要的权限</h6><p>requestPermissions()</p>
<pre><code>// Here, thisActivity is the current activity
if (ContextCompat.checkSelfPermission(thisActivity,
                Manifest.permission.READ_CONTACTS)
        != PackageManager.PERMISSION_GRANTED) &#123;

    // Should we show an explanation?
    if (ActivityCompat.shouldShowRequestPermissionRationale(thisActivity,
            Manifest.permission.READ_CONTACTS)) &#123;

        // Show an expanation to the user *asynchronously* -- don&#39;t block
        // this thread waiting for the user&#39;s response! After the user
        // sees the explanation, try again to request the permission.

    &#125; else &#123;

        // No explanation needed, we can request the permission.

        ActivityCompat.requestPermissions(thisActivity,
                new String[]&#123;Manifest.permission.READ_CONTACTS&#125;,
                MY_PERMISSIONS_REQUEST_READ_CONTACTS);

        // MY_PERMISSIONS_REQUEST_READ_CONTACTS is an
        // app-defined int constant. The callback method gets the
        // result of the request.
    &#125;
&#125;
</code></pre>
<h6 id="处理权限请求响应"><a href="#处理权限请求响应" class="headerlink" title="处理权限请求响应"></a>处理权限请求响应</h6><pre><code>@Override
public void onRequestPermissionsResult(int requestCode,
        String permissions[], int[] grantResults) &#123;
    switch (requestCode) &#123;
        case MY_PERMISSIONS_REQUEST_READ_CONTACTS: &#123;
            // If request is cancelled, the result arrays are empty.
            if (grantResults.length &gt; 0
                &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123;

                // permission was granted, yay! Do the
                // contacts-related task you need to do.

            &#125; else &#123;

                // permission denied, boo! Disable the
                // functionality that depends on this permission.
            &#125;
            return;
        &#125;

        // other &#39;case&#39; lines to check for other
        // permissions this app might request
    &#125;
&#125;
</code></pre>
<h4 id="权限的最佳实践"><a href="#权限的最佳实践" class="headerlink" title="权限的最佳实践"></a>权限的最佳实践</h4>]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>androidStudio快捷键整理</title>
    <url>/2016/06/19/androidStudio%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h4 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h4><p>Alt + insert  </p>
<h4 id="格式化代码"><a href="#格式化代码" class="headerlink" title="格式化代码"></a>格式化代码</h4><p>Ctrl+Alt+L </p>
<h4 id="大小写切换"><a href="#大小写切换" class="headerlink" title="大小写切换"></a>大小写切换</h4><p>Ctrl+Shift+U </p>
<h4 id="代码提示"><a href="#代码提示" class="headerlink" title="代码提示"></a>代码提示</h4><p>shift+ space(自己设置)<br>设置方法：File-&gt;setting-&gt;Keymap-&gt;Main menu-&gt;Code-&gt;Completion</p>
<h4 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h4><p>Alt + Enter</p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android studio</tag>
      </tags>
  </entry>
  <entry>
    <title>android学习记录</title>
    <url>/2016/06/19/android%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h4 id="activity之间的跳转和数据传递"><a href="#activity之间的跳转和数据传递" class="headerlink" title="activity之间的跳转和数据传递"></a>activity之间的跳转和数据传递</h4><span id="more"></span>

<p>MainActivity-&gt;Main2Activity<br>MainActivity代码:  </p>
<pre><code>Intent intent = new Intent();
intent.putExtra(&quot;name&quot;,&quot;哈哈哈&quot;);
intent.setClass(MainActivity.this,Main2Activity.class);
MainActivity.this.startActivity(intent);  
</code></pre>
<p>Main2Activity代码:  </p>
<pre><code>tv1 = (TextView) findViewById(R.id.main2text);
String value = getIntent().getStringExtra(&quot;name&quot;);
tv1.setText(value);  
</code></pre>
<h4 id="activity生命周期"><a href="#activity生命周期" class="headerlink" title="activity生命周期"></a>activity生命周期</h4><p><img src="/uploads/activityLifecycle.PNG" alt="Activity Lifecycle">  </p>
<h5 id="onCreate"><a href="#onCreate" class="headerlink" title="onCreate()"></a>onCreate()</h5><p>Called when the activity is first created<br>当activity第一次被创建的时候调用</p>
<h5 id="onStart"><a href="#onStart" class="headerlink" title="onStart()"></a>onStart()</h5><p>Called when the activity is becoming visible to the user<br>当activity对用户可见时调用</p>
<h4 id="onRestart"><a href="#onRestart" class="headerlink" title="onRestart()"></a>onRestart()</h4><p>Called after your activity has been stopped<br>当activity已经stoped过，恢复的时候调用</p>
<h5 id="onResume"><a href="#onResume" class="headerlink" title="onResume()"></a>onResume()</h5><p>Called when the activity will start interacting with the user<br>当用户能获取activity焦点时调用</p>
<h5 id="onPause"><a href="#onPause" class="headerlink" title="onPause()"></a>onPause()</h5><p>Called when the system is about to start resuming a previous activity<br>当系统恢复之前的activity时调用（失去焦点），通常用来在此方法里面持久化当前activity的数据等</p>
<h5 id="onStop"><a href="#onStop" class="headerlink" title="onStop()"></a>onStop()</h5><p>Called when the activity is no longer visible to the use<br>当activity完全不可见时调用</p>
<h5 id="onDestroy"><a href="#onDestroy" class="headerlink" title="onDestroy()"></a>onDestroy()</h5><p>The final call you receive before your activity is destroyed  </p>
<h4 id="将activity设置为窗口模式"><a href="#将activity设置为窗口模式" class="headerlink" title="将activity设置为窗口模式"></a>将activity设置为窗口模式</h4><p>在AndroidManifest.xml中设置theme</p>
<h4 id="设备兼容"><a href="#设备兼容" class="headerlink" title="设备兼容"></a>设备兼容</h4><h5 id="语言兼容"><a href="#语言兼容" class="headerlink" title="语言兼容"></a>语言兼容</h5><pre><code>MyProject/
    res/
       values/
           strings.xml
       values-es/
           strings.xml
       values-fr/
           strings.xml  
</code></pre>
<p>Android系统会基于当前系统的语言环境设置来选择对应的设置</p>
<h5 id="屏幕兼容"><a href="#屏幕兼容" class="headerlink" title="屏幕兼容"></a>屏幕兼容</h5><p>创建不同的布局  </p>
<pre><code>MyProject/
    res/
        layout/              # default (portrait)
            main.xml
        layout-land/         # landscape
            main.xml
        layout-large/        # large (portrait)
            main.xml
        layout-large-land/   # large landscape
            main.xml
</code></pre>
<p>创建不同的位图  </p>
<ul>
<li>xhdpi: 2.0</li>
<li>hdpi: 1.5</li>
<li>mdpi: 1.0 (baseline)</li>
<li>ldpi: 0.75</li>
</ul>
<p>如果xhdpi的图像为200*200，则hdpi为150*150，mdpi为100*100,ldpi为75*75  </p>
<pre><code>MyProject/
    res/
        drawable-xhdpi/
            awesomeimage.png
        drawable-hdpi/
            awesomeimage.png
        drawable-mdpi/
            awesomeimage.png
        drawable-ldpi/
            awesomeimage.png  
</code></pre>
<p>当引用 @drawable/awesomeimage时，系统会根据屏幕的分辨率选择对应的图片</p>
<h5 id="版本兼容"><a href="#版本兼容" class="headerlink" title="版本兼容"></a>版本兼容</h5><p>指定最小和目标API级别  </p>
<pre><code>&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; ... &gt;
    &lt;uses-sdk android:minSdkVersion=&quot;4&quot; android:targetSdkVersion=&quot;15&quot; /&gt;
    ...
&lt;/manifest&gt;  
</code></pre>
<p>在运行时检查系统版本  </p>
<pre><code>private void setUpActionBar() &#123;
    // Make sure we&#39;re running on Honeycomb or higher to use ActionBar APIs
    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) &#123;
        ActionBar actionBar = getActionBar();
        actionBar.setDisplayHomeAsUpEnabled(true);
    &#125;
&#125;  
</code></pre>
<p>使用平台的主题和样式<br>To make your activity look like a dialog box:</p>
<pre><code>&lt;activity android:theme=&quot;@android:style/Theme.Dialog&quot;&gt;
</code></pre>
<p>To make your activity have a transparent background:</p>
<pre><code>&lt;activity android:theme=&quot;@android:style/Theme.Translucent&quot;&gt;
</code></pre>
<p>To apply your own custom theme defined in /res/values/styles.xml:</p>
<pre><code>&lt;activity android:theme=&quot;@style/CustomTheme&quot;&gt;
</code></pre>
<p>To apply a theme to your entire app (all activities), add the android:theme attribute to the <application> element:</p>
<pre><code>application android:theme=&quot;@style/CustomTheme&quot;&gt;  
</code></pre>
<h4 id="Fragment的创建"><a href="#Fragment的创建" class="headerlink" title="Fragment的创建"></a>Fragment的创建</h4><p>1.Create a Fragment Class  </p>
<pre><code>import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.view.LayoutInflater;
import android.view.ViewGroup;

public class ArticleFragment extends Fragment &#123;
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
        Bundle savedInstanceState) &#123;
        // Inflate the layout for this fragment
        return inflater.inflate(R.layout.article_view, container, false);
    &#125;
&#125;
</code></pre>
<p>2.Add a Fragment to an Activity using XML  </p>
<p>res/layout-large/news_articles.xml  </p>
<pre><code>&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:orientation=&quot;horizontal&quot;
    android:layout_width=&quot;fill_parent&quot;
    android:layout_height=&quot;fill_parent&quot;&gt;

    &lt;fragment android:name=&quot;com.example.android.fragments.HeadlinesFragment&quot;
              android:id=&quot;@+id/headlines_fragment&quot;
              android:layout_weight=&quot;1&quot;
              android:layout_width=&quot;0dp&quot;
              android:layout_height=&quot;match_parent&quot; /&gt;

    &lt;fragment android:name=&quot;com.example.android.fragments.ArticleFragment&quot;
              android:id=&quot;@+id/article_fragment&quot;
              android:layout_weight=&quot;2&quot;
              android:layout_width=&quot;0dp&quot;
              android:layout_height=&quot;match_parent&quot; /&gt;

&lt;/LinearLayout&gt;
</code></pre>
<p>3.Then apply the layout to your activity  </p>
<pre><code>import android.os.Bundle;
import android.support.v4.app.FragmentActivity;

public class MainActivity extends FragmentActivity &#123;
    @Override
    public void onCreate(Bundle savedInstanceState) &#123;
        super.onCreate(savedInstanceState);
        setContentView(R.layout.news_articles);
    &#125;
&#125;
</code></pre>
<p>更多内容参考<a href="http://blog.csdn.net/guolin_blog/article/details/8881711">Android Fragment完全解析，关于碎片你所需知道的一切</a></p>
<h4 id="保存数据"><a href="#保存数据" class="headerlink" title="保存数据"></a>保存数据</h4><h5 id="保存键值对"><a href="#保存键值对" class="headerlink" title="保存键值对"></a>保存键值对</h5><p>获取SharedPreferences     </p>
<pre><code>1.通过R.string.preference_file_key获取对应的SharedPreferences
    Context context = getActivity();
    SharedPreferences sharedPref = context.getSharedPreferences(
        getString(R.string.preference_file_key), Context.MODE_PRIVATE);  
2.获取Activity的公共的SharedPreferences
    SharedPreferences sharedPref = getActivity().getPreferences(Context.MODE_PRIVATE);  
</code></pre>
<p>写入SharedPreferences </p>
<pre><code>SharedPreferences sharedPref = getActivity().getPreferences(Context.MODE_PRIVATE);
SharedPreferences.Editor editor = sharedPref.edit();
editor.putInt(getString(R.string.saved_high_score), newHighScore);
editor.commit();
</code></pre>
<p>读取SharedPreferences </p>
<pre><code>SharedPreferences sharedPref = getActivity().getPreferences(Context.MODE_PRIVATE);
int defaultValue = getResources().getInteger(R.string.saved_high_score_default);
long highScore = sharedPref.getInt(getString(R.string.saved_high_score), defaultValue);
</code></pre>
<h5 id="保存文件"><a href="#保存文件" class="headerlink" title="保存文件"></a>保存文件</h5><h6 id="内部存储"><a href="#内部存储" class="headerlink" title="内部存储"></a>内部存储</h6><ul>
<li>它始终可用  </li>
<li>默认情况下只有您的应用可以访问此处保存的文件</li>
<li>当用户卸载您的应用时，系统会从内部存储中删除您的应用的所有文件。</li>
</ul>
<p>获取应用的内部目录的 File  </p>
<pre><code>getFilesDir()
</code></pre>
<p>获取应用临时缓存文件的内部目录的 File  </p>
<pre><code>getCacheDir()
</code></pre>
<p>用法：</p>
<pre><code>File file = new File(context.getFilesDir(), filename);
</code></pre>
<p>或者 调用 openFileOutput() 获取写入到内部目录中的文件的 FileOutputStream</p>
<pre><code>String filename = &quot;myfile&quot;;
String string = &quot;Hello world!&quot;;
FileOutputStream outputStream;

try &#123;
  outputStream = openFileOutput(filename, Context.MODE_PRIVATE);
  outputStream.write(string.getBytes());
  outputStream.close();
&#125; catch (Exception e) &#123;
  e.printStackTrace();
&#125;  
</code></pre>
<p>或者 缓存某些文件，您应改用 createTempFile()</p>
<pre><code>public File getTempFile(Context context, String url) &#123;
    File file;
    try &#123;
        String fileName = Uri.parse(url).getLastPathSegment();
        file = File.createTempFile(fileName, null, context.getCacheDir());
    catch (IOException e) &#123;
        // Error while creating file
    &#125;
    return file;
&#125;
</code></pre>
<h6 id="外部存储"><a href="#外部存储" class="headerlink" title="外部存储"></a>外部存储</h6><ul>
<li>它并非始终可用，因为用户可采用 USB 存储的形式装载外部存储，并在某些情况下会从设备中将其删除</li>
<li>它是全局可读的，因此此处保存的文件可能不受您控制地被读取</li>
<li>当用户卸载您的应用时，只有在您通过 getExternalFilesDir() 将您的应用的文件保存在目录中时，系统才会从此处删除您的应用的文件</li>
</ul>
<p>1.获取权限  </p>
<pre><code>&lt;manifest ...&gt;  
    &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;
     &lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;
    ...
&lt;/manifest&gt;
</code></pre>
<p>通过调用 getExternalStorageState() 查询外部存储状态。 如果返回的状态为 MEDIA_MOUNTED，那么您可以对您的文件进行读写    </p>
<pre><code>/* Checks if external storage is available for read and write */
public boolean isExternalStorageWritable() &#123;
    String state = Environment.getExternalStorageState();
    if (Environment.MEDIA_MOUNTED.equals(state)) &#123;
        return true;
    &#125;
    return false;
&#125;

/* Checks if external storage is available to at least read */
public boolean isExternalStorageReadable() &#123;
    String state = Environment.getExternalStorageState();
    if (Environment.MEDIA_MOUNTED.equals(state) ||
        Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)) &#123;
        return true;
    &#125;
    return false;
&#125;
</code></pre>
<p>如果要使用外部存储上的公共文件，使用 getExternalStoragePublicDirectory() 方法获取表示外部存储上相应目录的 File 。该方法使用指定 您想要保存以便它们可以与其他公共文件在逻辑上组织在一起的文件类型的参数，比如 DIRECTORY_MUSIC 或 DIRECTORY_PICTURES  </p>
<pre><code>public File getAlbumStorageDir(String albumName) &#123;
    // Get the directory for the user&#39;s public pictures directory. 
    File file = new File(Environment.getExternalStoragePublicDirectory(
            Environment.DIRECTORY_PICTURES), albumName);
    if (!file.mkdirs()) &#123;
        Log.e(LOG_TAG, &quot;Directory not created&quot;);
    &#125;
    return file;
&#125; 
</code></pre>
<p>通过调用 getExternalFilesDir() 获取相应的目录并向其传递指示您想要的目录类型的名称。当用户卸载应用时，系统会删除这些文件</p>
<pre><code>public File getAlbumStorageDir(Context context, String albumName) &#123;
    // Get the directory for the app&#39;s private pictures directory. 
    File file = new File(context.getExternalFilesDir(
            Environment.DIRECTORY_PICTURES), albumName);
    if (!file.mkdirs()) &#123;
        Log.e(LOG_TAG, &quot;Directory not created&quot;);
    &#125;
    return file;
&#125;
</code></pre>
<h6 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h6><pre><code>myFile.delete();
or
myContext.deleteFile(fileName);
</code></pre>
<h5 id="使用-SQLite-保存数据"><a href="#使用-SQLite-保存数据" class="headerlink" title="使用 SQLite 保存数据"></a>使用 SQLite 保存数据</h5><h6 id="Define-a-Schema-and-Contract"><a href="#Define-a-Schema-and-Contract" class="headerlink" title="Define a Schema and Contract"></a>Define a Schema and Contract</h6><p>通过实现 BaseColumns接口，能自动生成_ID 字段</p>
<pre><code>public final class FeedReaderContract &#123;
    // To prevent someone from accidentally instantiating the contract class,
    // give it an empty constructor.
    public FeedReaderContract() &#123;&#125;

    /* Inner class that defines the table contents */
    public static abstract class FeedEntry implements BaseColumns &#123;
        public static final String TABLE_NAME = &quot;entry&quot;;
        public static final String COLUMN_NAME_ENTRY_ID = &quot;entryid&quot;;
        public static final String COLUMN_NAME_TITLE = &quot;title&quot;;
        public static final String COLUMN_NAME_SUBTITLE = &quot;subtitle&quot;;
        ...
    &#125;
&#125;
</code></pre>
<h6 id="Create-a-Database-Using-a-SQL-Helper"><a href="#Create-a-Database-Using-a-SQL-Helper" class="headerlink" title="Create a Database Using a SQL Helper"></a>Create a Database Using a SQL Helper</h6><pre><code>private static final String TEXT_TYPE = &quot; TEXT&quot;;
private static final String COMMA_SEP = &quot;,&quot;;
private static final String SQL_CREATE_ENTRIES =
    &quot;CREATE TABLE &quot; + FeedEntry.TABLE_NAME + &quot; (&quot; +
    FeedEntry._ID + &quot; INTEGER PRIMARY KEY,&quot; +
    FeedEntry.COLUMN_NAME_ENTRY_ID + TEXT_TYPE + COMMA_SEP +
    FeedEntry.COLUMN_NAME_TITLE + TEXT_TYPE + COMMA_SEP +
    ... // Any other options for the CREATE command
    &quot; )&quot;;

private static final String SQL_DELETE_ENTRIES =
    &quot;DROP TABLE IF EXISTS &quot; + FeedEntry.TABLE_NAME; 
</code></pre>
<p>Note: Because they can be long-running, be sure that you call getWritableDatabase() or getReadableDatabase() in a background thread, such as with AsyncTask or IntentService.</p>
<pre><code>public class FeedReaderDbHelper extends SQLiteOpenHelper &#123;
    // If you change the database schema, you must increment the database version.
    public static final int DATABASE_VERSION = 1;
    public static final String DATABASE_NAME = &quot;FeedReader.db&quot;;

    public FeedReaderDbHelper(Context context) &#123;
        super(context, DATABASE_NAME, null, DATABASE_VERSION);
    &#125;
    public void onCreate(SQLiteDatabase db) &#123;
        db.execSQL(SQL_CREATE_ENTRIES);
    &#125;
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123;
        // This database is only a cache for online data, so its upgrade policy is
        // to simply to discard the data and start over
        db.execSQL(SQL_DELETE_ENTRIES);
        onCreate(db);
    &#125;
    public void onDowngrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123;
        onUpgrade(db, oldVersion, newVersion);
    &#125;
&#125;
</code></pre>
<p>然后</p>
<pre><code>FeedReaderDbHelper mDbHelper = new FeedReaderDbHelper(getContext())
</code></pre>
<h6 id="Put-Information-into-a-Database"><a href="#Put-Information-into-a-Database" class="headerlink" title="Put Information into a Database"></a>Put Information into a Database</h6><pre><code>// Gets the data repository in write mode
SQLiteDatabase db = mDbHelper.getWritableDatabase();

// Create a new map of values, where column names are the keys
ContentValues values = new ContentValues();
values.put(FeedEntry.COLUMN_NAME_ENTRY_ID, id);
values.put(FeedEntry.COLUMN_NAME_TITLE, title);
values.put(FeedEntry.COLUMN_NAME_CONTENT, content);

// Insert the new row, returning the primary key value of the new row
long newRowId;
newRowId = db.insert(
         FeedEntry.TABLE_NAME,
         FeedEntry.COLUMN_NAME_NULLABLE,
         values);
</code></pre>
<h6 id="Read-Information-from-a-Database"><a href="#Read-Information-from-a-Database" class="headerlink" title="Read Information from a Database"></a>Read Information from a Database</h6><pre><code>SQLiteDatabase db = mDbHelper.getReadableDatabase();

// Define a projection that specifies which columns from the database
// you will actually use after this query.
String[] projection = &#123;
    FeedEntry._ID,
    FeedEntry.COLUMN_NAME_TITLE,
    FeedEntry.COLUMN_NAME_UPDATED,
    ...
    &#125;;

// How you want the results sorted in the resulting Cursor
String sortOrder =
    FeedEntry.COLUMN_NAME_UPDATED + &quot; DESC&quot;;

Cursor c = db.query(
    FeedEntry.TABLE_NAME,  // The table to query
    projection,                               // The columns to return
    selection,                                // The columns for the WHERE clause
    selectionArgs,                            // The values for the WHERE clause
    null,                                     // don&#39;t group the rows
    null,                                     // don&#39;t filter by row groups
    sortOrder                                 // The sort order
    );
</code></pre>
<p>then</p>
<pre><code>cursor.moveToFirst();
long itemId = cursor.getLong(
    cursor.getColumnIndexOrThrow(FeedEntry._ID)
)
</code></pre>
<h6 id="Delete-Information-from-a-Database"><a href="#Delete-Information-from-a-Database" class="headerlink" title="Delete Information from a Database"></a>Delete Information from a Database</h6><pre><code>// Define &#39;where&#39; part of query.
String selection = FeedEntry.COLUMN_NAME_ENTRY_ID + &quot; LIKE ?&quot;;
// Specify arguments in placeholder order.
String[] selectionArgs = &#123; String.valueOf(rowId) &#125;;
// Issue SQL statement.
db.delete(table_name, selection, selectionArgs)
</code></pre>
<h6 id="Update-a-Database"><a href="#Update-a-Database" class="headerlink" title="Update a Database"></a>Update a Database</h6><pre><code>SQLiteDatabase db = mDbHelper.getReadableDatabase();

// New value for one column
ContentValues values = new ContentValues();
values.put(FeedEntry.COLUMN_NAME_TITLE, title);

// Which row to update, based on the ID
String selection = FeedEntry.COLUMN_NAME_ENTRY_ID + &quot; LIKE ?&quot;;
String[] selectionArgs = &#123; String.valueOf(rowId) &#125;;

int count = db.update(
    FeedReaderDbHelper.FeedEntry.TABLE_NAME,
    values,
    selection,
    selectionArgs);
</code></pre>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>appcan主应用子应用页面互调方法</title>
    <url>/2016/06/02/appcan%E4%B8%BB%E5%BA%94%E7%94%A8%E5%AD%90%E5%BA%94%E7%94%A8%E9%A1%B5%E9%9D%A2%E4%BA%92%E8%B0%83%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><span id="more"></span>

<p>由于子应用和主应用页面文件的位置不一样，导致使用window.open难以打开对应的页面</p>
<h3 id="子应用打开主应用页面"><a href="#子应用打开主应用页面" class="headerlink" title="子应用打开主应用页面"></a>子应用打开主应用页面</h3><p>将需要打开的公共页面放置在plugin文件夹下的子应用中，调用时调用这个子应用打开。</p>
<p>1.plugin子应用也是一个widget应用，在config.xml同级创建一个plugin目录，其中放入以appid命名的文件夹，里面防止子应用的config以及相关网页代码。</p>
<p>2.调用时也需要使用uexWidget.startWidget来调用，但是无需传入appkey。</p>
<p>3.此应用无需在EMM注册，升级时跟随主应用升级。</p>
<h3 id="主应用打开子应用页面"><a href="#主应用打开子应用页面" class="headerlink" title="主应用打开子应用页面"></a>主应用打开子应用页面</h3><p>1.使用uexWidget.startWidget启动应用，openInfo中携带字符串，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uexWidget.startWidget(&quot;aaaao20031&quot;, &quot;5&quot;, &quot;pluginCallback&quot;, &quot;plugin123123&quot;, &quot;200&quot;, &quot;cfec6312-2584-4916-bfba-1a8239421c6f&quot;);</span><br></pre></td></tr></table></figure>
<p>2.在A应用中接收openInfo,之后在A应用内部跳转到a页面。(A页面背景色最好设置为透明)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uexWidget.cbGetOpenerInfo&#x3D;function(opId,dataType,data)&#123;</span><br><span class="line">    if(data&#x3D;&#x3D;&#39;xxx&#39;)&#123;</span><br><span class="line">        appcan.window.open();</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        appcan.window.open();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">uexWidget.getOpenerInfo();</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>appcan</category>
      </categories>
      <tags>
        <tag>appcan</tag>
      </tags>
  </entry>
  <entry>
    <title>express入门</title>
    <url>/2016/06/04/express%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><span id="more"></span>

<pre><code>npm install express --save
</code></pre>
<h1 id="Express-应用生成器"><a href="#Express-应用生成器" class="headerlink" title="Express 应用生成器"></a>Express 应用生成器</h1><h3 id="安装-expres-sgenerator-："><a href="#安装-expres-sgenerator-：" class="headerlink" title="安装 expres-sgenerator ："></a>安装 expres-sgenerator ：</h3><pre><code>npm install express-generator -g
</code></pre>
<h3 id="创建应用程序"><a href="#创建应用程序" class="headerlink" title="创建应用程序"></a>创建应用程序</h3><pre><code>express myapp
</code></pre>
<h3 id="安装依赖项："><a href="#安装依赖项：" class="headerlink" title="安装依赖项："></a>安装依赖项：</h3><pre><code>cd myapp
npm install
</code></pre>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><pre><code>MacOS or Linux :* npm start
Wdinwos:set DEBUG=myapp:* &amp; npm start
</code></pre>
<h1 id="基本路由"><a href="#基本路由" class="headerlink" title="基本路由"></a>基本路由</h1><h3 id="路由结构"><a href="#路由结构" class="headerlink" title="路由结构"></a>路由结构</h3><pre><code>app.METHOD(PATH, HANDLER)
</code></pre>
<ul>
<li>app 是 express 的实例。</li>
<li>METHOD 是 HTTP 请求方法。</li>
<li>PATH 是服务器上的路径。</li>
<li>HANDLER 是在路由匹配时执行的函数。<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3>  app.get(‘/‘, function (req, res) {<pre><code>res.send(&#39;Hello World!&#39;);
</code></pre>
  });<br>  app.post(‘/‘, function (req, res) {<pre><code>res.send(&#39;Got a POST request&#39;);
</code></pre>
  });<h1 id="静态文件"><a href="#静态文件" class="headerlink" title="静态文件"></a>静态文件</h1><h3 id="使用-Express-中的-express-static-内置中间件函数"><a href="#使用-Express-中的-express-static-内置中间件函数" class="headerlink" title="使用 Express 中的 express.static 内置中间件函数"></a>使用 Express 中的 express.static 内置中间件函数</h3>  app.use(express.static(‘public’));<br>  app.use(express.static(‘files’));</li>
</ul>
]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>express</tag>
      </tags>
  </entry>
  <entry>
    <title>git常用命令</title>
    <url>/2021/04/06/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>一个非常好的学习Git命令的网站:<a href="https://learngitbranching.js.org/?locale=zh_CN">Learn Git Branching</a></p>
<span id="more"></span>
<p>git常用命令整理</p>
<h1 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h1><pre><code>git branch 查看本地所有分支
git branch -r 查看远程所有分支
git branch -a 查看本地和远程所有分支
git branch -f &lt;branchname&gt; 新建本地分支
git branch -f &lt;branchname&gt; 9fbc3d0  指定commit新建本地分支
git branch -d &lt;branchname&gt; 删除本地分支
git branch (-m | -M) &lt;oldbranch&gt; &lt;newbranch&gt; 修改本地分支名，记得push至远端
</code></pre>
<h1 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h1><blockquote>
<p>不保留分支的commit提交节点 。</p>
</blockquote>
<p>合并步骤：</p>
<pre><code>1、进入要合并的分支（如开发分支合并到master，则进入master目录）
git checkout master
git pull

2、查看所有分支是否都pull下来了
git branch -a

3、使用merge合并开发分支
git merge 分支名

4、查看合并之后的状态
git status

5、有冲突的话，通过IDE解决冲突；

6、解决冲突之后，将冲突文件提交暂存区
git add 冲突文件

7、提交merge之后的结果
git commit

如果不是使用git commit -m &quot;备注&quot; ，那么git会自动将合并的结果作为备注，提交本地仓库；

8、本地仓库代码提交远程仓库
git push

git将分支合并到分支，将master合并到分支的操作步骤是一样的。
</code></pre>
<h1 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h1><blockquote>
<p>Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。<br>Rebase 的优势就是可以创造更线性的提交历史，这听上去有些难以理解。如果只允许使用 Rebase 的话，代码库的提交历史将会变得异常清晰。</p>
</blockquote>
<p>git rebase -i HEAD~4  交互式修改前四次记录（调整顺序  删除无用记录 等）</p>
<h1 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h1><blockquote>
<p>撤销本地改动<br>git reset HEAD~1 本地指向前一个结点  当前节点进入暂存区</p>
</blockquote>
<pre><code>git reset --soft &lt;版本号&gt;  重置至指定版本的提交，达到撤销提交的目的.

git reset soft 和 git reset hard的区别：

git reset soft只是改变了HEAD的指向，本地代码不会变化，
git reset hard会改变本地源码，不仅仅指向变化了，代码也回到了那个版本时的代码。

git push origin 分支名 –-force 强制提交当前版本号。
</code></pre>
<h1 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h1><blockquote>
<p>撤销远程改动<br>git revert HEAD  服务器上会产生一个新的提交记录，内容为退回之前的一次提交</p>
</blockquote>
<h1 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry-pick"></a>git cherry-pick</h1><p>git cherry-pick c3 c5 c7 在当前分支后面添加另一分支任意部分提交记录</p>
<h1 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h1><pre><code>git push origin &lt;本地分支名&gt;:&lt;远程分支名&gt; 推送本地分支操作至远端
git push origin --delete [branchname]  删除远程分支
将本地分支track至远端对应版本 git branch --set-upstream-to=origin/&lt;branch&gt; v3.2.1
</code></pre>
<h1 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h1><pre><code>git ls-remote 查看远程所有分支/标签
git tag 查看本地tag
git tag tag_v0.1.2 创建本地tag 
git tag tag_v0.1.1 9fbc3d0 对指定commit打tag
git tag -d tag_v0.1.2 删除本地标签
git push origin :refs/tags/test_tag 本地删除的tag提交到线上
git push origin tag_v0.1.2 将v0.1.2标签提交到git服务器
git push origin –tags 将本地所有标签一次性提交到远端
</code></pre>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>go入门</title>
    <url>/2021/04/19/go%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="第一个-Go-程序"><a href="#第一个-Go-程序" class="headerlink" title="第一个 Go 程序"></a>第一个 Go 程序</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>go run 命令直接运行:</p>
<pre><code>go run hello.go 
Hello, World!
</code></pre>
<p>go build 命令来生成二进制文件：</p>
<pre><code>go build hello.go 
./hello.exe
Hello, World!
</code></pre>
<h1 id="语言基础语法"><a href="#语言基础语法" class="headerlink" title="语言基础语法"></a>语言基础语法</h1><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>一个标识符实际上就是一个或是多个字母(A<del>Z和a</del>z)数字(0~9)、下划线_组成的序列，但是第一个字符必须是字母或下划线而不能是数字。</p>
<p>以下是无效的标识符：</p>
<ul>
<li>1ab（以数字开头）</li>
<li>case（Go 语言的关键字）</li>
<li>a+b（运算符是不允许的）</li>
</ul>
<h2 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// %d 表示整型数字，%s 表示字符串</span></span><br><span class="line">    <span class="keyword">var</span> stockcode=<span class="number">123</span></span><br><span class="line">    <span class="keyword">var</span> enddate=<span class="string">&quot;2020-12-31&quot;</span></span><br><span class="line">    <span class="keyword">var</span> url=<span class="string">&quot;Code=%d&amp;endDate=%s&quot;</span></span><br><span class="line">    <span class="keyword">var</span> target_url=fmt.Sprintf(url,stockcode,enddate)</span><br><span class="line">    fmt.Println(target_url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>布尔型: var b bool = true。</p>
<p>数字类型: 整型 int 和浮点型 float32、float64</p>
<p>字符串类型</p>
<p>派生类型:<br>(a) 指针类型（Pointer）<br>(b) 数组类型<br>(c) 结构化类型(struct)<br>(d) Channel 类型<br>(e) 函数类型<br>(f) 切片类型<br>(g) 接口类型（interface）<br>(h) Map 类型</p>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><ul>
<li>指定变量类型，如果没有初始化，则变量默认为零值。<br>  var b int<br>  b = 1;</li>
<li>根据值自行判定变量类型。<br>  var d = true</li>
<li>省略 var, 使用 :=（只能被用在函数体内，而不可以用于全局变量的声明与赋值）<br>  intVal :=1</li>
</ul>
<p>值类型（int、float、bool 和 string等）值存在栈中,值类型的赋值操作是值引用，相互之间没有影响。<br>引用类型 值存在堆中,引用数据类型的赋值是地址引用，两个变量指向同一个地址，相互之间有影响。</p>
<p>多变量声明：a, b, c := 5, 7, “abc”</p>
<p>交换两个变量的值，则可以简单地使用 a, b = b, a，两个变量的类型必须是相同。</p>
<p>空白标识符 _ 也被用于抛弃值，如值 5 在：_, b = 5, 7 中被抛弃。</p>
<h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>不会被修改的量，数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。</p>
<p>const b string = “abc”</p>
<p>枚举：</p>
<pre><code>const (
    Unknown = 0
    Female = 1
    Male = 2
)
</code></pre>
<p>iota，特殊常量，可以认为是一个可以被编译器修改的常量。<br>a=0, b=1, c=2</p>
<pre><code>const (
    a = iota
    b = iota
    c = iota
)
</code></pre>
<p>可简写为</p>
<pre><code>const (
    a = iota
    b
    c
)
</code></pre>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>定义：</p>
<pre><code>func function_name( [parameter list] ) [return_types] &#123;
函数体
&#125;
</code></pre>
<p>例子：</p>
<pre><code>package main

import &quot;fmt&quot;

func swap(x, y string) (string, string) &#123;
    return y, x
&#125;

func main() &#123;
    a, b := swap(&quot;Google&quot;, &quot;Runoob&quot;)
    fmt.Println(a, b)
&#125;
</code></pre>
<h2 id="函数作为实参"><a href="#函数作为实参" class="headerlink" title="函数作为实参"></a>函数作为实参</h2><pre><code>package main
import (
    &quot;fmt&quot;
    &quot;math&quot;
)
func main()&#123;
    /* 声明函数变量 */
    getSquareRoot := func(x float64) float64 &#123;
        return math.Sqrt(x)
    &#125;

    /* 使用函数 */
    fmt.Println(getSquareRoot(9))
&#125;
</code></pre>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><pre><code>package main
import &quot;fmt&quot;
func getSequence() func() int &#123;
    i:=0
    return func() int &#123;
        i+=1
        return i  
    &#125;
&#125;
func main()&#123;
    /* nextNumber 为一个函数，函数 i 为 0 */
    nextNumber := getSequence()  

    /* 调用 nextNumber 函数，i 变量自增 1 并返回 */
    fmt.Println(nextNumber())
    fmt.Println(nextNumber())
    fmt.Println(nextNumber())
    
    /* 创建新的函数 nextNumber1，并查看结果 */
    nextNumber1 := getSequence()  
    fmt.Println(nextNumber1())
    fmt.Println(nextNumber1())
&#125;
</code></pre>
<h2 id="函数方法"><a href="#函数方法" class="headerlink" title="函数方法"></a>函数方法</h2><pre><code>func (variable_name variable_data_type) function_name() [return_type]&#123;
/* 函数体*/
&#125;
</code></pre>
<p>例子：</p>
<pre><code>package main
import (
&quot;fmt&quot;  
)
/* 定义结构体 */
type Circle struct &#123;
radius float64
&#125;
func main()  &#123; 
    var c Circle
    fmt.Println(c.radius)
    c.radius = 10.00
    fmt.Println(c.getArea())
    c.changeRadius(20)
    fmt.Println(c.radius)
    change(&amp;c, 30)
    fmt.Println(c.radius)
&#125;
func (c Circle) getArea() float64  &#123;
    return c.radius * c.radius
&#125;
// 注意如果想要更改成功c的值，这里需要传指针
func (c *Circle) changeRadius(radius float64)  &#123;
    c.radius = radius
&#125;

// 以下操作将不生效
//func (c Circle) changeRadius(radius float64)  &#123;
//   c.radius = radius
//&#125;
// 引用类型要想改变值需要传指针
func change(c *Circle, radius float64)  &#123;
    c.radius = radius
&#125;
</code></pre>
<h1 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h1><ul>
<li>函数内定义的变量称为局部变量</li>
<li>函数外定义的变量称为全局变量</li>
<li>函数定义中的变量称为形式参数</li>
</ul>
<p>Go 语言程序中全局变量与局部变量名称可以相同，但是函数内的局部变量会被优先考虑</p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>声明:</p>
<pre><code>var variable_name [SIZE] variable_type
var balance [10] float32
</code></pre>
<p>初始化:</p>
<pre><code>balance := [5]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;
</code></pre>
<p>如果数组长度不确定，可以使用 … 代替数组的长度，编译器会根据元素个数自行推断数组的长度：</p>
<pre><code>balance := [...]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;
</code></pre>
<p>如果设置了数组的长度，我们还可以通过指定下标来初始化元素：</p>
<pre><code>//  将索引为 1 和 3 的元素初始化
balance := [5]float32&#123;1:2.0,3:7.0&#125;
</code></pre>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>声明:</p>
<pre><code>var var_name *var-type
var ip *int        /* 指向整型*/
var fp *float32    /* 指向浮点型 */
</code></pre>
<p>指针使用流程：</p>
<ul>
<li>定义指针变量。</li>
<li>为指针变量赋值。</li>
<li>访问指针变量中指向地址的值。<br>在指针类型前面加上 * 号（前缀）来获取指针所指向的内容。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">func main() &#123;</span><br><span class="line">    var a int&#x3D; 20   &#x2F;* 声明实际变量 *&#x2F;</span><br><span class="line">    var ip *int        &#x2F;* 声明指针变量 *&#x2F;</span><br><span class="line">    ip &#x3D; &amp;a  &#x2F;* 指针变量的存储地址 *&#x2F;</span><br><span class="line">    fmt.Printf(&quot;a 变量的地址是: %x\n&quot;, &amp;a  )</span><br><span class="line">    &#x2F;* 指针变量的存储地址 *&#x2F;</span><br><span class="line">    fmt.Printf(&quot;ip 变量储存的指针地址: %x\n&quot;, ip )</span><br><span class="line">    &#x2F;* 使用指针访问值 *&#x2F;</span><br><span class="line">    fmt.Printf(&quot;*ip 变量的值: %d\n&quot;, *ip )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>空指针判断</p>
<pre><code>if(ptr != nil)     /* ptr 不是空指针 */
if(ptr == nil)    /* ptr 是空指针 */
</code></pre>
<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Books <span class="keyword">struct</span> &#123;</span><br><span class="line">   title <span class="keyword">string</span></span><br><span class="line">   author <span class="keyword">string</span></span><br><span class="line">   subject <span class="keyword">string</span></span><br><span class="line">   book_id <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新的结构体</span></span><br><span class="line">    fmt.Println(Books&#123;<span class="string">&quot;Go 语言&quot;</span>, <span class="string">&quot;www.runoob.com&quot;</span>, <span class="string">&quot;Go 语言教程&quot;</span>, <span class="number">6495407</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以使用 key =&gt; value 格式</span></span><br><span class="line">    fmt.Println(Books&#123;title: <span class="string">&quot;Go 语言&quot;</span>, author: <span class="string">&quot;www.runoob.com&quot;</span>, subject: <span class="string">&quot;Go 语言教程&quot;</span>, book_id: <span class="number">6495407</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 忽略的字段为 0 或 空</span></span><br><span class="line">   fmt.Println(Books&#123;title: <span class="string">&quot;Go 语言&quot;</span>, author: <span class="string">&quot;www.runoob.com&quot;</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h1><p>与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。</p>
<p>定义：</p>
<pre><code>var identifier []type
slice1 := make([]type, len)
make([]T, length, capacity)//length 为初始化长度 capacity为最大长度  可选
</code></pre>
<p>初始化：</p>
<pre><code>s :=[] int &#123;1,2,3 &#125; 
</code></pre>
<p>append() 和 copy() 函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> numbers []<span class="keyword">int</span></span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 允许追加空切片 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">0</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 向切片添加一个元素 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">1</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 同时添加多个元素 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 创建切片 numbers1 是之前切片的两倍容量*/</span></span><br><span class="line">   numbers1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(numbers), (<span class="built_in">cap</span>(numbers))*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 拷贝 numbers 的内容到 numbers1 */</span></span><br><span class="line">   <span class="built_in">copy</span>(numbers1,numbers)</span><br><span class="line">   printSlice(numbers1)  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h1><p>Go 语言中 range 关键字用于 for 循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素。在数组和切片中它返回元素的索引和索引对应的值，在集合中返回 key-value 对。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//这是我们使用range去求一个slice的和。使用数组跟这个很类似</span></span><br><span class="line">    nums := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        sum += num</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;sum:&quot;</span>, sum)</span><br><span class="line">    <span class="comment">//在数组上使用range将传入index和值两个变量。上面那个例子我们不需要使用该元素的序号，所以我们使用空白符&quot;_&quot;省略了。有时侯我们确实需要知道它的索引。</span></span><br><span class="line">    <span class="keyword">for</span> i, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">3</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;index:&quot;</span>, i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//range也可以用在map的键值对上。</span></span><br><span class="line">    kvs := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">&quot;a&quot;</span>: <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;b&quot;</span>: <span class="string">&quot;banana&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> kvs &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%s -&gt; %s\n&quot;</span>, k, v)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//range也可以用来枚举Unicode字符串。第一个参数是字符的索引，第二个是字符（Unicode的值）本身。</span></span><br><span class="line">    <span class="keyword">for</span> i, c := <span class="keyword">range</span> <span class="string">&quot;go&quot;</span> &#123;</span><br><span class="line">        fmt.Println(i, c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><pre><code>/* 声明变量，默认 map 是 nil */
riable map[key_data_type]value_data_type
/* 使用 make 函数 */
map_variable := make(map[key_data_type]value_data_type)
var countryCapitalMap map[string]string /*创建集合 */
countryCapitalMap = make(map[string]string)
</code></pre>
<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><pre><code>type_name(expression)
</code></pre>
<p>例子:</p>
<pre><code>var sum int = 17
mean = float32(sum)
</code></pre>
<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><p>goroutine 是 golang 中在语言级别实现的轻量级线程，仅仅利用 go 就能立刻起一个新线程。多线程会引入线程之间的同步问题，在 golang 中可以使用 channel 作为同步的工具。</p>
<p>通过 channel 可以实现两个 goroutine 之间的通信。</p>
<p>goroutine 语法格式：</p>
<pre><code>go 函数名( 参数列表 )
</code></pre>
<p>创建一个 channel， make(chan TYPE {, NUM}) TYPE 指的是 channel 中传输的数据类型，第二个参数是可选的，指的是 channel 的容量大小。</p>
<p>向 channel 传入数据， CHAN &lt;- DATA ， CHAN 指的是目的 channel 即收集数据的一方， DATA 则是要传的数据。</p>
<p>从 channel 读取数据， DATA := &lt;-CHAN ，和向 channel 传入数据相反，在数据输送箭头的右侧的是 channel，形象地展现了数据从隧道流出到变量里。</p>
<p>无缓冲是同步的，例如 make(chan int)，就是一个送信人去你家门口送信，你不在家他不走，你一定要接下信，他才会走，无缓冲保证信能到你手上。</p>
<p>有缓冲是异步的，例如 make(chan int, 1)，就是一个送信人去你家仍到你家的信箱，转身就走，除非你的信箱满了，他必须等信箱空下来，有缓冲的保证信能进你家的邮箱。</p>
<p>关闭通道并不会丢失里面的数据，只是让读取通道数据的时候不会读完之后一直阻塞等待新数据写入</p>
<p>参考链接:<a href="https://www.runoob.com/go/go-tutorial.html" title="https://www.runoob.com/go/go-tutorial.html">https://www.runoob.com/go/go-tutorial.html</a></p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>http与https的区别</title>
    <url>/2021/05/27/http%E4%B8%8Ehttps%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="HTTP存在的问题"><a href="#HTTP存在的问题" class="headerlink" title="HTTP存在的问题"></a>HTTP存在的问题</h1><span id="more"></span>
<ol>
<li>明文传输，可能被窃听</li>
<li>无法确定访问的是真正的目标服务器，服务器可能是伪装的</li>
<li>请求或者响应可能被篡改</li>
</ol>
<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。流程如下：</p>
<ol>
<li>浏览器将自己支持的一套加密规则发送给服务器。</li>
<li>服务器从浏览器的加密规则中选出一组加密算法与HASH算法，并将自己的身份信息（公钥）以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。</li>
<li>浏览器验证证书的合法性，若合法，或者用户接受了不受信的证书，浏览器生成随机密码，用公钥加密，发给服务端。</li>
<li>服务端解密密码，验证HASH是否一致。若一致，服务端用密码加密一段握手消息，发送给客户端。</li>
<li>浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束。之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。</li>
</ol>
<p>浏览器与服务器互相发送加密的握手消息并验证，目的是为了保证双方都获得了一致的密码，并且可以正常的加密解密数据，为后续真正数据的传输做一次测试。</p>
<h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>客户端和服务器共用同一个密钥，该密钥可以用于加密一段内容，同时也可以用于解密这段内容。</p>
<p>优点：效率高<br>缺点：密钥可能被窃取，安全性差</p>
<h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>密钥分成了两种：公钥和私钥。公钥通常存放在客户端，私钥通常存放在服务器。使用公钥加密的数据只有用私钥才能解密，反过来使用私钥加密的数据也只有用公钥才能解密。</p>
<p>优点：安全性高<br>缺点：效率差</p>
<h2 id="为什么使用非对称加密"><a href="#为什么使用非对称加密" class="headerlink" title="为什么使用非对称加密"></a>为什么使用非对称加密</h2><p>保证对称加密的密钥的安全性。</p>
<h2 id="HTTPS工作中啥时候是非对称加密，啥时候是对称加密？"><a href="#HTTPS工作中啥时候是非对称加密，啥时候是对称加密？" class="headerlink" title="HTTPS工作中啥时候是非对称加密，啥时候是对称加密？"></a>HTTPS工作中啥时候是非对称加密，啥时候是对称加密？</h2><p>在交换密钥环节使用非对称加密方式，之后全部使用对称加密。</p>
<h1 id="简单讲解一下http2的多路复用"><a href="#简单讲解一下http2的多路复用" class="headerlink" title="简单讲解一下http2的多路复用"></a>简单讲解一下http2的多路复用</h1><p>HTTP/2 复用 TCP 连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应。</p>
<ol>
<li><p>http/1.0：如需要发送多个请求必须创建多个 TCP 连接，并且浏览器对于单域名请求有数量限制（一般6个），其连接无法被复用</p>
</li>
<li><p>http/1.1：引入流水线（Pipelining）技术，但先天 FIFO（先进先出）机制导致当前请求的执行依赖于上一个请求执行的完成，容易引起报头阻塞，并没有从根本上解决问题</p>
</li>
<li><p>http/2：重新定义底层 http 语义映射，允许同一个连接上使用请求和响应双向数据流。同一域名只需占用一个 TCP 连接，通过数据流（Stream）以帧为基本协议单位，从根本上解决了问题，避免了因频繁创建连接产生的延迟，减少了内存消耗，提升了使用性能</p>
</li>
</ol>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>js事件循环</title>
    <url>/2021/04/14/js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<h1 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h1><p>多任务：简单地说，就是操作系统可以同时运行多个任务。打个比方，你一边在用浏览器上网，一边在听MP3，一边在用Word赶作业，这就是多任务，至少同时有3个任务正在运行。还有很多任务悄悄地在后台同时运行着，只是桌面上没有显示而已。</p>
<p>对于操作系统来说，一个任务就是一个进程（Process），比如打开一个浏览器就是启动一个浏览器进程，打开一个记事本就启动了一个记事本进程，打开两个记事本就启动了两个记事本进程，打开一个Word就启动了一个Word进程。</p>
<p>有些进程还不止同时干一件事，比如Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）。</p>
<p>以Chrome浏览器中为例，当你打开一个 Tab 页时，其实就是创建了一个进程，一个进程中可以有多个线程（下文会详细介绍），比如渲染线程、JS 引擎线程、HTTP 请求线程等等。当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁。</p>
<span id="more"></span>

<h1 id="浏览器中的事件循环"><a href="#浏览器中的事件循环" class="headerlink" title="浏览器中的事件循环"></a>浏览器中的事件循环</h1><h2 id="Micro-Task-与-Macro-Task"><a href="#Micro-Task-与-Macro-Task" class="headerlink" title="Micro-Task 与 Macro-Task"></a>Micro-Task 与 Macro-Task</h2><p>浏览器端事件循环中的异步队列有两种:macro（宏任务）队列和 micro（微任务）队列。</p>
<ul>
<li>macro-task：setTimeout、setInterval、script（整体代码）、 I/O 操作、UI 渲染等</li>
<li>micro-task：process.nextTick、new Promise().then(回调)、MutationObserver(html5新特性) 、Async/Await(实际就是promise)等。</li>
</ul>
<p>每一次Event Loop触发时：</p>
<ol>
<li>执行完主执行线程中的任务也就是执行第一个macro-task任务，例如script任务。</li>
<li>取出micro-task中任务执行直到清空。</li>
<li>取出macro-task中一个任务执行。</li>
<li>取出micro-task中任务执行直到清空。</li>
<li>重复3和4。</li>
</ol>
<p>promise的then和catch才是microtask，本身的内部代码不是。</p>
<h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  宏任务队列.shift()</span><br><span class="line">  微任务队列全部任务()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="例子1："><a href="#例子1：" class="headerlink" title="例子1："></a>例子1：</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;global&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>;i &lt;= <span class="number">5</span>;i ++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;,i*<span class="number">1000</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">  resolve()</span><br><span class="line"> &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;then1&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;timeout2&#x27;</span>)</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;timeout2_promise&#x27;</span>)</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;timeout2_then&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">global</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">promise1</span><br><span class="line">then1</span><br><span class="line">6</span><br><span class="line">timeout2</span><br><span class="line">timeout2_promise</span><br><span class="line">timeout2_then</span><br><span class="line">6</span><br><span class="line">6</span><br><span class="line">6</span><br><span class="line">6</span><br></pre></td></tr></table></figure>
<h2 id="例子2："><a href="#例子2：" class="headerlink" title="例子2："></a>例子2：</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">new</span> <span class="built_in">Date</span>() - startTime &lt; time) &#123;&#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;1s over&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout - 1&#x27;</span>)</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout - 1 - 1&#x27;</span>)</span><br><span class="line">      sleep(<span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve()).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout - 1 - then&#x27;</span>)</span><br><span class="line">      <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve()).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout - 1 - then - then&#x27;</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  sleep(<span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout - 2&#x27;</span>)</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout - 2 - 1&#x27;</span>)</span><br><span class="line">      sleep(<span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve()).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout - 2 - then&#x27;</span>)</span><br><span class="line">      <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve()).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout - 2 - then - then&#x27;</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  sleep(<span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setTimeout - 1</span><br><span class="line">1s over</span><br><span class="line">setTimeout - 1 - then</span><br><span class="line">setTimeout - 1 - then - then</span><br><span class="line">setTimeout - 2</span><br><span class="line">1s over</span><br><span class="line">setTimeout - 2 - then</span><br><span class="line">setTimeout - 2 - then - then</span><br><span class="line">setTimeout - 1 - 1</span><br><span class="line">1s over</span><br><span class="line">setTimeout - 2 - 1</span><br><span class="line">1s over</span><br></pre></td></tr></table></figure>

<h2 id="await做了什么"><a href="#await做了什么" class="headerlink" title="await做了什么"></a>await做了什么</h2><p>从字面意思上看await就是等待，await 等待的是一个表达式，这个表达式的返回值可以是一个promise对象也可以是其他值。</p>
<p>很多人以为await会一直等待之后的表达式执行完之后才会继续执行后面的代码，实际上await是一个让出线程的标志。await后面的表达式会先执行一遍，将await后面的代码加入到microtask中，然后就会跳出整个async函数来执行后面的代码。</p>
<p>由于因为async await 本身就是promise+generator的语法糖。所以await后面的代码是microtask</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;async1 start&#x27;</span>);</span><br><span class="line">	<span class="keyword">await</span> async2();</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;async1 start&#x27;</span>);</span><br><span class="line">	<span class="built_in">Promise</span>.resolve(async2()).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="例子3："><a href="#例子3：" class="headerlink" title="例子3："></a>例子3：</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//请写出输出内容</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async1 start&#x27;</span>);</span><br><span class="line">    <span class="keyword">await</span> async2();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;async2&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">async1();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">script start</span></span><br><span class="line"><span class="comment">async1 start</span></span><br><span class="line"><span class="comment">async2</span></span><br><span class="line"><span class="comment">promise1</span></span><br><span class="line"><span class="comment">script end</span></span><br><span class="line"><span class="comment">async1 end</span></span><br><span class="line"><span class="comment">promise2</span></span><br><span class="line"><span class="comment">setTimeout</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h1 id="node-中的事件循环"><a href="#node-中的事件循环" class="headerlink" title="node 中的事件循环"></a>node 中的事件循环</h1>]]></content>
      <categories>
        <category>javascript基础</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>typescript</title>
    <url>/2021/05/13/typescript/</url>
    <content><![CDATA[<p>typescript学习笔记。</p>
<span id="more"></span>
<h1 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h1><p>布尔值、数字、字符串、数组</p>
<h2 id="元组-Tuple"><a href="#元组-Tuple" class="headerlink" title="元组 Tuple"></a>元组 Tuple</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line"><span class="comment">// Initialize it</span></span><br><span class="line">x = [<span class="string">&#x27;hello&#x27;</span>, <span class="number">10</span>]; <span class="comment">// OK</span></span><br><span class="line"><span class="comment">// Initialize it incorrectly</span></span><br><span class="line">x = [<span class="number">10</span>, <span class="string">&#x27;hello&#x27;</span>]; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> Color &#123;Red, Green, Blue&#125;</span><br><span class="line"><span class="keyword">let</span> c: Color = Color.Green;</span><br></pre></td></tr></table></figure>
<h2 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h2><p>为那些在编程阶段还不清楚类型的变量指定一个类型时，可以使用any</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> notSure: <span class="built_in">any</span> = <span class="number">4</span>;</span><br><span class="line">notSure = <span class="string">&quot;maybe a string instead&quot;</span>;</span><br><span class="line">notSure = <span class="literal">false</span>; <span class="comment">// okay, definitely a boolean</span></span><br></pre></td></tr></table></figure>
<p>与Object的区别：Object类型的变量只是允许你给它赋任意值 - 但是却不能够在它上面调用任意的方法，即便它真的有这些方法</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> notSure: <span class="built_in">any</span> = <span class="number">4</span>;</span><br><span class="line">notSure.ifItExists(); <span class="comment">// okay, ifItExists might exist at runtime</span></span><br><span class="line">notSure.toFixed(); <span class="comment">// okay, toFixed exists (but the compiler doesn&#x27;t check)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> prettySure: <span class="built_in">Object</span> = <span class="number">4</span>;</span><br><span class="line">prettySure.toFixed(); <span class="comment">// Error: Property &#x27;toFixed&#x27; doesn&#x27;t exist on type &#x27;Object&#x27;.</span></span><br></pre></td></tr></table></figure>
<h2 id="Void"><a href="#Void" class="headerlink" title="Void"></a>Void</h2><p>void类型像是与any类型相反，它表示没有任何类型。当一个函数没有返回值时，你通常会见到其返回值类型是 void：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">warnUser</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;This is my warning message&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Null-和-Undefined"><a href="#Null-和-Undefined" class="headerlink" title="Null 和 Undefined"></a>Null 和 Undefined</h2><p>undefined和null两者各自有自己的类型分别叫做undefined和null</p>
<h2 id="Never"><a href="#Never" class="headerlink" title="Never"></a>Never</h2><p>never类型表示的是那些永不存在的值的类型。没有类型是never的子类型或可以赋值给never类型（除了never本身之外）。<br>never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p>object表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型。</p>
<h2 id="类型断言-类型转换"><a href="#类型断言-类型转换" class="headerlink" title="类型断言(类型转换)"></a>类型断言(类型转换)</h2><p>“尖括号”语法：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: <span class="built_in">any</span> = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someValue).length;</span><br></pre></td></tr></table></figure>
<p>as语法：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: <span class="built_in">any</span> = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (someValue <span class="keyword">as</span> <span class="built_in">string</span>).length;</span><br></pre></td></tr></table></figure>
<p>TypeScript里使用JSX时，只有 as语法断言是被允许的</p>
<h1 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h1><p>let const</p>
<h2 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h2><h3 id="解构数组"><a href="#解构数组" class="headerlink" title="解构数组"></a>解构数组</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> input = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> [first, second] = input;</span><br><span class="line"><span class="built_in">console</span>.log(first); <span class="comment">// outputs 1</span></span><br><span class="line"><span class="built_in">console</span>.log(second); <span class="comment">// outputs 2</span></span><br><span class="line"><span class="comment">//交换变量</span></span><br><span class="line">[first, second] = [second, first];</span><br></pre></td></tr></table></figure>
<h3 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">    a: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">    b: <span class="number">12</span>,</span><br><span class="line">    c: <span class="string">&quot;bar&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; a, b &#125; = o;</span><br></pre></td></tr></table></figure>
<h3 id="属性重命名"><a href="#属性重命名" class="headerlink" title="属性重命名"></a>属性重命名</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">a</span>: newName1, <span class="attr">b</span>: newName2 &#125; = o;</span><br></pre></td></tr></table></figure>
<h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">keepWholeObject</span>(<span class="params">wholeObject: &#123; a: <span class="built_in">string</span>, b?: <span class="built_in">number</span> &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; a, b = <span class="number">1001</span> &#125; = wholeObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="展开"><a href="#展开" class="headerlink" title="展开"></a>展开</h3><p>展开操作符正与解构相反。 它允许你将一个数组展开为另一个数组，或将一个对象展开为另一个对象。 例如：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> first = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> second = [<span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> bothPlus = [<span class="number">0</span>, ...first, ...second, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> defaults = &#123; <span class="attr">food</span>: <span class="string">&quot;spicy&quot;</span>, <span class="attr">price</span>: <span class="string">&quot;$$&quot;</span>, <span class="attr">ambiance</span>: <span class="string">&quot;noisy&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> search = &#123; ...defaults, <span class="attr">food</span>: <span class="string">&quot;rich&quot;</span> &#125;;</span><br></pre></td></tr></table></figure>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> LabelledValue &#123;</span><br><span class="line">  label: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printLabel</span>(<span class="params">labelledObj: LabelledValue</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(labelledObj.label);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myObj = &#123;<span class="attr">size</span>: <span class="number">10</span>, <span class="attr">label</span>: <span class="string">&quot;Size 10 Object&quot;</span>&#125;;</span><br><span class="line">printLabel(myObj);</span><br></pre></td></tr></table></figure>
<p>LabelledValue接口就好比一个名字，用来描述上面例子里的要求。 它代表了有一个 label属性且类型为string的对象。<br>只会去关注值的外形。 只要传入的对象满足上面提到的必要条件，那么它就是被允许的。<br>不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。</p>
<h2 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h2><p>在可选属性名字定义的后面加一个?符号。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> SquareConfig &#123;</span><br><span class="line">  color?: <span class="built_in">string</span>;</span><br><span class="line">  width?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">    <span class="keyword">readonly</span> x: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">readonly</span> y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1: Point = &#123; <span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">20</span> &#125;;</span><br><span class="line">p1.x = <span class="number">5</span>; <span class="comment">// error!</span></span><br></pre></td></tr></table></figure>
<p>ReadonlyArray<T>类型，与Array<T>相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> ro: ReadonlyArray&lt;<span class="built_in">number</span>&gt; = a;</span><br><span class="line">ro[<span class="number">0</span>] = <span class="number">12</span>; <span class="comment">// error!</span></span><br><span class="line">ro.push(<span class="number">5</span>); <span class="comment">// error!</span></span><br><span class="line">ro.length = <span class="number">100</span>; <span class="comment">// error!</span></span><br><span class="line">a = ro; <span class="comment">// error!</span></span><br></pre></td></tr></table></figure>
<h2 id="额外的属性检查"><a href="#额外的属性检查" class="headerlink" title="额外的属性检查"></a>额外的属性检查</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> SquareConfig &#123;</span><br><span class="line">    color?: <span class="built_in">string</span>;</span><br><span class="line">    width?: <span class="built_in">number</span>;</span><br><span class="line">    [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>;<span class="comment">//可以有任意数量的属性，并且只要它们不是color和width，那么就无所谓它们的类型是什么。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> SearchFunc &#123;</span><br><span class="line">  (source: <span class="built_in">string</span>, <span class="attr">subString</span>: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySearch: SearchFunc;</span><br><span class="line">mySearch = <span class="function"><span class="keyword">function</span>(<span class="params">source: <span class="built_in">string</span>, subString: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = source.search(subString);</span><br><span class="line">  <span class="keyword">return</span> result &gt; -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数的参数名不需要与接口里定义的名字相匹配,只要求对应位置上的参数类型是兼容的。</p>
<h2 id="可索引的类型"><a href="#可索引的类型" class="headerlink" title="可索引的类型"></a>可索引的类型</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> StringArray &#123;</span><br><span class="line">  [index: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myArray: StringArray;</span><br><span class="line">myArray = [<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Fred&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myStr: <span class="built_in">string</span> = myArray[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<h2 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h2><p>TypeScript能够用它来明确的强制一个类去符合某种契约。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> ClockInterface &#123;</span><br><span class="line">    currentTime: <span class="built_in">Date</span>;</span><br><span class="line">    setTime(d: <span class="built_in">Date</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="title">implements</span> <span class="title">ClockInterface</span> </span>&#123;</span><br><span class="line">    currentTime: <span class="built_in">Date</span>;</span><br><span class="line">    <span class="function"><span class="title">setTime</span>(<span class="params">d: <span class="built_in">Date</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.currentTime = d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个类实现了一个接口时，只对其实例部分进行类型检查。 </p>
<h2 id="继承接口"><a href="#继承接口" class="headerlink" title="继承接口"></a>继承接口</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Shape &#123;</span><br><span class="line">    color: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> PenStroke &#123;</span><br><span class="line">    penWidth: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Square <span class="keyword">extends</span> Shape, PenStroke &#123;</span><br><span class="line">    sideLength: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> square = &lt;Square&gt;&#123;&#125;;</span><br><span class="line">square.color = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line">square.sideLength = <span class="number">10</span>;</span><br><span class="line">square.penWidth = <span class="number">5.0</span>;</span><br></pre></td></tr></table></figure>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeter</span> </span>&#123;</span><br><span class="line">    greeting: <span class="built_in">string</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">message: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.greeting = message;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">greet</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + <span class="built_in">this</span>.greeting;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> greeter = <span class="keyword">new</span> Greeter(<span class="string">&quot;world&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>)</span> &#123; <span class="built_in">this</span>.name = theName; &#125;</span><br><span class="line">    <span class="function"><span class="title">move</span>(<span class="params">distanceInMeters: <span class="built_in">number</span> = <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> moved <span class="subst">$&#123;distanceInMeters&#125;</span>m.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Snake</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span> &#123; <span class="built_in">super</span>(name); &#125;</span><br><span class="line">    <span class="function"><span class="title">move</span>(<span class="params">distanceInMeters = <span class="number">5</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Slithering...&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.move(distanceInMeters);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Horse</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span> &#123; <span class="built_in">super</span>(name); &#125;</span><br><span class="line">    <span class="function"><span class="title">move</span>(<span class="params">distanceInMeters = <span class="number">45</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Galloping...&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.move(distanceInMeters);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sam = <span class="keyword">new</span> Snake(<span class="string">&quot;Sammy the Python&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> tom: Animal = <span class="keyword">new</span> Horse(<span class="string">&quot;Tommy the Palomino&quot;</span>);</span><br><span class="line"></span><br><span class="line">sam.move();</span><br><span class="line">tom.move(<span class="number">34</span>);</span><br></pre></td></tr></table></figure>
<p>通过 extends关键字实现继承。<br>派生类包含了一个构造函数，它 必须调用 super()，它会执行基类的构造函数。 而且，在构造函数里访问 this的属性之前，我们 一定要调用 super()。 这个是TypeScript强制执行的一条重要规则。</p>
<h2 id="公共，私有与受保护的修饰符"><a href="#公共，私有与受保护的修饰符" class="headerlink" title="公共，私有与受保护的修饰符"></a>公共，私有与受保护的修饰符</h2><ol>
<li>默认为 public</li>
<li>private： 不能在声明它的类的外部访问</li>
<li>protected： 不能在声明它的类的外部访问，但能在派生类中仍然可以访问</li>
<li>readonly：将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。<h2 id="参数属性"><a href="#参数属性" class="headerlink" title="参数属性"></a>参数属性</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Octopus</span> </span>&#123;</span><br><span class="line">    <span class="keyword">readonly</span> name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">readonly</span> numberOfLegs: <span class="built_in">number</span> = <span class="number">8</span>;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params">theName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = theName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Octopus</span> </span>&#123;</span><br><span class="line">    <span class="keyword">readonly</span> numberOfLegs: <span class="built_in">number</span> = <span class="number">8</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">readonly</span> name: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在构造函数里使用 readonly name: string参数来创建和初始化 name成员。 我们把声明和赋值合并至一处。<br>参数属性通过给构造函数参数前面添加一个访问限定符来声明。 使用 private限定一个参数属性会声明并初始化一个私有成员；对于 public和 protected来说也是一样。<h2 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h2></li>
</ol>
<p>支持通过getters/setters来截取对对象成员的访问。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> passcode = <span class="string">&quot;secret passcode&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> _fullName: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> <span class="title">fullName</span>(): <span class="title">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._fullName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> <span class="title">fullName</span>(<span class="params">newName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (passcode &amp;&amp; passcode == <span class="string">&quot;secret passcode&quot;</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>._fullName = newName;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;Error: Unauthorized update of employee!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> Employee();</span><br><span class="line">employee.fullName = <span class="string">&quot;Bob Smith&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (employee.fullName) &#123;</span><br><span class="line">    alert(employee.fullName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h2><p>静态属性存在于类本身上面而不是类的实例上。static关键字</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grid</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> origin = &#123;<span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="function"><span class="title">calculateDistanceFromOrigin</span>(<span class="params">point: &#123;x: <span class="built_in">number</span>; y: <span class="built_in">number</span>;&#125;</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> xDist = (point.x - Grid.origin.x);</span><br><span class="line">        <span class="keyword">let</span> yDist = (point.y - Grid.origin.y);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(xDist * xDist + yDist * yDist) / <span class="built_in">this</span>.scale;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params"><span class="keyword">public</span> scale: <span class="built_in">number</span></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> grid1 = <span class="keyword">new</span> Grid(<span class="number">1.0</span>);  <span class="comment">// 1x scale</span></span><br><span class="line"><span class="keyword">let</span> grid2 = <span class="keyword">new</span> Grid(<span class="number">5.0</span>);  <span class="comment">// 5x scale</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(grid1.calculateDistanceFromOrigin(&#123;<span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">10</span>&#125;));</span><br><span class="line"><span class="built_in">console</span>.log(grid2.calculateDistanceFromOrigin(&#123;<span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">10</span>&#125;));</span><br></pre></td></tr></table></figure>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>abstract关键字。<br>抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。<br>抽象方法必须包含 abstract关键字并且可以包含访问修饰符。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printName(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Department name: &#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> printMeeting(): <span class="built_in">void</span>; <span class="comment">// 必须在派生类中实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountingDepartment</span> <span class="keyword">extends</span> <span class="title">Department</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&#x27;Accounting and Auditing&#x27;</span>); <span class="comment">// 在派生类的构造函数中必须调用 super()</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printMeeting(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;The Accounting Department meets each Monday at 10am.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    generateReports(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Generating accounting reports...&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> department: Department; <span class="comment">// 允许创建一个对抽象类型的引用</span></span><br><span class="line">department = <span class="keyword">new</span> Department(); <span class="comment">// 错误: 不能创建一个抽象类的实例</span></span><br><span class="line">department = <span class="keyword">new</span> AccountingDepartment(); <span class="comment">// 允许对一个抽象子类进行实例化和赋值</span></span><br><span class="line">department.printName();</span><br><span class="line">department.printMeeting();</span><br><span class="line">department.generateReports(); <span class="comment">// 错误: 方法在声明的抽象类中不存在</span></span><br></pre></td></tr></table></figure>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="为函数定义类型"><a href="#为函数定义类型" class="headerlink" title="为函数定义类型"></a>为函数定义类型</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myAdd = <span class="function"><span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//完整函数类型</span></span><br><span class="line"><span class="keyword">let</span> myAdd: <span class="function">(<span class="params">baseValue: <span class="built_in">number</span>, increment: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> =</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;;</span><br></pre></td></tr></table></figure>
<h2 id="推断类型"><a href="#推断类型" class="headerlink" title="推断类型"></a>推断类型</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myAdd = <span class="function"><span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The parameters `x` and `y` have the type number</span></span><br><span class="line"><span class="keyword">let</span> myAdd: <span class="function">(<span class="params">baseValue: <span class="built_in">number</span>, increment: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> =</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123; <span class="keyword">return</span> x + y; &#125;;</span><br></pre></td></tr></table></figure>
<h2 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h2><p>在参数名旁使用 ?实现可选参数的功能。可选参数必须跟在必须参数后面。 </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName?: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lastName)</span><br><span class="line">        <span class="keyword">return</span> firstName + <span class="string">&quot; &quot;</span> + lastName;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> firstName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result1 = buildName(<span class="string">&quot;Bob&quot;</span>);  <span class="comment">// works correctly now</span></span><br><span class="line"><span class="keyword">let</span> result2 = buildName(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Adams&quot;</span>, <span class="string">&quot;Sr.&quot;</span>);  <span class="comment">// error, too many parameters</span></span><br><span class="line"><span class="keyword">let</span> result3 = buildName(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Adams&quot;</span>);  <span class="comment">// ah, just right</span></span><br></pre></td></tr></table></figure>
<h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName = <span class="string">&quot;Smith&quot;</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + <span class="string">&quot; &quot;</span> + lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result1 = buildName(<span class="string">&quot;Bob&quot;</span>);                  <span class="comment">// works correctly now, returns &quot;Bob Smith&quot;</span></span><br><span class="line"><span class="keyword">let</span> result2 = buildName(<span class="string">&quot;Bob&quot;</span>, <span class="literal">undefined</span>);       <span class="comment">// still works, also returns &quot;Bob Smith&quot;</span></span><br><span class="line"><span class="keyword">let</span> result3 = buildName(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Adams&quot;</span>, <span class="string">&quot;Sr.&quot;</span>);  <span class="comment">// error, too many parameters</span></span><br><span class="line"><span class="keyword">let</span> result4 = buildName(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Adams&quot;</span>);  </span><br></pre></td></tr></table></figure>
<h2 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, ...restOfName: <span class="built_in">string</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> firstName + <span class="string">&quot; &quot;</span> + restOfName.join(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> buildNameFun: <span class="function">(<span class="params">fname: <span class="built_in">string</span>, ...rest: <span class="built_in">string</span>[]</span>) =&gt;</span> <span class="built_in">string</span> = buildName;</span><br></pre></td></tr></table></figure>

<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>函数名相同,根据传入不同的参数而实现不同的功能。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> suits = [<span class="string">&quot;hearts&quot;</span>, <span class="string">&quot;spades&quot;</span>, <span class="string">&quot;clubs&quot;</span>, <span class="string">&quot;diamonds&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickCard</span>(<span class="params">x: &#123;suit: <span class="built_in">string</span>; card: <span class="built_in">number</span>; &#125;[]</span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickCard</span>(<span class="params">x: <span class="built_in">number</span></span>): </span>&#123;suit: <span class="built_in">string</span>; card: <span class="built_in">number</span>; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickCard</span>(<span class="params">x</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Check to see if we&#x27;re working with an object/array</span></span><br><span class="line">    <span class="comment">// if so, they gave us the deck and we&#x27;ll pick the card</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x == <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> pickedCard = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * x.length);</span><br><span class="line">        <span class="keyword">return</span> pickedCard;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Otherwise just let them pick the card</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x == <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> pickedSuit = <span class="built_in">Math</span>.floor(x / <span class="number">13</span>);</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">suit</span>: suits[pickedSuit], <span class="attr">card</span>: x % <span class="number">13</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myDeck = [&#123; <span class="attr">suit</span>: <span class="string">&quot;diamonds&quot;</span>, <span class="attr">card</span>: <span class="number">2</span> &#125;, &#123; <span class="attr">suit</span>: <span class="string">&quot;spades&quot;</span>, <span class="attr">card</span>: <span class="number">10</span> &#125;, &#123; <span class="attr">suit</span>: <span class="string">&quot;hearts&quot;</span>, <span class="attr">card</span>: <span class="number">4</span> &#125;];</span><br><span class="line"><span class="keyword">let</span> pickedCard1 = myDeck[pickCard(myDeck)];</span><br><span class="line">alert(<span class="string">&quot;card: &quot;</span> + pickedCard1.card + <span class="string">&quot; of &quot;</span> + pickedCard1.suit);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pickedCard2 = pickCard(<span class="number">15</span>);</span><br><span class="line">alert(<span class="string">&quot;card: &quot;</span> + pickedCard2.card + <span class="string">&quot; of &quot;</span> + pickedCard2.suit);</span><br></pre></td></tr></table></figure>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>泛型类使用（ &lt;&gt;）括起泛型类型，跟在类名后面。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericNumber</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    zeroValue: T;</span><br><span class="line">    add: <span class="function">(<span class="params">x: T, y: T</span>) =&gt;</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myGenericNumber = <span class="keyword">new</span> GenericNumber&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line">myGenericNumber.zeroValue = <span class="number">0</span>;</span><br><span class="line">myGenericNumber.add = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123; <span class="keyword">return</span> x + y; &#125;;</span><br></pre></td></tr></table></figure>
<h2 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Lengthwise &#123;</span><br><span class="line">    length: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Lengthwise</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length);  <span class="comment">// Now we know it has a .length property, so no more error</span></span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="枚举-1"><a href="#枚举-1" class="headerlink" title="枚举"></a>枚举</h1><h2 id="数字枚举"><a href="#数字枚举" class="headerlink" title="数字枚举"></a>数字枚举</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> Direction &#123;</span><br><span class="line">    Up = <span class="number">1</span>,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串枚举"><a href="#字符串枚举" class="headerlink" title="字符串枚举"></a>字符串枚举</h2><p>每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> Direction &#123;</span><br><span class="line">    Up = <span class="string">&quot;UP&quot;</span>,</span><br><span class="line">    Down = <span class="string">&quot;DOWN&quot;</span>,</span><br><span class="line">    Left = <span class="string">&quot;LEFT&quot;</span>,</span><br><span class="line">    Right = <span class="string">&quot;RIGHT&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack</title>
    <url>/2021/05/10/webpack/</url>
    <content><![CDATA[<h1 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h1>]]></content>
  </entry>
  <entry>
    <title>倒计时时间偏差问题</title>
    <url>/2021/08/30/%E5%80%92%E8%AE%A1%E6%97%B6%E6%97%B6%E9%97%B4%E5%81%8F%E5%B7%AE%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>在前端实现中一般会通过 setTimeout 和 setInterval 方法来实现一个倒计时效果。但是使用这些方法会存在时间偏差的问题，这是由于 js 的程序执行机制造成的，setTimeout 和 setInterval 的作用是隔一段时间将回调事件加入到事件队列中，因此事件并不是立即执行的，它会等到当前执行栈为空的时候再取出事件执行，因此事件等待执行的时间就是造成误差的原因。<span id="more"></span></p>
<p>解决方法：</p>
<ol>
<li><p>通过前端定时向服务器发送请求获取最新的时间差，以此来校准倒计时时间。但是这样会存在一个很大的问题，那就是每隔一秒去请求服务器，这样如果用户多了，服务器就会崩溃(内存占用率很大).</p>
</li>
<li><p>前端根据偏差时间来自动调整间隔时间。首先是以 setTimeout 递归的方式来实现倒计时，然后通过一个变量来记录已经倒计时的秒数。每一次函数调用的时候，首先将变量加一，然后根据这个变量和每次的间隔时间，我们就可以计算出此时无偏差时应该显示的时间。然后将当前的真实时间与这个时间相减，这样我们就可以得到时间的偏差大小，因此我们在设置下一个定时器的间隔大小的时候，我们就从间隔时间中减去这个偏差大小，以此来实现由于程序执行所造成的时间误差的纠正。</p>
</li>
</ol>
<p>实现方法:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> interval = <span class="number">1000</span>;</span><br><span class="line"><span class="comment">// 从服务器和活动开始时间计算出的时间差，这里测试用 50000 ms</span></span><br><span class="line"><span class="keyword">let</span> ms = <span class="number">50000</span>;</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line"><span class="keyword">let</span> timeCounter;</span><br><span class="line"><span class="keyword">if</span> (ms &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">  timerCounter = <span class="built_in">setTimeout</span>(countDownStart, interval);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countDownStart</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  count++;</span><br><span class="line">  <span class="keyword">const</span> offset = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() - (startTime + count * interval);<span class="comment">//时间误差</span></span><br><span class="line">  <span class="keyword">let</span> nextTime = interval - offset;</span><br><span class="line">  <span class="keyword">if</span> (nextTime &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    nextTime = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ms -= interval;</span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    <span class="string">`误差：<span class="subst">$&#123;offset&#125;</span> ms，下一次执行：<span class="subst">$&#123;nextTime&#125;</span> ms 后，离活动开始还有：<span class="subst">$&#123;ms&#125;</span> ms`</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span> (ms &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeCounter);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    timeCounter = <span class="built_in">setTimeout</span>(countDownStart, nextTime);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>javascript基础</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>前端安全</title>
    <url>/2021/08/30/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<p>前端安全问题<span id="more"></span></p>
<h1 id="xss"><a href="#xss" class="headerlink" title="xss"></a>xss</h1><p>Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。</p>
<h2 id="XSS-分类"><a href="#XSS-分类" class="headerlink" title="XSS 分类"></a>XSS 分类</h2><h3 id="存储型"><a href="#存储型" class="headerlink" title="存储型"></a>存储型</h3><p>攻击者将恶意代码提交到目标网站的数据库中。<br>用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。<br>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</p>
<p>常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。</p>
<h3 id="反射型"><a href="#反射型" class="headerlink" title="反射型"></a>反射型</h3><p>攻击者构造出特殊的 URL，其中包含恶意代码。<br>用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。<br>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</p>
<p>反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。</p>
<h3 id="DOM型"><a href="#DOM型" class="headerlink" title="DOM型"></a>DOM型</h3><p>攻击者构造出特殊的 URL，其中包含恶意代码。<br>用户打开带有恶意代码的 URL。<br>用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。</p>
<p>DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。</p>
<h2 id="XSS-攻击的预防"><a href="#XSS-攻击的预防" class="headerlink" title="XSS 攻击的预防"></a>XSS 攻击的预防</h2><h3 id="输入过滤"><a href="#输入过滤" class="headerlink" title="输入过滤"></a>输入过滤</h3><h3 id="预防存储型和反射型-XSS-攻击"><a href="#预防存储型和反射型-XSS-攻击" class="headerlink" title="预防存储型和反射型 XSS 攻击"></a>预防存储型和反射型 XSS 攻击</h3><p>充分转义</p>
<h3 id="预防-DOM-型-XSS-攻击"><a href="#预防-DOM-型-XSS-攻击" class="headerlink" title="预防 DOM 型 XSS 攻击"></a>预防 DOM 型 XSS 攻击</h3><p>DOM 型 XSS 攻击，实际上就是网站前端 JavaScript 代码本身不够严谨，把不可信的数据当作代码执行了。</p>
<p>在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等。</p>
<p>如果用 Vue/React 技术栈，并且不使用 v-html/dangerouslySetInnerHTML 功能，就在前端 render 阶段避免 innerHTML、outerHTML 的 XSS 隐患。</p>
<p>DOM 中的内联事件监听器，如 location、onclick、onerror、onload、onmouseover 等，<a> 标签的 href 属性，JavaScript 的 eval()、setTimeout()、setInterval() 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免</p>
<h3 id="其他-XSS-防范措施"><a href="#其他-XSS-防范措施" class="headerlink" title="其他 XSS 防范措施"></a>其他 XSS 防范措施</h3><p>Content Security Policy:CSP 的实质就是白名单制度，开发者明确告诉客户端，哪些外部资源可以加载和执行，等同于提供白名单。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Security-Policy: script-src &#39;self&#39;; object-src &#39;none&#39;;</span><br><span class="line">style-src cdn.example.org third-party.org; child-src https:</span><br></pre></td></tr></table></figure>

<p>脚本：只信任当前域名<br>&lt;object&gt;标签：不信任任何URL，即不加载任何资源<br>样式表：只信任cdn.example.org和third-party.org<br>框架（frame）：必须使用HTTPS协议加载<br>其他资源：没有限制</p>
<p>输入内容长度控制</p>
<p>HTTP-only Cookie</p>
<p>验证码</p>
<h1 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h1><p>CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。(冒用cookie)</p>
<h2 id="一般流程："><a href="#一般流程：" class="headerlink" title="一般流程："></a>一般流程：</h2><ol>
<li>受害者登录a.com，并保留了登录凭证（Cookie）。</li>
<li>攻击者引诱受害者访问了b.com。</li>
<li>b.com 向 a.com 发送了一个请求：a.com/act=xx。</li>
<li>a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。</li>
<li>a.com以受害者的名义执行了act=xx。</li>
<li>攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作。</li>
</ol>
<h2 id="防护策略"><a href="#防护策略" class="headerlink" title="防护策略"></a>防护策略</h2><ol>
<li><p>阻止不明外域的访问:</p>
<p> 同源检测(Origin 和 Referer 验证)<br> Samesite Cookie</p>
</li>
<li><p>提交时要求附加本域才能获取的信息:</p>
<p> CSRF Token(将CSRF Token输出到页面中,页面提交的请求携带这个Token,后端校验)<br> 双重Cookie验证（将cookie中的值 添加到请求path中，提交时校验两处的值是否相等）</p>
</li>
</ol>
<h1 id="网络劫持"><a href="#网络劫持" class="headerlink" title="网络劫持"></a>网络劫持</h1><h2 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h2><h2 id="HTTP劫持"><a href="#HTTP劫持" class="headerlink" title="HTTP劫持"></a>HTTP劫持</h2>]]></content>
      <tags>
        <tag>前端基础</tag>
      </tags>
  </entry>
  <entry>
    <title>前端异常监控</title>
    <url>/2021/05/27/%E5%89%8D%E7%AB%AF%E5%BC%82%E5%B8%B8%E7%9B%91%E6%8E%A7/</url>
    <content><![CDATA[<p>前端异常监控方案<span id="more"></span></p>
<h1 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h1><pre><code>SyntaxError:解析时发生语法错误
TypeError:值不是所期待的类型
ReferenceError:引用未声明的变量
RangeError:当一个值不在其所允许的范围或者集合中
ResourceError:资源加载错误
HttpError:Http请求错误
</code></pre>
<h1 id="搜集错误"><a href="#搜集错误" class="headerlink" title="搜集错误"></a>搜集错误</h1><h2 id="try-catch"><a href="#try-catch" class="headerlink" title="try/catch"></a>try/catch</h2><pre><code>能捕获常规运行时错误，语法错误和异步错误不行
</code></pre>
<h2 id="window-onerror"><a href="#window-onerror" class="headerlink" title="window.onerror"></a>window.onerror</h2><p>能捕获常规运行时错误,异步错误可以捕获, 语法错误、资源错误不能捕获 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;String&#125;</span>  </span>message    错误信息</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;String&#125;</span>  </span>source    出错文件</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;Number&#125;</span>  </span>lineno    行号</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;Number&#125;</span>  </span>colno    列号</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;Object&#125;</span>  </span>error  Error对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">message, source, lineno, colno, error</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;捕获到异常：&#x27;</span>, &#123;message, source, lineno, colno, error&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="window-addEventListener"><a href="#window-addEventListener" class="headerlink" title="window.addEventListener"></a>window.addEventListener</h2><p>图片、script、css加载错误，都能被捕获 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;error&#x27;</span>, <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;捕获到异常：&#x27;</span>, error);</span><br><span class="line">&#125;, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<h2 id="Promise错误"><a href="#Promise错误" class="headerlink" title="Promise错误"></a>Promise错误</h2><p>try/catch不能捕获Promise中的错误</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局统一处理Promise</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;unhandledrejection&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;捕获到异常：&#x27;</span>, e);</span><br><span class="line">&#125;);</span><br><span class="line">fetch(<span class="string">&#x27;https://tuia.cn/test&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="Vue错误"><a href="#Vue错误" class="headerlink" title="Vue错误"></a>Vue错误</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全局捕获Vue错误，直接扔出给onerror处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Vue.config.errorHandler = <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> err</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="React错误"><a href="#React错误" class="headerlink" title="React错误"></a>React错误</h2><blockquote>
<p>react 通过componentDidCatch，声明一个错误边界的组件</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123; <span class="attr">hasError</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//只有子组件发生错误时，该函数才会被执行</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">getDerivedStateFromError</span>(<span class="params">error</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 更新 state 使下一次渲染能够显示降级后的 UI</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">hasError</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">componentDidCatch</span>(<span class="params">error, errorInfo</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 你同样可以将错误日志上报给服务器</span></span><br><span class="line">    logErrorToMyService(error, errorInfo);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.state.hasError) &#123;</span><br><span class="line">      <span class="comment">// 你可以自定义降级后的 UI 并渲染</span></span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Something went wrong.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.props.children; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">    &lt;ErrorBoundary&gt;</span><br><span class="line">      &lt;MyWidget /&gt;</span><br><span class="line">    &lt;/ErrorBoundary&gt;  </span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="行为收集"><a href="#行为收集" class="headerlink" title="行为收集"></a>行为收集</h1><h2 id="用户行为"><a href="#用户行为" class="headerlink" title="用户行为"></a>用户行为</h2><p>使用addEventListener监听全局上的click事件，将事件和DOM元素名字收集。与错误信息一起上报。</p>
<h2 id="浏览器行"><a href="#浏览器行" class="headerlink" title="浏览器行"></a>浏览器行</h2><p>监听window.onpopstate，页面跳转的时会触发此方法，将信息收集。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> oldOnpopstate = <span class="built_in">window</span>.onpopstate;</span><br><span class="line"><span class="built_in">window</span>.onpopstate = <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> currentUrl = location.url;</span><br><span class="line">    <span class="keyword">if</span>(oldOnpopstate)&#123;</span><br><span class="line">        <span class="keyword">return</span> oldOnpopstate.apply(<span class="built_in">this</span>,args)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="控制台打印行为"><a href="#控制台打印行为" class="headerlink" title="控制台打印行为"></a>控制台打印行为</h2><p>改写console对象的info warn error 方法，收集信息</p>
<h1 id="数据上报"><a href="#数据上报" class="headerlink" title="数据上报"></a>数据上报</h1><p>post 一个1*1的gif上报</p>
<p>优点：<br>    没有跨域问题<br>    不会携带cookie<br>    不需要等待服务器返回数据<br>    不会阻塞页面加载，影响用户的体验，只需new Image 对象<br>    流量小 GIF比BMP节约41%的流量，比PNG节约35%的流量</p>
<h1 id="后台处理保存日志数据"><a href="#后台处理保存日志数据" class="headerlink" title="后台处理保存日志数据"></a>后台处理保存日志数据</h1>]]></content>
  </entry>
  <entry>
    <title>前端性能优化</title>
    <url>/2021/05/27/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>前端常用性能优化方法<span id="more"></span></p>
<h1 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h1><h2 id="NetWork面板"><a href="#NetWork面板" class="headerlink" title="NetWork面板"></a>NetWork面板</h2><p>减少请求数量  减少请求时间</p>
<h2 id="webpack-bundle-analyzer"><a href="#webpack-bundle-analyzer" class="headerlink" title="webpack-bundle-analyzer"></a>webpack-bundle-analyzer</h2><p>webpack-bundle-analyzer是一款包分析工具。</p>
<p>可以排查出一些无用的模块，过大的模块。然后进行优化。以减少我们的bundle包size，减少加载时长。</p>
<h2 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h2><ol>
<li><p>chrome自带的performance面板。<a href="https://developer.chrome.com/docs/devtools/evaluate-performance/">Performance</a></p>
<p> 可以查看fps cpu net<br> dom加载完毕时间：DOMContentLoaded Event<br> 第一次绘制时间：First Paint<br> 第一次内容绘制时间：First Contentful Paint<br> 最大的内容绘制时间：Largest Contentful Paint</p>
</li>
<li><p>PerformanceNavigationTiming</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showNavigationDetails</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [entry] = performance.getEntriesByType(<span class="string">&quot;navigation&quot;</span>);</span><br><span class="line">  <span class="built_in">console</span>.table(entry.toJSON());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<pre><code>DNS解析时间： domainLookupEnd - domainLookupStart
TCP建立连接时间： connectEnd - connectStart
白屏时间： responseStart - navigationStart
dom渲染完成时间： domContentLoadedEventEnd - navigationStart
页面onload时间： loadEventEnd - navigationStart
</code></pre>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><h2 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h2><ol>
<li>减少http请求数量，请求时间</li>
<li>使用 HTTP2<br> 二进制分帧传输<br> 多路复用<br> 首部压缩<br> 服务器推送</li>
<li>静态资源使用CDN</li>
<li>使用缓存，不重复加载相同的资源</li>
<li>开启 gzip</li>
</ol>
<h2 id="图片优化"><a href="#图片优化" class="headerlink" title="图片优化"></a>图片优化</h2><ol>
<li>图片压缩</li>
<li>图片分割 图片过大时考虑</li>
<li>雪碧图</li>
<li>图片懒加载</li>
<li>字体图</li>
</ol>
<h2 id="wabpack-相关"><a href="#wabpack-相关" class="headerlink" title="wabpack 相关"></a>wabpack 相关</h2><ol>
<li><p>tree shaking</p>
</li>
<li><p>split chunks (分包)<br> 入口文件依赖的文件都被打包进了main.js，那些大于 30kb 的第三方包，如：echarts、xlsx、dropzone等都被单独打包成了一个个独立 bundle。<br> 其它被我们设置了异步加载的页面或者组件变成了一个个chunk，也就是被打包成独立的bundle。<br> 内置的代码分割策略是这样的：</p>
<pre><code> 新的 chunk 是否被共享或者是来自 node_modules 的模块
 新的 chunk 体积在压缩之前是否大于 30kb
 按需加载 chunk 的并发请求数量小于等于 5 个
 页面初始加载时的并发请求数量小于等于 3 个
</code></pre>
</li>
<li><p>拆包<br> 可以将vue、react等资源包使用CDN 跟原有bundle拆开 拉取时可以命中强缓存 减少</p>
</li>
<li><p>压缩文件<br> 在 webpack 可以使用如下插件进行压缩：<br> JavaScript：UglifyPlugin<br> CSS ：MiniCssExtractPlugin<br> HTML：HtmlWebpackPlugin</p>
</li>
</ol>
<h2 id="代码方面"><a href="#代码方面" class="headerlink" title="代码方面"></a>代码方面</h2><ol>
<li>v-if v-show区分使用</li>
<li>v-for 添加key 避免使用v-if</li>
<li>computed 和 watch 区分使用  computed 有缓存 watch 在数据变化时执行异步或开销较大的操作时使用</li>
<li>长列表性能优化     Object.freeze</li>
<li>事件及时销毁</li>
<li>图片资源懒加载       滚动到可视区域后再去加载图片</li>
<li>路由懒加载</li>
<li>第三方插件的按需引入(elemnt 只引入button)</li>
<li>将 CSS 放在文件头部，JavaScript 文件放在底部</li>
</ol>
<h2 id="使用服务端渲染"><a href="#使用服务端渲染" class="headerlink" title="使用服务端渲染"></a>使用服务端渲染</h2>]]></content>
      <tags>
        <tag>前端基础</tag>
      </tags>
  </entry>
  <entry>
    <title>常用js方法实现</title>
    <url>/2021/09/02/%E5%B8%B8%E7%94%A8js%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>js常用方法整理<span id="more"></span></p>
<h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.sx_forEach = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.length; i++) &#123;</span><br><span class="line">        callback(<span class="built_in">this</span>[i], i, <span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">players.sx_forEach(<span class="function">(<span class="params">item, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item, index)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// &#123; name: &#x27;科比&#x27;, num: 24 &#125; 0</span></span><br><span class="line"><span class="comment">// &#123; name: &#x27;詹姆斯&#x27;, num: 23 &#125; 1</span></span><br><span class="line"><span class="comment">// &#123; name: &#x27;保罗&#x27;, num: 3 &#125; 2</span></span><br><span class="line"><span class="comment">// &#123; name: &#x27;威少&#x27;, num: 0 &#125; 3</span></span><br><span class="line"><span class="comment">// &#123; name: &#x27;杜兰特&#x27;, num: 35 &#125; 4</span></span><br></pre></td></tr></table></figure>

<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.sx_map = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.length; i++) &#123;</span><br><span class="line">        res.push(callback(<span class="built_in">this</span>[i], i, <span class="built_in">this</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(players.sx_map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;item.name&#125;</span>--<span class="subst">$&#123;item.num&#125;</span>--<span class="subst">$&#123;index&#125;</span>`</span>))</span><br><span class="line"><span class="comment">// [ &#x27;科比--24--0&#x27;, &#x27;詹姆斯--23--1&#x27;, &#x27;保罗--3--2&#x27;, &#x27;威少--0--3&#x27;, &#x27;杜兰特--35--4&#x27; ]</span></span><br></pre></td></tr></table></figure>

<h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.sx_filter = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.length; i++) &#123;</span><br><span class="line">        callback(<span class="built_in">this</span>[i], i, <span class="built_in">this</span>) &amp;&amp; res.push(<span class="built_in">this</span>[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(players.sx_filter(<span class="function"><span class="params">item</span> =&gt;</span> item.num &gt;= <span class="number">23</span>))</span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//     &#123; name: &#x27;科比&#x27;, num: 24 &#125;,</span></span><br><span class="line"><span class="comment">//     &#123; name: &#x27;詹姆斯&#x27;, num: 23 &#125;,</span></span><br><span class="line"><span class="comment">//     &#123; name: &#x27;杜兰特&#x27;, num: 35 &#125;</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure>

<h2 id="every"><a href="#every" class="headerlink" title="every"></a>every</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.sx_every = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> flag = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.length; i++) &#123;</span><br><span class="line">        flag = callback(<span class="built_in">this</span>[i], i, <span class="built_in">this</span>)</span><br><span class="line">        <span class="keyword">if</span> (!flag) <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> flag</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(players.sx_every(<span class="function"><span class="params">item</span> =&gt;</span> item.num &gt;= <span class="number">23</span>)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(players.sx_every(<span class="function"><span class="params">item</span> =&gt;</span> item.num &gt;= <span class="number">0</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="some"><a href="#some" class="headerlink" title="some"></a>some</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.sx_some = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> flag = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.length; i++) &#123;</span><br><span class="line">        flag = callback(<span class="built_in">this</span>[i], i, <span class="built_in">this</span>)</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> flag</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(players.sx_some(<span class="function"><span class="params">item</span> =&gt;</span> item.num &gt;= <span class="number">23</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(players.sx_some(<span class="function"><span class="params">item</span> =&gt;</span> item.num &gt;= <span class="number">50</span>)) <span class="comment">// false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.sx_reduce = <span class="function"><span class="keyword">function</span> (<span class="params">callback, initValue</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pre = initValue</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.length; i++) &#123;</span><br><span class="line">        pre = callback(pre, <span class="built_in">this</span>[i], i, <span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算所有num相加</span></span><br><span class="line"><span class="keyword">const</span> sum = players.sx_reduce(<span class="function">(<span class="params">pre, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pre + next.num</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(sum) <span class="comment">// 85</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex"></a>findIndex</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.sx_findIndex = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (callback(<span class="built_in">this</span>[i], i, <span class="built_in">this</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(players.sx_findIndex(<span class="function"><span class="params">item</span> =&gt;</span> item.name === <span class="string">&#x27;科比&#x27;</span>)) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(players.sx_findIndex(<span class="function"><span class="params">item</span> =&gt;</span> item.name === <span class="string">&#x27;安东尼&#x27;</span>)) <span class="comment">// -1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.sx_find = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (callback(<span class="built_in">this</span>[i], i, <span class="built_in">this</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(players.sx_find(<span class="function"><span class="params">item</span> =&gt;</span> item.name === <span class="string">&#x27;科比&#x27;</span>)) <span class="comment">// &#123; name: &#x27;科比&#x27;, num: 24 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(players.sx_find(<span class="function"><span class="params">item</span> =&gt;</span> item.name === <span class="string">&#x27;安东尼&#x27;</span>)) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h2 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.sx_fill = <span class="function"><span class="keyword">function</span> (<span class="params">value, start = <span class="number">0</span>, end</span>) </span>&#123;</span><br><span class="line">    end = (end || <span class="built_in">this</span>.length - <span class="number">1</span>) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">        <span class="built_in">this</span>[i] = value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(players.sx_fill(<span class="string">&#x27;林三心&#x27;</span>, <span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//     &#123; name: &#x27;科比&#x27;, num: 24 &#125;,</span></span><br><span class="line"><span class="comment">//     &#x27;林三心&#x27;,</span></span><br><span class="line"><span class="comment">//     &#x27;林三心&#x27;,</span></span><br><span class="line"><span class="comment">//     &#x27;林三心&#x27;,</span></span><br><span class="line"><span class="comment">//     &#123; name: &#x27;杜兰特&#x27;, num: 35 &#125;</span></span><br><span class="line"><span class="comment">// ]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.sx_includes = <span class="function"><span class="keyword">function</span> (<span class="params">value, start = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span>) start = <span class="built_in">this</span>.length + start</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">isNaN</span> = <span class="built_in">Number</span>.isNaN(value)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; <span class="built_in">this</span>.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>[i] === value || <span class="built_in">Number</span>.isNaN(<span class="built_in">this</span>[i]) === <span class="built_in">isNaN</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].sx_includes(<span class="number">2</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="literal">NaN</span>].sx_includes(<span class="literal">NaN</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].sx_includes(<span class="number">1</span>, <span class="number">1</span>)) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.sx_join = <span class="function"><span class="keyword">function</span> (<span class="params">s = <span class="string">&#x27;,&#x27;</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> str = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.length; i++) &#123;</span><br><span class="line">        str = i === <span class="number">0</span> ? <span class="string">`<span class="subst">$&#123;str&#125;</span><span class="subst">$&#123;<span class="built_in">this</span>[i]&#125;</span>`</span> : <span class="string">`<span class="subst">$&#123;str&#125;</span><span class="subst">$&#123;s&#125;</span><span class="subst">$&#123;<span class="built_in">this</span>[i]&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].sx_join()) <span class="comment">// 1,2,3</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].sx_join(<span class="string">&#x27;*&#x27;</span>)) <span class="comment">// 1*2*3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="flat"><a href="#flat" class="headerlink" title="flat"></a>flat</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.sx_flat = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">while</span> (arr.some(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">Array</span>.isArray(item))) &#123;</span><br><span class="line">        arr = [].concat(...arr)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> testArr = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]], [<span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(testArr.sx_flat())</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5, 8, 9]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h2><p>向/从数组中添加/删除项目，然后返回被删除的项目。该方法会改变原始数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.sx_splice = <span class="function"><span class="keyword">function</span> (<span class="params">start, length, ...values</span>) </span>&#123;</span><br><span class="line">  length = start + length &gt; <span class="built_in">this</span>.length - <span class="number">1</span> ? <span class="built_in">this</span>.length - start : length</span><br><span class="line">  <span class="keyword">const</span> res = [], tempArr = [...this]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; start + values.length; i++) &#123;</span><br><span class="line">    <span class="built_in">this</span>[i] = values[i - start]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (values.length &lt; length) &#123;</span><br><span class="line">    <span class="keyword">const</span> cha = length - values.length</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = start + values.length; i &lt; tempArr.length; i++) &#123;</span><br><span class="line">      <span class="built_in">this</span>[i] = tempArr[i + cha]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.length = <span class="built_in">this</span>.length - cha </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (values.length &gt; length) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = start + length; i &lt; tempArr.length; i++) &#123;</span><br><span class="line">      <span class="built_in">this</span>.push(tempArr[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; start + length; i++) &#123;</span><br><span class="line">    res.push(tempArr[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><h2 id="entries"><a href="#entries" class="headerlink" title="entries"></a>entries</h2><p>将对象转成键值对数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.sx_entries = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        obj.hasOwnProperty(key) &amp;&amp; res.push([key, obj[key]])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.sx_entries(obj))</span><br><span class="line"><span class="comment">// [ [ &#x27;name&#x27;, &#x27;林三心&#x27; ], [ &#x27;age&#x27;, 22 ], [ &#x27;gender&#x27;, &#x27;男&#x27; ] ]</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="fromEntries"><a href="#fromEntries" class="headerlink" title="fromEntries"></a>fromEntries</h2><p>跟entries相反，将键值对数组转成对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.sx_fromEntries = <span class="function"><span class="keyword">function</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> [key, value] = arr[i]</span><br><span class="line">        obj[key] = value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.sx_fromEntries([[<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;林三心&#x27;</span>], [<span class="string">&#x27;age&#x27;</span>, <span class="number">22</span>], [<span class="string">&#x27;gender&#x27;</span>, <span class="string">&#x27;男&#x27;</span>]]))</span><br><span class="line"><span class="comment">// &#123; name: &#x27;林三心&#x27;, age: 22, gender: &#x27;男&#x27; &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="keys"><a href="#keys" class="headerlink" title="keys"></a>keys</h2><p>将对象的key转成一个数组合集</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.sx_keys = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> keys = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        obj.hasOwnProperty(key) &amp;&amp; res.push(key)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> keys</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj))</span><br><span class="line"><span class="comment">// [ &#x27;name&#x27;, &#x27;age&#x27;, &#x27;gender&#x27; ]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="values"><a href="#values" class="headerlink" title="values"></a>values</h2><p>将对象的所有值转成数组合集</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.sx_values = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> values = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        obj.hasOwnProperty(key) &amp;&amp; values.push(obj[key])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> values</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.sx_values(obj))</span><br><span class="line"><span class="comment">// [ &#x27;林三心&#x27;, 22, &#x27;男&#x27; ]</span></span><br></pre></td></tr></table></figure>
<h2 id="instanceOf"><a href="#instanceOf" class="headerlink" title="instanceOf"></a>instanceOf</h2><p>A instanceOf B，判断A是否经过B的原型链</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instanceOf</span>(<span class="params">father, child</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> fp = father.prototype</span><br><span class="line">    <span class="keyword">var</span> cp = child.__proto__</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cp) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cp === fp) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        cp = cp.__proto__</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> sx = <span class="keyword">new</span> Person(<span class="string">&#x27;林三心&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(instanceOf(Person, sx)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(instanceOf(Person, sx2)) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="is"><a href="#is" class="headerlink" title="is"></a>is</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.sx_is = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x === y) &#123;</span><br><span class="line">        <span class="comment">// 防止 -0 和 +0</span></span><br><span class="line">        <span class="keyword">return</span> x !== <span class="number">0</span> || <span class="number">1</span> / x === <span class="number">1</span> / y</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止NaN</span></span><br><span class="line">    <span class="keyword">return</span> x !== x &amp;&amp; y !== y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">name</span>: <span class="string">&#x27;林三心&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">const</span> b = a</span><br><span class="line"><span class="keyword">const</span> c = &#123; <span class="attr">name</span>: <span class="string">&#x27;林三心&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.sx_is(a, b)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.sx_is(a, c)) <span class="comment">// false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="assign"><a href="#assign" class="headerlink" title="assign"></a>assign</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.sx_assign = <span class="function"><span class="keyword">function</span> (<span class="params">target, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target === <span class="literal">null</span> || target === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Cannot convert undefined or null to object&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    target = <span class="built_in">Object</span>(target)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> nextObj <span class="keyword">of</span> args) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> nextObj) &#123;</span><br><span class="line">            nextObj.hasOwnProperty(key) &amp;&amp; (target[key] = nextObj[key])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> testa = &#123; <span class="attr">name</span>: <span class="string">&#x27;林三心&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">const</span> testb = &#123; <span class="attr">name</span>: <span class="string">&#x27;sunshine_lin&#x27;</span>, <span class="attr">age</span>: <span class="number">22</span> &#125;</span><br><span class="line"><span class="keyword">const</span> testc = &#123; <span class="attr">age</span>: <span class="number">18</span>, <span class="attr">gender</span>: <span class="string">&#x27;男&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> testd = <span class="built_in">Object</span>.sx_assign(testa, testb, testc)</span><br><span class="line"><span class="built_in">console</span>.log(testd) <span class="comment">// &#123; name: &#x27;sunshine_lin&#x27;, age: 18, gender: &#x27;男&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(testa === testd) <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h1><h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.sx_call = <span class="function"><span class="keyword">function</span> (<span class="params">obj, ...args</span>) </span>&#123;</span><br><span class="line">    obj = obj || <span class="built_in">window</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Symbol是唯一的，防止重名key</span></span><br><span class="line">    <span class="keyword">const</span> fn = <span class="built_in">Symbol</span>()</span><br><span class="line">    obj[fn] = <span class="built_in">this</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行，返回执行值</span></span><br><span class="line">    <span class="keyword">return</span> obj[fn](...args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> testobj = &#123;</span><br><span class="line">    name: <span class="string">&#x27;林三心&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">testFn</span>(<span class="params">age</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span><span class="subst">$&#123;age&#125;</span>岁了`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> testobj2 = &#123;</span><br><span class="line">    name: <span class="string">&#x27;sunshine_lin&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">testobj.testFn.sx_call(testobj2, <span class="number">22</span>) <span class="comment">// sunshine_lin22岁了</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.sx_apply = <span class="function"><span class="keyword">function</span> (<span class="params">obj, args</span>) </span>&#123;</span><br><span class="line">    obj = obj || <span class="built_in">window</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Symbol是唯一的，防止重名key</span></span><br><span class="line">    <span class="keyword">const</span> fn = <span class="built_in">Symbol</span>()</span><br><span class="line">    obj[fn] = <span class="built_in">this</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行，返回执行值</span></span><br><span class="line">    <span class="keyword">return</span> obj[fn](...args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> testobj = &#123;</span><br><span class="line">    name: <span class="string">&#x27;林三心&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">testFn</span>(<span class="params">age</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span><span class="subst">$&#123;age&#125;</span>岁了`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> testobj2 = &#123;</span><br><span class="line">    name: <span class="string">&#x27;sunshine_lin&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">testobj.testFn.sx_apply(testobj2, [<span class="number">22</span>]) <span class="comment">// sunshine_lin22岁了</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.sx_bind = <span class="function"><span class="keyword">function</span> (<span class="params">obj, ...args</span>) </span>&#123;</span><br><span class="line">    obj = obj || <span class="built_in">window</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Symbol是唯一的，防止重名key</span></span><br><span class="line">    <span class="keyword">const</span> fn = <span class="built_in">Symbol</span>()</span><br><span class="line">    obj[fn] = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">const</span> _this = <span class="built_in">this</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> res = <span class="function"><span class="keyword">function</span> (<span class="params">...innerArgs</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>, _this)</span><br><span class="line">        <span class="comment">//若是将 bind 绑定之后的函数当作构造函数，通过 new 操作符使用，则不绑定传入的 this，而是将 this 指向实例化出来的对象</span></span><br><span class="line">        <span class="comment">// 此时由于new操作符作用  this指向res实例对象  而res又继承自传入的_this 根据原型链知识可得出以下结论</span></span><br><span class="line">        <span class="comment">// this.__proto__ === res.prototype   //this instanceof res =&gt;true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span> _this) &#123;</span><br><span class="line">            <span class="built_in">this</span>[fn] = _this</span><br><span class="line">            <span class="built_in">this</span>[fn](...[...args, ...innerArgs])</span><br><span class="line">            <span class="keyword">delete</span> <span class="built_in">this</span>[fn]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果只是作为普通函数调用  那就很简单了 直接改变this指向为传入的context</span></span><br><span class="line">            obj[fn](...[...args, ...innerArgs])</span><br><span class="line">            <span class="keyword">delete</span> obj[fn]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res.prototype = <span class="built_in">Object</span>.create(<span class="built_in">this</span>.prototype)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name); <span class="comment">//&#x27;我是参数传进来的name&#x27;</span></span><br><span class="line">  <span class="built_in">console</span>.log(age); <span class="comment">//&#x27;我是参数传进来的age&#x27;</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">//构造函数this指向实例对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构造函数原型的方法</span></span><br><span class="line">Person.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">123</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  objName: <span class="string">&#x27;我是obj传进来的name&#x27;</span>,</span><br><span class="line">  objAge: <span class="string">&#x27;我是obj传进来的age&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalFun</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name);   <span class="comment">//&#x27;我是参数传进来的name&#x27;</span></span><br><span class="line">  <span class="built_in">console</span>.log(age);   <span class="comment">//&#x27;我是参数传进来的age&#x27;</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">//普通函数this指向绑定bind的第一个参数 也就是例子中的obj</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.objName); <span class="comment">//&#x27;我是obj传进来的name&#x27;</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.objAge); <span class="comment">//&#x27;我是obj传进来的age&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先测试作为构造函数调用</span></span><br><span class="line"><span class="keyword">var</span> bindFun = Person.sx_bind(obj, <span class="string">&#x27;我是参数传进来的name&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> bindFun(<span class="string">&#x27;我是参数传进来的age&#x27;</span>)</span><br><span class="line">a.say() <span class="comment">//123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//再测试作为普通函数调用</span></span><br><span class="line"><span class="keyword">var</span> bindFun = normalFun.sx_bind(obj, <span class="string">&#x27;我是参数传进来的name&#x27;</span>)</span><br><span class="line"> bindFun(<span class="string">&#x27;我是参数传进来的age&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params">fun,...args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p = &#123;&#125;;</span><br><span class="line">    p.proto = fun.prototype;</span><br><span class="line">    fun.call(p,...args);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = myNew(Person,<span class="string">&#x27;zhangsan&#x27;</span>,<span class="string">&#x27;21&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="setTimeout-模拟实现-setInterval"><a href="#setTimeout-模拟实现-setInterval" class="headerlink" title="setTimeout 模拟实现 setInterval"></a>setTimeout 模拟实现 setInterval</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInterval</span>(<span class="params">fn,time=<span class="number">1000</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>,isClear = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">interval</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isClear)&#123;</span><br><span class="line">            isClear = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fn();</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(interval,time);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(interval,time);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">()=&gt;</span>&#123;</span><br><span class="line">        isClear = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = myInterval(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">111</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"><span class="keyword">let</span> cancel = myInterval(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">222</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line">cancel()</span><br></pre></td></tr></table></figure>

<h2 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EventEmitter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.events  = &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">EventEmitter.prototype.on = <span class="function"><span class="keyword">function</span>(<span class="params">type,callBack</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.events[type]) &#123;</span><br><span class="line">      <span class="built_in">this</span>.events[type] = [callBack];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.events[type].push(callBack);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EventEmitter.prototype.off = <span class="function"><span class="keyword">function</span>(<span class="params">type,callBack</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.events[type]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">this</span>.events[type] = <span class="built_in">this</span>.events[type].filter(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> item !== callBack;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventEmitter.prototype.once = <span class="function"><span class="keyword">function</span>(<span class="params">type,callBack</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      callBack();</span><br><span class="line">      <span class="built_in">this</span>.off(type, fn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.on(type, fn);</span><br><span class="line">&#125;</span><br><span class="line">EventEmitter.prototype.emit = <span class="function"><span class="keyword">function</span>(<span class="params">type,...args</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.events[type] &amp;&amp;</span><br><span class="line">      <span class="built_in">this</span>.events[type].forEach(<span class="function">(<span class="params">fn</span>) =&gt;</span> fn.apply(<span class="built_in">this</span>, args));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> event = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handle = <span class="function">(<span class="params">...rest</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(rest);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">event.on(<span class="string">&quot;click&quot;</span>, handle);</span><br><span class="line"></span><br><span class="line">event.emit(<span class="string">&quot;click&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">event.off(<span class="string">&quot;click&quot;</span>, handle);</span><br><span class="line"></span><br><span class="line">event.emit(<span class="string">&quot;click&quot;</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">event.once(<span class="string">&quot;dbClick&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">123456</span>);</span><br><span class="line">&#125;);</span><br><span class="line">event.emit(<span class="string">&quot;dbClick&quot;</span>);</span><br><span class="line">event.emit(<span class="string">&quot;dbClick&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h2 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.sx_slice = <span class="function"><span class="keyword">function</span> (<span class="params">start = <span class="number">0</span>, end</span>) </span>&#123;</span><br><span class="line">    start = start &lt; <span class="number">0</span> ? <span class="built_in">this</span>.length + start : start</span><br><span class="line">    end = !end &amp;&amp; end !== <span class="number">0</span> ? <span class="built_in">this</span>.length : end</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end) <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">let</span> str = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">        str += <span class="built_in">this</span>[i]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str.sx_slice(<span class="number">2</span>)) <span class="comment">// nshine_lin</span></span><br><span class="line"><span class="built_in">console</span>.log(str.sx_slice(-<span class="number">2</span>)) <span class="comment">// in</span></span><br><span class="line"><span class="built_in">console</span>.log(str.sx_slice(-<span class="number">9</span>, <span class="number">10</span>)) <span class="comment">// shine_l</span></span><br><span class="line"><span class="built_in">console</span>.log(str.sx_slice(<span class="number">5</span>, <span class="number">1</span>)) <span class="comment">// &#x27;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="substr"><a href="#substr" class="headerlink" title="substr"></a>substr</h2><p>参数代表含义<br>start：开始截取的字符索引(包含此字符)<br>length：截取的长度</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.sx_substr = <span class="function"><span class="keyword">function</span> (<span class="params">start = <span class="number">0</span>, length</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    start = start &lt; <span class="number">0</span> ? <span class="built_in">this</span>.length + start : start</span><br><span class="line">    length = (!length &amp;&amp; length !== <span class="number">0</span>) || length &gt; <span class="built_in">this</span>.length - start ? <span class="built_in">this</span>.length : start + length</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> str = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; length; i++) &#123;</span><br><span class="line">        str += <span class="built_in">this</span>[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str.sx_substr(<span class="number">3</span>)) <span class="comment">// shine_lin</span></span><br><span class="line"><span class="built_in">console</span>.log(str.sx_substr(<span class="number">3</span>, <span class="number">3</span>)) <span class="comment">// shi</span></span><br><span class="line"><span class="built_in">console</span>.log(str.sx_substr(<span class="number">5</span>, <span class="number">300</span>)) <span class="comment">// ine_lin</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="substring"><a href="#substring" class="headerlink" title="substring"></a>substring</h2><p>功能与slice大致相同,区别之处:start &gt; end：互换值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.sx_sunstring = <span class="function"><span class="keyword">function</span> (<span class="params">start = <span class="number">0</span>, end</span>) </span>&#123;</span><br><span class="line">    start = start &lt; <span class="number">0</span> ? <span class="built_in">this</span>.length + start : start</span><br><span class="line">    end = !end &amp;&amp; end !== <span class="number">0</span> ? <span class="built_in">this</span>.length : end</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end) [start, end] = [end, start]</span><br><span class="line">    <span class="keyword">let</span> str = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">        str += <span class="built_in">this</span>[i]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str.sx_sunstring(<span class="number">2</span>)) <span class="comment">// nshine_lin</span></span><br><span class="line"><span class="built_in">console</span>.log(str.sx_sunstring(-<span class="number">2</span>)) <span class="comment">// in</span></span><br><span class="line"><span class="built_in">console</span>.log(str.sx_sunstring(-<span class="number">9</span>, <span class="number">10</span>)) <span class="comment">// shine_l</span></span><br><span class="line"><span class="built_in">console</span>.log(str.sx_sunstring(<span class="number">5</span>, <span class="number">1</span>)) <span class="comment">// unsh</span></span><br></pre></td></tr></table></figure>

<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h2 id="all"><a href="#all" class="headerlink" title="all"></a>all</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">all</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = []</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> addData = <span class="function">(<span class="params">index, value</span>) =&gt;</span> &#123;</span><br><span class="line">            result[index] = value</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span> (count === promises.length) resolve(result)</span><br><span class="line">        &#125;</span><br><span class="line">        promises.forEach(<span class="function">(<span class="params">promise,index</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(promise <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)&#123;</span><br><span class="line">                promise.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">                    addData(index,res)</span><br><span class="line">                &#125;,<span class="function"><span class="params">err</span>=&gt;</span>reject(err))</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                addData(index,promise)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="race"><a href="#race" class="headerlink" title="race"></a>race</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">race</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            promises.forEach(<span class="function"><span class="params">promise</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (promise <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">                    promise.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                        resolve(res)</span><br><span class="line">                    &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                        reject(err)</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    resolve(promise)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="allSettled"><a href="#allSettled" class="headerlink" title="allSettled"></a>allSettled</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">allSettled</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> res = []</span><br><span class="line">        <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">const</span> addData = <span class="function">(<span class="params">status, value, i</span>) =&gt;</span> &#123;</span><br><span class="line">            res[i] = &#123;</span><br><span class="line">                status,</span><br><span class="line">                value</span><br><span class="line">            &#125;</span><br><span class="line">            count++</span><br><span class="line">            <span class="keyword">if</span> (count === promises.length) &#123;</span><br><span class="line">                resolve(res)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        promises.forEach(<span class="function">(<span class="params">promise, i</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (promise <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">                promise.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                    addData(<span class="string">&#x27;fulfilled&#x27;</span>, res, i)</span><br><span class="line">                &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                    addData(<span class="string">&#x27;rejected&#x27;</span>, err, i)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                addData(<span class="string">&#x27;fulfilled&#x27;</span>, promise, i)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="any"><a href="#any" class="headerlink" title="any"></a>any</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">any</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">            promises.forEach(<span class="function">(<span class="params">promise</span>) =&gt;</span> &#123;</span><br><span class="line">                promise.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">                    resolve(val)</span><br><span class="line">                &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                    count++</span><br><span class="line">                    <span class="keyword">if</span> (count === promises.length) &#123;</span><br><span class="line">                        reject(<span class="keyword">new</span> AggregateError(<span class="string">&#x27;All promises were rejected&#x27;</span>))</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>常用设计模式</title>
    <url>/2021/04/07/%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。<span id="more"></span></p>
<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><blockquote>
<p>常见的实例化对象模式，工厂模式就相当于创建实例对象的new，提供一个创建对象的接口</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 某个需要创建的具体对象</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">        <span class="title">constructor</span> (<span class="params">name</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        init () &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 工厂对象</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Creator</span> </span>&#123;</span><br><span class="line">        create (name) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Product(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> creator = <span class="keyword">new</span> Creator();</span><br><span class="line">    <span class="keyword">const</span> p = creator.create(); <span class="comment">// 通过工厂对象创建出来的具体对象</span></span><br></pre></td></tr></table></figure>
<p>工厂模式最直观的地方在于，创建产品对象不是通过直接new 产品类实现，而是通过工厂方法实现</p>
<p>应用场景： jQuery的选择器$(selector)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">jQuery</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">selector</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(selector)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.$ = <span class="function"><span class="keyword">function</span>(<span class="params">selector</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> jQuery(selector)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><blockquote>
<p>保证实例在全局的单一性</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let Modal &#x3D; (function()&#123;</span><br><span class="line">    let instance;</span><br><span class="line">    return function(name) &#123;</span><br><span class="line">        if (instance) &#123;</span><br><span class="line">           return instance;</span><br><span class="line">        &#125;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        return instance &#x3D; this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">Modal.prototype.getName &#x3D; function() &#123;</span><br><span class="line">    return this.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let question &#x3D; new Modal(&#39;问题框&#39;);</span><br><span class="line">let answer &#x3D; new Modal(&#39;回答框&#39;);</span><br><span class="line"></span><br><span class="line">console.log(question &#x3D;&#x3D;&#x3D; answer); &#x2F;&#x2F; true</span><br><span class="line">console.log(question.getName());  &#x2F;&#x2F; &#39;问题框&#39;</span><br><span class="line">console.log(answer.getName());  &#x2F;&#x2F; &#39;回答框&#39;</span><br></pre></td></tr></table></figure>
<p>单例模式保证了实例对象得唯一性。</p>
<p>例子：弹窗、购物车、网络请求</p>
<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><blockquote>
<p>适配器模式（Adapter）是将一个类（对象）的接口（方法或属性）转化成适应当前场景的另一个接口（方法或属性），适配器模式使得原本由于接口不兼容而不能一起工作的那些类（对象）可以一些工作。所以，适配器模式必须包含目标（Target）、源（Adaptee）和适配器（Adapter）三个角色。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> adaptee = [</span><br><span class="line">    &#123;</span><br><span class="line">        id: <span class="number">1</span></span><br><span class="line">        type: <span class="string">&#x27;Article&#x27;</span>,</span><br><span class="line">        createAt: <span class="string">&#x27;2019-06-12 08:10:20&#x27;</span>,</span><br><span class="line">        updateAt: <span class="string">&#x27;2019-08-15 09:00:00&#x27;</span>,</span><br><span class="line">        ......</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        id: <span class="number">2</span></span><br><span class="line">        type: <span class="string">&#x27;Answer&#x27;</span>,</span><br><span class="line">        createAt: <span class="string">&#x27;2019-04-11 08:11:23&#x27;</span>,</span><br><span class="line">        updateAt: <span class="string">&#x27;2019/08/15 09:00:00&#x27;</span>,</span><br><span class="line">        ......</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        id: <span class="number">3</span></span><br><span class="line">        type: <span class="string">&#x27;Course&#x27;</span>,</span><br><span class="line">        createTime: <span class="number">1554941483000</span>,</span><br><span class="line">        updateAt: <span class="number">1565830800000</span>,</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">let</span> adapter = <span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(item.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;Article&#x27;</span>:</span><br><span class="line">        [item.createAt, item.updateAt] = [</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">Date</span>(item.createAt.replace(<span class="regexp">/-/g</span>,<span class="string">&#x27;/&#x27;</span>)).getTime(),</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">Date</span>(item.updateAt.replace(<span class="regexp">/-/g</span>,<span class="string">&#x27;/&#x27;</span>)).getTime()</span><br><span class="line">        ]</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>: <span class="string">&#x27;Answer&#x27;</span>: </span><br><span class="line">        item.createAt = <span class="keyword">new</span> <span class="built_in">Date</span>(item.createAt.replace(<span class="regexp">/-/g</span>,<span class="string">&#x27;/&#x27;</span>)).getTime();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>: <span class="string">&#x27;Course&#x27;</span>:</span><br><span class="line">        item.createAt = item.createTime</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> target = adaptee.map(<span class="function">(<span class="params">item</span>)=&gt;</span>adapter(item));</span><br></pre></td></tr></table></figure>
<h1 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h1><blockquote>
<p>在原来方法的基础上去装饰一些针对特别场景所适用的方法，即添加一些新功能</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">draw</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;画一个圆形&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">circle</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.circle = circle;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">draw</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.circle.draw();</span><br><span class="line">        <span class="built_in">this</span>.setRedBorder(circle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">setRedBorder</span>(<span class="params">circle</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;画一个红色边框&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> circle = <span class="keyword">new</span> Circle();</span><br><span class="line"><span class="keyword">let</span> decorator = <span class="keyword">new</span> Decorator(circle);</span><br><span class="line">decorator.draw(); <span class="comment">//画一个圆形，画一个红色边框</span></span><br></pre></td></tr></table></figure>
<p>例子:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixins</span>(<span class="params">...list</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">Object</span>.assign(target.prototype, ...list)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">    <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        alert(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@mixins(Foo)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">obj.foo();</span><br></pre></td></tr></table></figure>

<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><blockquote>
<p>代理模式要突出“代理”的含义，该模式场景需要三类角色，分别为使用者、目标对象和代理者，使用者的目的是直接访问目标对象，但却不能直接访问，而是要先通过代理者</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadImg</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">fileName</span>)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.fileName = fileName;</span><br><span class="line">       <span class="built_in">this</span>.loadFromDisk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">display</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;display...&#x27;</span> + <span class="built_in">this</span>.fileName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">loadFromDisk</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;loading...&#x27;</span> + <span class="built_in">this</span>.fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyImg</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">fileName</span>)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.readImg = <span class="keyword">new</span> ReadImg(fileName)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">display</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.readImg.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxyImg = <span class="keyword">new</span> ProxyImg(<span class="string">&#x27;1.png&#x27;</span>);</span><br><span class="line">proxyImg.display();</span><br></pre></td></tr></table></figure>
<p>实际使用：</p>
<blockquote>
<p>HTML元素事件代理：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;div1&quot;</span>&gt;</span><br><span class="line">        &lt;a href=<span class="string">&quot;#&quot;</span>&gt;a1&lt;/a&gt;</span><br><span class="line">        &lt;a href=<span class="string">&quot;#&quot;</span>&gt;a2&lt;/a&gt;</span><br><span class="line">        &lt;a href=<span class="string">&quot;#&quot;</span>&gt;a3&lt;/a&gt;</span><br><span class="line">        &lt;a href=<span class="string">&quot;#&quot;</span>&gt;a4&lt;/a&gt;</span><br><span class="line">        &lt;a href=<span class="string">&quot;#&quot;</span>&gt;a5&lt;/a&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">       <span class="keyword">var</span> div1 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;div1&#x27;</span>);</span><br><span class="line">       div1.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">var</span> target = e.target;</span><br><span class="line">          <span class="keyword">if</span>(target.nodeName === <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">             alert(target.innerHTML);</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<p>我们并未直接在元素上定义点击事件，而是通过监听元素点击事件，并通过定位元素节点名称来代理到&lt;a&gt;标签的点击，最终利用捕获事件来实现相应的点击效果。</p>
<blockquote>
<p>ES6 proxy  </p>
</blockquote>
<p>Vue 3.0 的双向绑定原理就是依赖 ES6 的 Proxy 来实现，给一个简单的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> star = &#123;</span><br><span class="line">    name: <span class="string">&#x27;菜徐坤&#x27;</span>,</span><br><span class="line">    song: <span class="string">&#x27;~鸡你太美~&#x27;</span></span><br><span class="line">    age: <span class="number">40</span>,</span><br><span class="line">    phone: <span class="number">13089898989</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> agent = <span class="keyword">new</span> <span class="built_in">Proxy</span>(star , &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params">target , key</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(key == <span class="string">&#x27;phone&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回经济人自己的电话</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">15667096303</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(key == <span class="string">&#x27;price&#x27;</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">20000000000</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target[key]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">target , key , val</span>)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(key === <span class="string">&#x27;customPrice&#x27;</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span>(val &lt; <span class="number">100000000</span>) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;价格太低&#x27;</span>)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">              target[key] = value;</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// agent 对象会根据相应的代理规则，执行相应的操作：</span></span><br><span class="line">agent.phone <span class="comment">// 15667096303  </span></span><br><span class="line">agent.price <span class="comment">// 20000000000 </span></span><br></pre></td></tr></table></figure>

<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><blockquote>
<p>观察者模式，也叫订阅-发布模式，熟悉Vue的朋友一定不会陌生，该模式定义了一种1对N的关系，使观察者们同时监听某一个对象相应的状态变换，一旦变化则通知到所有观察者，从而触发观察者相应的事件。因此，观察者模式中的角色有两类：观察者（发布者）和被观察者（订阅者）。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个主题，保存状态，状态变化之后触发所有观察者对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.observers = []</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">getState</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.state</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">setState</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.state = state;</span><br><span class="line">       <span class="built_in">this</span>.notifyAllObservers()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">notifyAllObservers</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.observers.forEach(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">            observer.update()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">attach</span>(<span class="params">observer</span>)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.observers.push(observer)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name , subject</span>)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.name = name;</span><br><span class="line">       <span class="built_in">this</span>.subject = subject;</span><br><span class="line">       <span class="built_in">this</span>.subject.attach(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">update</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> update, state: <span class="subst">$&#123;<span class="built_in">this</span>.subject.getState()&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> Subject();</span><br><span class="line"><span class="keyword">let</span> o1 = <span class="keyword">new</span> Observer(<span class="string">&#x27;o1&#x27;</span> , s);</span><br><span class="line"><span class="keyword">let</span> o2 = <span class="keyword">new</span> Observer(<span class="string">&#x27;o2&#x27;</span> , s);</span><br><span class="line"><span class="keyword">let</span> o3 = <span class="keyword">new</span> Observer(<span class="string">&#x27;o3&#x27;</span> , s);</span><br><span class="line"></span><br><span class="line">s.setState(<span class="number">1</span>)</span><br><span class="line">s.setState(<span class="number">2</span>)</span><br><span class="line">s.setState(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">o1 update, state: 1</span></span><br><span class="line"><span class="comment"> o2 update, state: 1</span></span><br><span class="line"><span class="comment">o3 update, state: 1</span></span><br><span class="line"><span class="comment">o1 update, state: 2</span></span><br><span class="line"><span class="comment">o2 update, state: 2</span></span><br><span class="line"><span class="comment">o3 update, state: 2</span></span><br><span class="line"><span class="comment">o2 update, state: 3</span></span><br><span class="line"><span class="comment">o3 update, state: 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>例子：Promise、Vue 的 Watch生命周期钩子、flutter Provider等</p>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6语法</title>
    <url>/2021/08/17/ES6%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>ES6常用语法整理<span id="more"></span></p>
<h1 id="let-const"><a href="#let-const" class="headerlink" title="let/const"></a>let/const</h1><h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><ol>
<li>箭头函数没有arguments</li>
<li>箭头函数没有prototype属性，不能用作构造函数</li>
<li>箭头函数没有自己this，它的this是词法的，引用的是上下文的this</li>
</ol>
<h1 id="iterator迭代器"><a href="#iterator迭代器" class="headerlink" title="iterator迭代器"></a>iterator迭代器</h1><p>是另外4个ES6常用特性的实现基础（解构赋值，剩余/扩展运算符，生成器，for of循环）</p>
<h1 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h1><h1 id="剩余-扩展运算符"><a href="#剩余-扩展运算符" class="headerlink" title="剩余/扩展运算符"></a>剩余/扩展运算符</h1><h1 id="对象属性-方法简写"><a href="#对象属性-方法简写" class="headerlink" title="对象属性/方法简写"></a>对象属性/方法简写</h1><h1 id="for-…-of循环"><a href="#for-…-of循环" class="headerlink" title="for … of循环"></a>for … of循环</h1><ol>
<li>for … of只能用在可迭代对象上,获取的是迭代器返回的value值,for … in 可以获取所有对象的键名</li>
<li>for … in会遍历对象的整个原型链,性能非常差不推荐使用,而for … of只遍历当前对象不会遍历它的原型链</li>
<li>对于数组的遍历,for … in会返回数组中所有可枚举的属性(包括原型链上可枚举的属性),for … of只返回数组的下标对应的属性值</li>
</ol>
<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h1 id="ES6-Module"><a href="#ES6-Module" class="headerlink" title="ES6 Module"></a>ES6 Module</h1><p><a href="/2021/07/08/JavaScript%E6%A8%A1%E5%9D%97%E5%8C%96">JavaScript模块化</a>。</p>
<h1 id="函数默认值"><a href="#函数默认值" class="headerlink" title="函数默认值"></a>函数默认值</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">&#123;x=<span class="number">10</span>&#125;=&#123;&#125;,&#123;y&#125;=&#123;y: <span class="number">10</span>&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>. log(x,y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(&#123;&#125;,&#123;&#125;) <span class="comment">//10, undefined  </span></span><br><span class="line"><span class="comment">//传入了2个空对象,所以函数的第一第二个参数都不会使用函数默认值.第一个参数会尝试解构对象,提取变量x,因为第一个参数传入了一个空对象,所以解构不出变量x,但是这里又在内层设置了一个默认值,所以x的值为10,而第二个参数同样传了一个空对象,不会使用函数默认值,然后会尝试解构出变量y,发现空对象中也没有变量y,但是y没有设置默认值所以解构后y的值为undefined</span></span><br><span class="line"></span><br><span class="line">func (<span class="literal">undefined</span>,&#123;&#125;) <span class="comment">//10,undefined </span></span><br><span class="line"><span class="comment">//第一个参数显式的传入了一个undefined,所以会使用函数默认值为一个空对象,随后和第一行一样尝试解构x发现x为undefined,但是设置了默认值所以x的值为10,而y和上文一样为undefined</span></span><br><span class="line">func(<span class="literal">undefined</span>, <span class="literal">undefined</span>) <span class="comment">//10.10 </span></span><br><span class="line"><span class="comment">//2个参数都会undefined,第一个参数和上文一样,第二个参数会调用函数默认值,赋值为&#123;y:10&#125;,然后尝试解构出变量y,即y为10</span></span><br><span class="line">func() <span class="comment">//10,10</span></span><br><span class="line"><span class="comment">//跟上一个相同 一个是显式传入undefined,一个是隐式不传参数</span></span><br><span class="line">func(&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;,&#123;<span class="attr">y</span>:<span class="number">2</span>&#125;) <span class="comment">//1,2</span></span><br><span class="line"><span class="comment">//直接使用传入的参数,不会使用函数默认值,并且能够顺利的解构出变量x,y</span></span><br></pre></td></tr></table></figure>

<h1 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h1><h2 id="handler-apply"><a href="#handler-apply" class="headerlink" title="handler.apply"></a>handler.apply</h2><p>节流</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="function">(<span class="params">func, time</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> previous =<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">0</span>).getTime()</span><br><span class="line">    <span class="keyword">let</span> handler =&#123;</span><br><span class="line">        <span class="function"><span class="title">apply</span>(<span class="params">target, context, args</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> now =<span class="keyword">new</span> <span class="built_in">Date</span>().getTime(); </span><br><span class="line">            <span class="keyword">if</span> (now - previous&gt;time) &#123; </span><br><span class="line">                previous =now</span><br><span class="line">                <span class="built_in">Reflect</span>.apply(func, context, args)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(func, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DOM.addEventListener(<span class="string">&#x27;mousemove&#x27;</span>,proxy(func,<span class="number">1000</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="handler-contruct"><a href="#handler-contruct" class="headerlink" title="handler.contruct"></a>handler.contruct</h2><p>单例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="function">(<span class="params">func</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> instance;</span><br><span class="line">    <span class="keyword">let</span> handler =&#123;</span><br><span class="line">        <span class="function"><span class="title">contruct</span>(<span class="params">target, args</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(!instance)&#123;</span><br><span class="line">                instance = <span class="built_in">Reflect</span>.contruct(func,args)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(func, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> singlePerson = proxy(Person);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = singlePerson(<span class="string">&#x27;zhangsan&#x27;</span>,<span class="number">21</span>)</span><br><span class="line"><span class="keyword">let</span> p2 = singlePerson(<span class="string">&#x27;lisi&#x27;</span>,<span class="number">21</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p1 === p2)</span><br></pre></td></tr></table></figure>

<h2 id="handler-defineProperty"><a href="#handler-defineProperty" class="headerlink" title="handler.defineProperty"></a>handler.defineProperty</h2><h1 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h1><ol>
<li>从 Reflect 对象上可以拿到语言内部的方法。</li>
<li>操作对象出现报错时返回 false</li>
<li>让操作对象都变为函数式编程</li>
<li>保持和 proxy 对象的方法一一对应</li>
</ol>
]]></content>
      <categories>
        <category>javascript基础</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>怎么让一个div水平垂直居中</title>
    <url>/2021/07/09/%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/</url>
    <content><![CDATA[<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>1.</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative; </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute; </span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 或者 */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">25px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 或 */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.child</span> &#123;</span><br><span class="line">    justify-self: center;</span><br><span class="line">    <span class="attribute">align-self</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器缓存机制</title>
    <url>/2021/05/27/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="浏览器缓存机制"><a href="#浏览器缓存机制" class="headerlink" title="浏览器缓存机制"></a>浏览器缓存机制</h1><p>浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识。<br>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中</p>
<span id="more"></span>

<h1 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h1><p>每次发起请求，都会查询本地缓存，存在缓存且未过期则直接使用，否则向服务端发起请求。</p>
<p>Expires（绝对值）：其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果。<br>缺点：依赖客户端时间，若客户端时间不准确（时区、客户端时间异常），会失效</p>
<p>Cache-Control：</p>
<ol>
<li>public：所有内容都将被缓存（客户端和代理服务器都可缓存）</li>
<li>private：所有内容只有客户端可以缓存，Cache-Control的默认取值</li>
<li>no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定</li>
<li>no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</li>
<li>max-age=600 (相对值)：缓存内容将在xxx秒后失效</li>
</ol>
<p>max-age 优先于Expires</p>
<h1 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h1><p>强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存。<br>若协商缓存生效，服务器返回304<br>否则，服务器返回200</p>
<p>Cache-Control：no-cache</p>
<p>Last-Modified/If-Modified-Since:资源在服务器上的最后修改时间<br>缺点：只能以秒计算，小于秒的更改，无法感知</p>
<p>ETag/If-None-Match:资源文件的唯一标识(由服务器生成)</p>
<h1 id="浏览器缓存位置"><a href="#浏览器缓存位置" class="headerlink" title="浏览器缓存位置"></a>浏览器缓存位置</h1><ol>
<li><p>200 OK (from disk cache) ：硬盘缓存<br>读取速度慢</p>
</li>
<li><p>200 OK (from memory cache) ：内存缓存<br>读取速度快 有时效性(网页关闭则消失)</p>
</li>
<li><p>大一点的文件会缓存在dist里面，因为内存也是有限的，磁盘的空间更大</p>
</li>
<li><p>小一点文件js,图片存的是memory</p>
</li>
<li><p>css文件一般存在dist</p>
</li>
<li><p>特殊情况memory大小是有限制的，浏览器也会根据自己的内置算法，把一部分js文件存到dist里面</p>
</li>
</ol>
<p>浏览器查询次序：内存缓存-&gt;硬盘缓存</p>
<p>打开网页：内存缓存失效，查询硬盘缓存，若有则所有请求使用硬盘缓存，返回200 OK (from disk cache) ，若无，向服务器发送请求，返回200</p>
<p>按F5刷新，js、图片、字体文件使用内存缓存，返回200 OK (from memory cache) ，css资源使用硬盘缓存，返回200 OK (from disk cache)</p>
<p>Ctrl+F5刷新，删除本地缓存，强制从服务器获取。</p>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>Cache-Control: no-store 不使用任何缓存  银行页面<br>Cache-Control: no-cache 强制校验缓存（max-age无效）      实时客车列表<br>Cache-Control: max-age=604800, must-revalidate  网页缓存一周( 604800秒)，一旦这一周结束，需要向服务器查询是否需要更新。   FAQ页面<br>Cache-Control: max-age=31536000, immutable 一直使用缓存     静态的js/css<br>Cache-Control: max-age=2419200, must-revalidate, stale-while-revalidate=86400    存储28天( 2419200秒)，我们要在28天的时间限制后向服务器查询更新，在一周( 86400秒)内，我们可以边查询更新边使用缓存文件     不重要的图片</p>
<h1 id="常用状态码"><a href="#常用状态码" class="headerlink" title="常用状态码"></a>常用状态码</h1><p>200 请求已正常处理<br>200 OK (from memory cache)：强制缓存生效，使用内存缓存<br>200 OK (from disk cache)：强制缓存生效，使用硬盘缓存<br>301:代表永久性转移<br>302:代表暂时性转移<br>304:请求未过期  使用缓存  协商缓存<br>400:请求错误<br>401:未授权<br>403:禁止<br>404:请求的内容不存在<br>410:请求的内容曾经存在<br>500:服务器错误</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>盒子模型</title>
    <url>/2021/07/07/%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="标准盒子模型"><a href="#标准盒子模型" class="headerlink" title="标准盒子模型"></a>标准盒子模型</h1><p>标准 w3c 盒子模型的范围包括 margin、border、padding、content，并且 content 部分不包含其他部分。</p>
<h1 id="ie-盒子模型"><a href="#ie-盒子模型" class="headerlink" title="ie 盒子模型"></a>ie 盒子模型</h1><p>ie 盒子模型的范围也包括 margin、border、padding、content，和标准 w3c 盒子模型不同的是：ie 盒子模型的 content 部分包含了 border 和 pading。</p>
<h1 id="CSS3-box-sizing-属性"><a href="#CSS3-box-sizing-属性" class="headerlink" title="CSS3 box-sizing 属性"></a>CSS3 box-sizing 属性</h1><p>当设置为box-sizing:content-box时，将采用<em>标准模式</em>解析计算，也是默认模式；</p>
<p>当设置为box-sizing:border-box时，将采用<em>怪异模式</em>解析计算；</p>
<p>一般设置为border-box</p>
]]></content>
      <categories>
        <category>css基础</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>深拷贝与浅拷贝</title>
    <url>/2021/04/07/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<p>在开发过程中，我们有时候并不希望引用数据类型的赋值操作中的两个变量相互影响，这就需要浅拷贝和深拷贝<span id="more"></span></p>
<h1 id="变量存储类型"><a href="#变量存储类型" class="headerlink" title="变量存储类型"></a>变量存储类型</h1><p>基本数据类型:值存在栈中，无地址值，例子：string,bool,number,null,undefined,symbol</p>
<p>引用数据类型:值存在堆中，地址存在栈中，例子：数组、对象、函数、正则</p>
<p>栈是自动分配相对固定大小的内存空间，并由系统自动释放,线性结构，后进先出,效率很高，但是分配的内存容量有限。<br>堆是动态分配内存，内存大小不一，也不会自动释放,混沌，杂乱无章，方便存储和开辟内存空间。</p>
<h1 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h1><p>当参数为基本数据类型的时候，为值传递</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">add(a);</span><br><span class="line"><span class="built_in">console</span>.log(a)<span class="comment">//100</span></span><br></pre></td></tr></table></figure>

<p>当参数为引用数据类型的时候，为引用传递</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeAgeImpure</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">    person.age = <span class="number">25</span>;</span><br><span class="line">    <span class="keyword">return</span> person;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> alex = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Alex&#x27;</span>,</span><br><span class="line">    age: <span class="number">30</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> changedAlex = changeAgeImpure(alex);</span><br><span class="line"><span class="built_in">console</span>.log(alex); <span class="comment">// &#123; name: &#x27;Alex&#x27;, age: 25 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(changedAlex); <span class="comment">// &#123; name: &#x27;Alex&#x27;, age: 25 &#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h1><ul>
<li>给定相同的输入，将始终返回相同的输出。</li>
<li>无副作用。不会修改外部的状态。</li>
</ul>
<p>优点：可测试 可缓存  可移植</p>
<h1 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h1><p>符号=就是赋值操作。分为对基本数据类型和引用数据类型赋值两种情况</p>
<h2 id="基本数据类型赋值"><a href="#基本数据类型赋值" class="headerlink" title="基本数据类型赋值"></a>基本数据类型赋值</h2><p>基本数据类型的赋值操作是值引用，相互之间没有影响</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> b = a; <span class="comment">// 将 a 赋值给 b</span></span><br><span class="line">a = <span class="string">&#x27;李四&#x27;</span>; <span class="comment">// 修改 a 的值为 &#x27;李四&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 打印 b 的值，仍为 &#x27;张三&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="引用数据类型赋值"><a href="#引用数据类型赋值" class="headerlink" title="引用数据类型赋值"></a>引用数据类型赋值</h2><p>引用数据类型的赋值是地址引用，两个变量指向同一个地址，相互之间有影响</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  name: <span class="string">&#x27;张三&#x27;</span> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> b = a; <span class="comment">// 将 a 赋值给 b</span></span><br><span class="line">a.name = <span class="string">&#x27;李四&#x27;</span>; <span class="comment">// 修改 a.name 的值为 &#x27;李四&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(b.name); <span class="comment">// 打印 b.name 的值，变为 &#x27;李四&#x27;</span></span><br></pre></td></tr></table></figure>
<h1 id="对象的遍历"><a href="#对象的遍历" class="headerlink" title="对象的遍历"></a>对象的遍历</h1><p>对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="comment">//  &#123;</span></span><br><span class="line"><span class="comment">//    value: 123,</span></span><br><span class="line"><span class="comment">//    writable: true,</span></span><br><span class="line"><span class="comment">//    enumerable: true,</span></span><br><span class="line"><span class="comment">//    configurable: true</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br></pre></td></tr></table></figure>
<p>描述对象的enumerable属性，称为“可枚举性”，如果该属性为false，就表示某些操作会忽略当前属性。</p>
<p>目前，有四个操作会忽略enumerable为false的属性。</p>
<ul>
<li>for…in循环：只遍历对象自身的和继承的可枚举的属性。</li>
<li>Object.keys()：返回对象自身的所有可枚举的属性的键名。</li>
<li>JSON.stringify()：只串行化对象自身的可枚举的属性。</li>
<li>Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。</li>
</ul>
<p>只有for…in会返回继承的属性，其他三个方法都会忽略继承的属性</p>
<h1 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h1><p>浅拷贝只拷贝原对象的第一层属性。即拷贝A对象里面的数据，但是不拷贝A对象里面的子对象。</p>
<p>实现一个浅拷贝</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对 obj 进行浅拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowCopy</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span> &amp;&amp; obj !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> copy = <span class="built_in">Array</span>.isArray(obj) ? [] : &#123;&#125;;</span><br><span class="line">    <span class="comment">// 遍历原对象 obj，将第一层属性赋值给新对象</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> p <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      copy[p] = obj[p]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回的新对象就是浅拷贝后的对象</span></span><br><span class="line">    <span class="keyword">return</span> copy</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是基本类型，直接返回</span></span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常用的浅拷贝</p>
<ol>
<li>Object.assign()</li>
<li>Array.concat()</li>
<li>{ …obj }</li>
</ol>
<h1 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h1><p>深拷贝是从内存中完整的拷贝一份出来，在堆内存中开一个新的内存空间，与原对象完全独立。修改新对象不会影响原对象。</p>
<p>实现一个深拷贝</p>
<h2 id="JSON-parse-JSON-stringify"><a href="#JSON-parse-JSON-stringify" class="headerlink" title="JSON.parse(JSON.stringify())"></a>JSON.parse(JSON.stringify())</h2><p>缺陷：不可以拷贝 undefined、Symbol、函数、正则、循环引用 等等类型的</p>
<h2 id="浅拷贝-递归"><a href="#浅拷贝-递归" class="headerlink" title="浅拷贝+递归"></a>浅拷贝+递归</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">target </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果是一个数组的话</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(target)) &#123;</span><br><span class="line">            result = []; <span class="comment">// 将result赋值为一个数组，并且执行遍历</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> target) &#123;</span><br><span class="line">                <span class="comment">// 递归克隆数组中的每一项</span></span><br><span class="line">                result.push(deepClone(target[i]))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断如果当前的值是null的话；直接赋值为null</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(target===<span class="literal">null</span>) &#123;</span><br><span class="line">            result = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 判断如果当前的值是一个RegExp对象的话，直接赋值</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(target.constructor===<span class="built_in">RegExp</span>)&#123;</span><br><span class="line">            result = target;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则是普通对象，直接for in循环，递归赋值对象的所有值</span></span><br><span class="line">            result = &#123;&#125;;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> target) &#123;</span><br><span class="line">                result[i] = deepClone(target[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 如果不是对象的话，就是基本数据类型，那么直接赋值</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript基础</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>shadowsocks搭建VPN</title>
    <url>/2016/06/23/%E7%BF%BB%E5%A2%99%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h4 id="购买服务器"><a href="#购买服务器" class="headerlink" title="购买服务器"></a>购买服务器</h4><span id="more"></span>

<pre><code>https://www.openvzvps.cc/aff.php?aff=259
</code></pre>
<h4 id="修改安装的系统并安装服务"><a href="#修改安装的系统并安装服务" class="headerlink" title="修改安装的系统并安装服务"></a>修改安装的系统并安装服务</h4><p>在 客户中心-&gt;我的产品与服务 将预装的centos重装为ubunt<br>用xshell进入后台  </p>
<pre><code>apt-get update
apt-get install python-gevent python-pip
apt-get install python-m2crypto
pip install shadowsocks
</code></pre>
<h4 id="添加配置文件并启动服务"><a href="#添加配置文件并启动服务" class="headerlink" title="添加配置文件并启动服务"></a>添加配置文件并启动服务</h4><p>下载<a href="/uploads/shadowsocks.rar">shadowsocks.rar</a><br>修改里面的shadowsocks.json  </p>
<pre><code>&#123;
    &quot;server&quot;:&quot;0.0.0.0&quot;,
    &quot;server_port&quot;:xxxx,  //端口
    &quot;password&quot;:&quot;xxxxxx&quot;, //密码
    &quot;timeout&quot;:600,
    &quot;method&quot;:&quot;aes-256-cfb&quot;
&#125; 
</code></pre>
<p>将文件夹上传到root目录，然后</p>
<pre><code>bash restart.sh
bash check.sh
</code></pre>
<h4 id="下载客户端"><a href="#下载客户端" class="headerlink" title="下载客户端"></a>下载客户端</h4><pre><code>windows: https://shadowsocks.org/en/download/clients.html
android: https://github.com/shadowsocks/shadowsocks-android/releases
</code></pre>
]]></content>
      <tags>
        <tag>shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title>箭头函数与普通函数的区别</title>
    <url>/2021/07/16/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<ol>
<li>箭头函数没有arguments（建议使用更好的语法，剩余运算符替代）</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(...rest)=&gt;&#123;</span><br><span class="line">    consle.log(rest)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>箭头函数没有prototype属性，不能用作构造函数（不能用new关键字调用）</li>
</ol>
<ol start="3">
<li>箭头函数没有自己this，它的this是词法的，引用的是上下文的this，即在你写这行代码的时候就箭头函数的this就已经和外层执行上下文的this绑定了(这里个人认为并不代表完全是静态的,因为外层的上下文仍是动态的可以使用call,apply,bind修改,这里只是说明了箭头函数的this始终等于它上层上下文中的this)</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> T =&#123;</span><br><span class="line">    a:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span>)&#125;,</span><br><span class="line">    b:<span class="function">()=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="string">&#x27;b&#x27;</span>)&#125;,</span><br><span class="line">    <span class="function"><span class="title">c</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">&#x27;c&#x27;</span>)&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T.a();</span><br><span class="line">T.b();</span><br><span class="line">T.c();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> T.a();</span><br><span class="line"><span class="keyword">new</span> T.b();<span class="comment">//报错  箭头函数没有prototype属性</span></span><br><span class="line"><span class="keyword">new</span> T.c();<span class="comment">//报错  简写的对象方法不能用作构造函数  没有prototype属性</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>
<p>new的过程拆分成以下三步：</p>
<ol>
<li>var p={}; 也就是说，初始化一个对象p</li>
<li>p.<strong>proto</strong> = Person.prototype;</li>
<li>Person.call(p); 也就是说构造p，也可以称之为初始化</li>
</ol>
]]></content>
      <categories>
        <category>javascript基础</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>防抖节流</title>
    <url>/2021/04/02/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<h1 id="防抖-debounce"><a href="#防抖-debounce" class="headerlink" title="防抖 debounce"></a>防抖 debounce</h1><p>在一段时间内，不论调用多少次回调，都以最后一次为准。(将多次执行变为最后一次执行)<span id="more"></span></p>
<p>应用场景：页面resize事件，只有最后一次是有用</p>
<p>思路：使用定时器执行函数，新调用发生时如果旧调用没有执行就清除之前的定时器。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn,delay</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        &#125;</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>); <span class="comment">// 用apply指向调用debounce的对象，相当于_this.fn(args);</span></span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showTop</span>  (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scrollTop = <span class="built_in">document</span>.body.scrollTop || <span class="built_in">document</span>.documentElement.scrollTop;</span><br><span class="line">　　<span class="built_in">console</span>.log(<span class="string">&#x27;滚动条位置：&#x27;</span> + scrollTop);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.onscroll = debounce(showTop,<span class="number">1000</span>) </span><br></pre></td></tr></table></figure>


<h1 id="节流-throttle"><a href="#节流-throttle" class="headerlink" title="节流 throttle"></a>节流 throttle</h1><p>限制一个函数在一定时间内只能执行一次。(将多次执行变成每隔一段时间执行)</p>
<p>应用场景： 输入框补全提示，只需要每两秒补全一次</p>
<p>思路：利用时间戳判断，每次调用判断和上一次调用的时间差异确定是否需要调用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn,delay</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pre = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> now = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line">        <span class="keyword">if</span>(now-pre&gt;delay)&#123;</span><br><span class="line">            fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">            pre = now</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showTop</span>  (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scrollTop = <span class="built_in">document</span>.body.scrollTop || <span class="built_in">document</span>.documentElement.scrollTop;</span><br><span class="line">　　<span class="built_in">console</span>.log(<span class="string">&#x27;滚动条位置：&#x27;</span> + scrollTop);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.onscroll = throttle(showTop,<span class="number">1000</span>) </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript基础</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器输入url到页面展示的过程</title>
    <url>/2021/05/27/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>前端常见面试题</p>
<span id="more"></span>
<h1 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h1><p>dns解析过程：</p>
<ol>
<li>浏览器缓存</li>
<li>系统缓存<br> Windows中可以通过C:\Windows\System32\drivers\etc\hosts</li>
<li>路由器缓存</li>
<li>ISP（互联网服务提供商）DNS缓存<br> 互联网服务提供商，有联通电信移动等，跟网络配置中的”DNS服务器地址”相同，以下简称本地DNS服务器。</li>
<li>根域名服务器<br> 本地DNS服务器向根域名服务器查询<br> 根域：一个完整域名最后面的那个点，通常省略不写（假设要查询ke.qq.com(ke.qq.com.)，该域名的根域就是.）</li>
<li>顶级域名服务器<br> 本地DNS服务器向顶级域名服务器查询<br> 顶级域:（假设要查询ke.qq.com，该域名的根域就是com）</li>
<li>二级域名服务器<br> 本地DNS服务器向二级域名服务器查询<br> 二级域:（假设要查询ke.qq.com，该域名的根域就是qq）</li>
<li>不断往下递归查找</li>
<li>保存结果至缓存</li>
</ol>
<h1 id="发起TCP连接"><a href="#发起TCP连接" class="headerlink" title="发起TCP连接"></a>发起TCP连接</h1><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>刚开始客户端处于 closed 的状态，服务端处于 listen 状态</p>
<ol>
<li>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 SYN_Send 状态。</li>
<li>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。</li>
<li>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 establised 状态</li>
<li>服务器收到 ACK 报文之后，也处于 establised 状态，此时，双方以建立起了链接。</li>
</ol>
<p>如果是https,三次握手之后进行<a href="/2021/05/27/http%E4%B8%8Ehttps%E7%9A%84%E5%8C%BA%E5%88%AB/">ssl握手</a>。</p>
<h3 id="三次握手的作用"><a href="#三次握手的作用" class="headerlink" title="三次握手的作用:"></a>三次握手的作用:</h3><ol>
<li>确认双方的接受能力、发送能力是否正常。</li>
<li>指定自己的初始化序列号，为后面的可靠传送做准备。</li>
<li>如果是 https 协议的话，三次握手这个过程，还会进行数字证书的验证以及加密密钥的生成到。</li>
</ol>
<h3 id="（ISN）是固定的吗"><a href="#（ISN）是固定的吗" class="headerlink" title="（ISN）是固定的吗:"></a>（ISN）是固定的吗:</h3><p>三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。</p>
<p>如果ISN是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。</p>
<h3 id="什么是半连接队列"><a href="#什么是半连接队列" class="headerlink" title="什么是半连接队列:"></a>什么是半连接队列:</h3><p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。<br>当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</p>
<h3 id="三次握手过程中可以携带数据吗"><a href="#三次握手过程中可以携带数据吗" class="headerlink" title="三次握手过程中可以携带数据吗"></a>三次握手过程中可以携带数据吗</h3><p>第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。</p>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><ol>
<li>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于FIN_WAIT1状态。</li>
<li>第二次握手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT状态。</li>
<li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。</li>
<li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态</li>
<li>服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</li>
</ol>
<h3 id="为什么客户端发送-ACK-之后不直接关闭，而是要等一阵子才关闭"><a href="#为什么客户端发送-ACK-之后不直接关闭，而是要等一阵子才关闭" class="headerlink" title="为什么客户端发送 ACK 之后不直接关闭，而是要等一阵子才关闭"></a>为什么客户端发送 ACK 之后不直接关闭，而是要等一阵子才关闭</h3><p>客户端要确保服务器是否已经收到了我们的 ACK 报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 ACK 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。</p>
<p>TIME_WAIT 持续的时间至少是一个报文的来回时间。一般会设置一个计时，如果过了这个计时没有再次收到 FIN 报文，则代表对方成功就是 ACK 报文，此时处于 CLOSED 状态。</p>
<h1 id="发送HTTP请求"><a href="#发送HTTP请求" class="headerlink" title="发送HTTP请求"></a>发送HTTP请求</h1><p><a href="/2021/05/27/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/">强制缓存和协商缓存</a></p>
<h1 id="服务器处理请求并返回HTTP报文"><a href="#服务器处理请求并返回HTTP报文" class="headerlink" title="服务器处理请求并返回HTTP报文"></a>服务器处理请求并返回HTTP报文</h1><p><a href="/2021/05/27/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/">常用状态码</a></p>
<h1 id="浏览器解析渲染页面"><a href="#浏览器解析渲染页面" class="headerlink" title="浏览器解析渲染页面"></a>浏览器解析渲染页面</h1><ol>
<li>解析HTML形成DOM树</li>
<li>解析CSS形成CSSOM 树</li>
<li>合并DOM树和CSSOM树形成渲染树</li>
<li>浏览器开始渲染并绘制页面</li>
</ol>
<h2 id="js-css-顺序对前端优化影响"><a href="#js-css-顺序对前端优化影响" class="headerlink" title="js css 顺序对前端优化影响"></a>js css 顺序对前端优化影响</h2><ul>
<li><p>首先获取 html 文件，构建 DOM 树，这个过程是边下载边解析，并不是等 html 文件全部下载完了，再去解析 html，这样比较浪费时间，而是下载一点解析一点</p>
</li>
<li><p>css 文件也是一边下载一边解析的</p>
</li>
<li><p>css 放头部,js 放尾部<br>  渲染树的构成必须要 DOM 树和 CSSOM 树的，所以尽快的构建 CSSOM 树是一个重要的优化手段，如果 css 文件放在尾部，那么整个过程就是一个串行的过程先解析了 dom，再去解析 css。所以 css 我们一般都是放在头部，这样 DOM 树和 CSSOM 树的构建是同步进行的。<br>  因为 js 的运行会阻止 DOM 树的渲染的，所以一旦我们的 js 放在了头部，而且也没有异步加载这些操作的话，js 一旦一直在运行，DOM 树就一直构建不出来，那么页面就会一直出现白屏界面，所以一般我们会把 js 文件放在尾部。当然放到尾部也不是就没有问题了，只是问题相对较小，放到尾部的 js 文件如果过大，运行时间长，代码加载时，就会有大量耗时的操作造成页面不可点击，这就是另一个问题，但这肯定比白屏要好，白屏是什么页面都没有，这种是页面有了只是操作不流畅。</p>
<p>  js 脚本放在尾部还有一个原因，有时候 js 代码会有操作 dom 节点的情况，如果放在头部执行，DOM树还没有构建，拿不到 DOM 节点但是你又去使用就会出现报错情况，错误没处理好的话页面会直接崩掉</p>
</li>
</ul>
<h2 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h2><p>重绘指的是不影响界面布局的操作，比如更改颜色，那么根据上面的渲染讲解我们知道，重绘之后我们只需要在重复进行一下样式计算，就可以直接渲染了，对浏览器渲染的影响相对较小</p>
<h2 id="重排"><a href="#重排" class="headerlink" title="重排"></a>重排</h2><p>重排指的是影响界面布局的操作，比如改变宽高，隐藏节点等。对于重排就不是一个重新计算样式那么简单了，因为改变了布局，根据上面的渲染流程来看涉及到的阶段有样式计算，布局树重新生成，分层树重新生成，所以重排对浏览器的渲染影响是比较高的</p>
<h2 id="避免方法"><a href="#避免方法" class="headerlink" title="避免方法"></a>避免方法</h2><p>js 尽量减少对样式的操作，能用 css 完成的就用 css<br>对 dom 操作尽量少，能用 createDocumentFragment 的地方尽量用<br>如果必须要用 js 操作样式，能合并尽量合并不要分多次操作<br>resize 事件 最好加上防抖，能尽量少触发就少触发<br>加载图片的时候，提前写好宽高</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
</search>
